         ,-----.      MMMMM      l
   /\j__/\  (  \`--.    M   OOO  ll   º  N.  N
   \`@_@'/  _)  >--.`.  M  O   O ll   I  N N N
  _{.:Y:_}_{{_,'    ) ) m  O   O ll   Ii N  'n
 {_}`-^{_} ```     (_/  M   OOO   lll Ii n   N  Versión Alfa.

Modo de uso:
   tolin [-cbdiehstSOEHTBF][-man][-ts][-seed][-ss|se|si] -f [path]file-input | foo 
         <-t [path]filemacro | 'script-macro'> [> file][| commando]

   -i n            línea inicial de proceso.
   -e n            línea final de proceso.
   -h              esta ayuda.
   -man            manual de funciones y operadores de macros Tolin.
   -s              estadísticas del archivo. Sirve para saber si se podrá procesar con Tolin.
                   Esta opción anula todas las demás, excepto '-fb'.
   -S n            número de líneas a saltar luego de procesada una línea (Skip o incremento).
   -O              (Odd)  procesa solo líneas impares. Si el proceso inicia en una línea par, esta es omitida.
   -E              (even) procesa líneas pares. Si el proceso inicia en una línea impar, esta es omitida.
   -H n            procesa las 'n' primeras líneas del archivo. Similar a HEAD de Linux.
   -T n            procesa las 'n' últimas líneas del archivo. Similar a TAIL de Linux.
   
   -ss "string"    busca un string en cada línea procesada: si lo encuentra, la línea se procesa; sino, la
                   línea se omite. El string puede ser un substring. Si "string" es "COM", serán matches
                   "LOCOMOCION","COMO" y "COMODO". 
                   La búsqueda es case sensitive, o sea, distingue entre mayúsculas y minúsculas...
                   ¿Sabes cuál es la versión mayúscula del número 5? Resp: V.
   -se "string"    idem a '-ss', pero el string debe ser exacto. Si "string" es "COM", no serán matches
                   "LOCOMOCION","COMO" ni "COMODO".
                   La búsqueda es case sensitive.
   -si             define que las búsquedas realizadas sean case insensitive. Esta opción influye sobre
                   los siguientes comandos y opciones de búsqueda:
                   * -ss y -se
                   * operadores "-" y "^" sobrecargados.
                   * operadores "&" y "|" sobrecargados.
                   * funciones AT, RAT, AF, y MATCH.
   
   -B v
   -B 'v0 v1..'    añade valores al BUFFER, que puede ser usado por LET y LIN.                             
                   Usar el BUFFER para guardar valores es como usar variables globales. Uselas.

   -f              indica el archivo a procesar. Puede añadir una ruta.
   -f foo          Puede usar este archivo ficticio para procesar comandos sin la presencia de datos de un
                   archivo. Normalmente se usa en iteraciones POOL/LOOP y con COPY.
                   Ejemplo: 
                    tolin -f foo 'macros...'
                    
   -F              procesa un lote de archivos, indicados con comodines. 
                   Ejemplo: 
                     tolin -F *.txt 'script...'

   -c 'comando'    ejecuta un comando del sistema operativo, y procesa el resultado.
                   Ejemplo:
                     El siguiente comando imprime el total de bytes del directorio actual:
                       tolin -c 'ls -l' -B 0 'buff let(1,(#1+$5))' ==> 210290615
                     
                     El siguiente comando hace lo mismo, pero incluye su valor en KB:
                       tolin -c 'ls -l' -B '0 0' 'buff let(1,(#1+$5)) let(2,str(#1/1024)+" Kb")'
                       ==> 210291127 205362.43 Kb
                     
                     Idem, pero usando CAT en vez de concatenación "+":
                       tolin -c 'ls -l' -B '0 0' 'buff let(1,(#1+$5)) let(2,{(#1/1024)," Kb"})'
                       ==> 210291127 205362.43 Kb
                     con CAT '{}' no hace falta convertir la operación a string 'str(n)'.
                     
                     El siguiente, usa la codificación del sistema para procesar un archivo con caracteres
                     binarios:
                       tolin -c 'cat nuevo.txt' '#'
                     Hace lo mismo que:
                       tolin -f nuevo.txt -b 'ansi(#)'
                     
   -t              indica un archivo de macros, alternativo a 'script'.
   -b              fuerza procesamiento sobre archivo binario. Un archivo binario, para Tolin, es aquel que
                   contiene carcateres ASCII menores a 32 y distintos a 9, 10 y 13. Si tiene un archivo de datos
                   que no debería tener estos caracteres, use '-b' para forzar su proceso.

   -d n            define una precisión decimal para todos los cálculos de Tolin. Por default, es 2. Se acepta
                   un valor entre 0 y 15, aunque la máquina de la actual arquitectura solo garantiza hasta 12 o
                   13 decimales correctos, con cuea.
                   Ejemplos:
                     tolin -f foo '10/2345'        ==> 0.00
                     tolin -f foo -d 4 '10/2345'   ==> 0.0043
                     tolin -f foo -d 7 '10/2345'   ==> 0.0042644
                     tolin -f foo -d 13 '10/2345'  ==> 0.0042643923241

   -ts "sep"       define un separador global de tokens. Será usado por las funciones de token de Tolin.
                   Su valor será alterado por DEFT().
                   El separador por default es ASCII 32 (espacio en blanco).

   -seed n         define una semilla para el generador de números aleatorios de Tolin.
                     
 [-] 'script'      script de comandos que procesarán el archivo.
                   Use el guión '-' antes de 'script' si este viene a continuación del parámetro '-F'.
                   Ejemplo:
                    tolin -F *.txt - 'void at{"base"}?#;' -H 10  /* '-' necesario */
                    tolin -F *.txt -H 10 'void at{"base"}?#;'    /* '-' no necesario */
                   
      strings      Los strings en Tolin son encerrados entre comillas (", o ASCII 34 - ch(34)).
                   Ejemplo:
                     "hola mundo!"      ==>  válido  = hola mundo!
                     'hola mundo!'      ==>  no es válido.

      números      Tolin no se ciñe al tratamiento numérico de Harbour, por lo que puede operar con números
                   mayores a dicho límite, pero en formato de notación científica.
                   Un número en notación científica válido es el siguiente:
                     n.mE|e[-+]exp
                   Ejemplo:
                      1E10                   no es válido: falta punto decimal.
                      1.0e10                 es válido.
                      4.56E-16               es válido.
                      1.2E190/1.0e126+11.45  es una operación válida.
                      tolin -f foo '1.20892e-8+10000'             ==> 10000.00  válido.
                      tolin -f foo 'round((1.20892e-8+10000),15)' ==> 10000.000000012090000  válido.
                         
      código '\'   Caracter de escape usado dentro del script. 
                   \" : se usa para que Tolin pueda reconocer comillas. 
                   \n : se usa para incluir un salto de línea en el string de salida.
                   Ejemplo:
                     "\"hola mundo!!\"" ==>  válido  = "hola mundo!"
                     "hola\nmundo!"     ==>  válido  = hola
                                                       mundo!
                   
                   EXCEPCIONES: el comando CLEAR, en Tolin, limpia el BUFFER. Además, los comandos SAVE y LOAD
                   no tienen uso con Tolin, y el comando FILE, que devuelve el nombre del archivo procesado,
                   no existe en Edit4XU. Asimismo, \n no existe en Edit4XU, pero sí existe \".

  OBSERVACIONES.
       Tolin carga y analiza el archivo de entrada antes de procesarlo con los comandos y funciones de
       macros de Edit4Xu. Dicho procedimiento de carga es necesario para configurar el archivo lo más correcto
       posible. Esto hace que Tolin sea un poco más lento que sus compañeros, pero gana en otras cosas.
       Otras observaciones son las siguientes:

           * La salida del proceso será la consola, o un archivo, si redirige la salida con '>' o '|',
           * Aparte, puede obtener una salida alternativa usando el BUFFER de Tolin. La función
             COPY copia datos al BUFFER.
           * El BUFFER es guardado al finalizar el proceso, en un archivo que tiene como nombre la
             fecha y la hora actual, más '.buffer'. Por ejemplo, si usted usó el BUFFER para guardar
             datos, el archivo de salida del BUFFER será:
                     20191201_130435.buffer
             Si usa la opción RESET, el BUFFER será guardado de manera diferente (ver RESET más adelante).
           * Las opciones '-ie' son INCOMPATIBLES con '-HT'.
           * La opción '-f' es INCOMPATIBLE con '-F'.
           * La opción '-c' es INCOMPATIBLE con '-fF'.
           * Tolin no admite pipeline como datos de entrada. Debe usar '-fF'.
           * Por defecto, Tolin lee archivos UTF8 y US-ASCII, y no hace conversión de codepage.
             Sin embargo, hace un esfuerzo. Intente '-s' para saber si su archivo puede ser procesado, y lo
             invito a probar las macros "UTF8()" y "ANSI()".

  EJEMPLOS.
        1) Si un archivo 'nuevo.txt' contiene un caracter anómalo (e.g. #1), el comando:

                     tolin -f nuevo.txt -b 'void at{ch(1)}?#:tr{ch(1),""};'

           podrá procesarlo, reemplazando ASCII 1 por nada. Debe usar '-b'.
           El comando VOID indica que deben incluirse las líneas en blanco en el proceso.
           La función TR reemplaza todo lo que encuentre en la línea.
           La función AT devuelve la posición del primer match, sin importar si es una palabra completa
           o es parte de otra. La función AF busca el match exacto y completo.

        2) Si 'prog.c' tiene una codificación US-ASCII o ISO-8859xx, es posible que use #10 y #13
           como salto de línea. Para eliminar #13, basta con hacer esto:

                     tolin -f prog.c 'void #'

        3) Suponga un programa Harbour donde se haya escrito en duro el caracter flecha (#16), en
           muchas líneas. Para reparar eso, puede usar la siguiente línea:

                     tolin -f clrsel.prg -b 'void at{ch(16)}?#:tr{("\""+ch(16)+"\""),"chr(16)"};'

           Aparte de eliminar los #13 sobrantes (propio de codificación US-ASCII), busca el caracter
           anómalo (AT); si no lo encuentra, libera la línea completa. Pero, si lo encuentra, reemplaza
           el caracter "->", por "chr(16)", la función.

        4) Para conocer la estadística de un grupo de archivos:

                     tolin -F datos/*.csv -s

        5) Para procesar un grupo de archivos. La salida será única, así como los datos almacenados en
           el BUFFER con COPY, si no usa RESET:

                     tolin -F datos/*.csv 'void match{"CTAAGH"}?:{I,{"  :  ",#}};'

           Buscará exactamente 'CTAAGH'; si lo encuentra, despliega la línea con el número de línea.
           Si no lo encuentra, no hace nada (eso quiere decir '?:')
        
        6) Usando un archivo ficticio "foo", se ejecuta una iteración que llena el BUFFER con la glosa
           de cada cifra de 100 cifras:
           
                     tolin -f foo '@1(0)@2(0) pool @2(gloss(@1)) copy(@2) @1(@1+1) loop(101-@1)'
           
           Su salida será un archivo ".buffer" con lo siguiente:
                            cero
                            uno
                            ...
                            noventa y nueve
                            cien
  
   ¿Qué hace Tolin, exactamente?
            Iterará cada línea indicada del archivo o los archivos, y será usada como argumento
            de la expresión del script.
            Si cae en un loop infinito, puede abortar con ALT-C (en Linux).
   
   Importante
            Un resultado válido será extraído de la pila de operaciones. Si la pila
            está vacía, no devolverá nada, pero si tiene más de un elemento, Tolin
            arrojará error. Un ejemplo de esto último es el siguiente:
            @1(5)
            (#+@1)   ==> deja un resultado en la pila
            (#-@1)   ==> no toma el elemento de la pila, sino que deja otro.
            En este caso, Tolin arroja un error de "Expresión mal formada".
            
            Además, el analizador sintáctico de Tolin no es "Turing-decidible", por
            la existencia de registros de memoria, y un par de funciones que no
            dejan nada en la pila de operaciones. Sin embargo, una expresión sí
            puede ser "Turing-decidible" si es una expresión bien formada.

   Expresión bien formada
            Una expresión "bien formada" es aquella que termina con un único
            resultado en la pila de proceso.
   
   Ejemplo de expresión bien formada:
            if(match{"código\;santiago"},up(tri(#)),nop)
            
            Si en la línea procesada existen las palabras "código" y "santiago",
            quitará los espacios en blanco de la línea, y la convertirá en
            mayúsculas; luego, la dejará en la pila. De lo contrario, dejará un
            caracter nulo. Tolin detecta si en la pila no hay nada, y no altera
            la fuente.
   
   Ejemplo de expresión no válida:
            @1(5)

            "5" es guardado en registro 1, pero no deja nada en la pila. 
            Un resultado válido sería el siguiente:
            @1(5)
            @1    ==> esto, aunque parezca huevón, deja un resultado en la pila.

   Expresiones "{}"
            Estas expresiones operan sobre la línea procesada ORIGINAL. Esto quiere decir
            que una expresión como esta:
               tolin -f ropa-de-dalien 'pool  /* ver estructuras de ciclo después */
                                           tre{"rancio","oloroso"}
                                        loop(at{"rancio"})'
            Caerá en un loop infinito si encuentra una línea con la palabra "rancio".
            El ejemplo es mierda pura, porque POOL no es necesario, pero sirve para
            exponer el punto.
            Explicación: TRE reempazará "rancio" por "oloroso" en la línea original, y
            dejará el resultado en la pila de resultados. Pero, AT tomará la línea
            original, no la pila de resultados, y volverá a encontrar "rancio".
            ¿Solución? Esta es una posible solución (puede haber más):
               tolin -f ropa-de-dalien '@1(#)  /* asigna la línea a registro 1 */
                                        pool 
                                           @1(tre(@1,"pedro","PEDRO")) 
                                        loop(at(@1,"pedro")) 
                                        @1  /* libera registro 1 */'
            O mejor aún:
               tolin -f ropa-de-dalien 'match{"rancio"}?tre{"rancio","oloroso"};'
            
            O nivel dios:
               tolin -f ropa-de-dalien 'tre{"rancio","oloroso"}'
   
            
  NOCIONES DEL LENGUAJE DE MACROS DE TOLIN.

   Operadores aritméticos: 
   
   +, -, *, /, \(div. entera), %(resto modulo), ^(potencia).
   
   Operadores lógicos:
   
   =, <, >, <=, >=, <>, ~ (negación).
            
            Devolverán "0" si la condición se cumple; de lo contrario,
            devolverán "1".
            Operaciones lógicas y aritméticas deben ir entre paréntesis.
      
      "~"   Niega un resultado numérico: si "n" es 0, "~n" es 1, y si
            "n" es distinto de "0" (puede ser negativo), "~n" es 0. 
            Util.

   Los siguientes operadores trabajan con números de 32 bits:
   
   &                 AND binario. Ejemplo 0x100101b & 25, 0xFFh & 0x00101.
   |                 OR BINARIO.
   !                 XOR BINARIO.
   >>                Desplazamiento hacia la derecha. Ejemplo: 1>>2.
   <<                Desplazamiento hacia la izquierda, Ejemplo: 1<<2.                     

   Números negativos:
   
            Deben ser escritos entre paréntesis.

   NOTA: todas las funciones y atajos deben ser escritas con
         minúsculas. Aquí las escribo con mayúscula porque soy
         choro.

   Comentarios:
                     Acepta comentarios de bloque /* ... */


   Variables globales y sentencias de operación y configuración:
   
   
   I                 Variable que contiene el número de la línea que se
                     está procesando.
                     
   L                 Variable que contiene la longitud de la línea original
                     que se está procesando. Dicho valor no será alterado
                     por subsguientes alteraciones de esa línea.
   
   NT                Número total de tokens de la línea procesada. Su valor
                     depende de la función DEFT(), descrita más adelante.

   NOP               Instrucción pedorra cuyo único objetivo es dejar un
                     caracter nulo en la pila de resultados. Es muy útil
                     para usarlo con IFxx(), porque, a veces, no se necesita
                     un "ELSE". 

   NULL              Puesta al principio de la expresión, provoca que
                     la iteración termine cuando encuentre una línea
                     vacía.
                     
   VOID              Indica a Tolin que si un resultado es vacío, lo añada a
                     la pila de resultados. Sin este flag, los resultados
                     vacíos no son considerados. Esto no tiene nada que ver
                     con la función COPY.
   
   RESET             Resetea el BUFFER en cada cambio de archivo. Esto incluye
                     los valores del espacio de variables del BUFFER (declarados
                     con '-B'), los que vuelven a su declaración original.
                     Al final de cada archivo, si existen valores adicionales
                     a las variables globales en el BUFFER, se guardará dicho
                     contenido en un archivo cuyo nombre será el nombre del
                     archivo, más ".buffer".

   BUFF              Incluye el contenido de las variables globales defindas
                     por la opción '-B' en la salida del programa.

   CLEAR             Elimina el contenido del BUFFER.


   Registros de memoria.
   
                     Son variables. Existen 10 registros de memoria que
                     pueden ser usados en una expresión, y creo que es
                     mucho.
                     Dichas memorias son inicializadas en cada ejecución,
                     y pueden contener valores de distinto tipo en su
                     ciclo de vida.

   MOV(n,valor)      Mueve un valor al registro "n". Ejemplo:
                     mov(2,100)
                     mueve el valor 100 al registro 2

      @n(valor)      Idem. Es más corto y elegante. Ejemplo:
                     @2(100)

   VAR(n)            Obtiene un valor de un registro "n". Ejemplo:
                     var(2)
                     obtiene el valor guardado en el registro 2.

      @n             Idem.
      
      Importante     Los registros de memoria fueron incluidos para solventar
                     procesos complejos de edición; sin embargo, pueden ser
                     mal usados, como por ejemplo, @n(v) no deja ningún 
                     valor en la pila, y eso está mal. Se resuelve si se
                     escribe: @n(v) @n.
                     Los registros son solo temporales, no globales, se
                     resetean con cada iteración.
      
      RECORDAR
                     Tolin no procesa un grupo de expresiones: procesa una sola
                     expresión, que puede tener "saltos" (como una función
                     discontinua reparable), pero no debe indefinirse.
                     Cuando una expresión se "indefine", es cuando devuelve más
                     de un resultado, y eso Tolin no lo dejará pasar.
                     Tolin puede aceptar saltos de línea para ordenar el código
                     y para ayudar a la comprensión del mismo, pero al final
                     procesará dicho código como una sola línea.



   Estructura de Ciclo.

   
                     POOL/LOOP es una estructura de iteración. Pueden haber
                     "pozos" anidados, aunque no se me ocurre para qué.

   POOL              Entra al "pozo", al ciclo iterativo.

   LOOP(n)           Vuelve al principio del ciclo, si "n" es distinto de 0.
                     si "n" es 0, sale. Ejemplo:
                     
                     Se tiene en archivo:
                     
                     mensaje es total
                     mensaje es total
                     mensaje es total
                     
                     y se añade este valor al BUFFER mediante '-B 0':
                     
                     0
                     
                     Pruebe el siguiente código:
                     
                null                     /* termina en linea en blanco */
                deft(" ")                /* define un tokenizer local */
                @1(tri(#))               /* asigno tri(#) a registro 1 */
                pool                     /* entra al pozo */
                   let(1,(#1+1))         /* incremento de valor línea 1 */ 
                   @2(tk(@1,#1))         /* dejo token #1 en registro 2 */ 
                   @3( {{@3,"..."},@2} ) /* operacion generica, dejo en 3 */
                loop(nt-#1)              /* total - token actual != 0 ? */
                @3                       /* dejo registro 3 en pila */
                let(1,0)                 /* dejo valor de línea 1 en 0 */
                     
                     Muestra:
                     mensaje...es...total
                     mensaje...es...total
                     mensaje...es...total
                
                     NOTA: el recurso de la línea 1 como variable global de proceso
                     estaba antes de la inclusión de los registros de memoria.


   Sobrecarga de operadores.

                     Algunos operadores, tanto aritméticos como operadores de bits, 
                     están sobrecargados con funciones especiales de proceso de cadenas.
                     Estas son esas funciones:

        Sean S, S1, S2 cadenas, y N un número.
        
        S1+S2        Idem a CAT(S1,S2), pero no es CAT.

        S+N, N+S     Iden a PTRP(S,N)

        S-N, N-S     Idem a PTRM(S,N). Ejemplo:
                     #-(len(#)-rat{"//"})
                     borra los comentarios de línea "//".
                     
        S1-S2        Elimina exactamente S2 desde S1. Ejemplo:
                     "María tenía un corderito"-"tenía"
                 ==> "María  un corderito"
                     Funciona como la búsqueda de CTRL-NN de ED4XU, con la opción
                     "full", y reemplazo por nada.

        S*N, N*S     Idem a CP(S,N)

        S1*S2        Mezcla S1 con S2. Ejemplo:
                     "Hola!"*" " ==> "H o l a ! "

        S1/S2        Filtra desde S1 los caracteres que no son los indicados
                     en S2. Es complementario a DC(). Ejemplo:
                     "20.356.019-5" / "0123456789"  ==> "203560195"

        S1/N         Devuelve un substring de S1, desde la posición N en adelante.
                     Ejemplo:
                     "Este es un ejemplo. No otro"/at{"."}
                 ==> ". No otro"
                  
        N/S1         Devuelve un substring de S1, desde la primera posición hasta
                     la posición N. Ejemplo:
                     at{"."}/"Este es un ejemplo. No otro"
                 ==> "Este es un ejemplo."
                     
        S1\N         Ajusta desde S1 dentro de la línea procesada, a la posición
                     indicada por N. Ejemplo:
                     si #=" a[100]=0"
                     "="\10 ==> " a[100]   =0"

               <<IMPORTANTE>>
                     Solo tomará la primera ocurrencia de S1; las demás, serán
                     descartadas.
                     
        S1^S2        Idem a AF(S1,S2).

        S1^N         Inserta S1 dentro de la línea procesada, en la posición N.
                     Ejemplo:
                     si #="base(100)"
                     ".string"^at{"("} ==> "base.string(100)"
                     
        S1%S2        Devuelve "0" si S1 tiene coincidencias con el patrón
                     indicado en S2. Ejemplo:
                     "base-20192601.txt"  % "base-????????.*" ==> 0
                     "base-201926011.txt" % "base-????????.*" ==> 1
                     "0" indica "éxito".
                     "1" indica, según el usuario:
                     -informático de tomo y lomo: fracaso.
                     -millenial: No te preocupes, es una oportunidad para
                                 mejorar; no estás mal, solo es este editor
                                 de mierda el que no te comprende... 
                     "?" indica que se espera un solo caracter.
                     "*" indica que se espera una secuencia de caracteres.

        S1|S2        Devuelve "0" si S1 está contenido como substring en S2;
                     de lo contrario, devuelve "1".
                     Ejemplo:
                     "carbon"|"Kirk es una unidad de carbono" ==> 0
                     "carbon"|"hola mundo" ==> 1
        
        S1&S2        Devuelve "0" si S1 está contenido exactamente como un
                     substring en S2. De lo contrario, devuelve "1".
                     Ejemplo:
                     "carbon"&"Kirk es una unidad de carbono" ==> 1
                     "unidad"&"Kirk es una unidad de carbono" ==> 0
                     

   Funciones aritméticas.

  
   ABS(n), SQRT(n), LOG(n), LN(n), SIN(n), COS(n), TAN(n)
                     Para qué las explico...

   PI                Constante con el valor de PI.

   INT(n)|[n]        Entero. 

   CEIL(n)           Función techo.

   FLOOR(n)          Función piso.

   ROUND(n,dec)      Redondeo.

   ROUND{dec}        Idem, pero en la línea procesada.
   
   RND(n)            Devuelve un número aleatorio entre 0 y 1. "n" es un
                     factor multiplicador. Si no quiere alterar el número
                     devuelto, use rnd(1).

   SGN(n)            -1 si n<0; 1 si n>0; 0 si n=0.

   EXP(n)            Exponencial.

   INV(n)            1/n.


   Funciones básicas de texto.

   UTF8(V)           Convierte "V" a codificación UTF8. Por defecto, Tolin
                     realiza la conversión. Sin embargo, cuando lee en modo
                     binario, es posible que dicha conversión falle.
                     
   ANSI(V)           Convierte "V" de UTF8 a ANSI, útil para cuando se leen
                     archivos en modo binario o con una codificación que
                     venga de Windows o Mac.
                     
        <<IMPORTANTE>> Se aceptan combinaciones entre estas funciones.
      
   RP(#,V)           Reemplaza línea procesada por "V".

      RP{V}          idem.

   TRI(V)            Quita los espacios laterales de "V".

   LTRI(V)           Quita solo los espacios a la izquierda de "V".

   RTRI(V)           Quita solo los espacios a la derecha de "V".

   UP(V)             Convierte "V" a mayúsculas.

   LO(V)             Convierte "V" a minúsculas.

   PC(V,N)           Centra un texto "V" entre "N" caracteres.

      PC{N}          Centra la línea procesada.

   PL(V,N)           Justifica el texto "V" hacia la derecha, entre
                     "N" caracteres (padea "V" hacia la izquerda).

      PL{N}          Idem, pero usa la línea procesada. 

   PR(V,N)           Justifica el texto "V" hacia la izquierda, entre
                     "N" caracteres.

      PR{N}          Idem, pero usa la línea procesada.

   CH(N)             Devuelve el caracter ASCII de "N". Si "N" está fuera del
                     rango, ya sea que fuese un valor negativo o mayor que 254,
                     se aplicará módulo 255 y devolverá el caracter respectivo.
                     Ejemplo:
                     ch(65) ==> "A"

   ASC(S)            Devuelve el valor ASCII de "S".
                     Ejemplo:
                     asc("A") ==> 65

   VAL(V)            Convierte "V" a tipo número para calcular. Si "V" es un
                     string alfanumérico y no-numérico (no contiene dígitos),
                     VAL producirá un error.

   STR(V)            Convierte "V" a tipo string.

   CP(V,N)           Repite "V", "N" veces. Ejemplo:
                     cp("*",10)  ==> "**********"
      {*N}           Repite la línea procesada, "N" veces.



   Modificacion de BUFFER.

   LIN(N)            Devuelve el contenido de la línea del BUFFER
                     indicada por "N". Si "N" está fuera del rango, se
                     devolverá un error y el proceso se detendrá.

      #{N}           Idem.

      #N             Idem.

   Diferencia entre #{N} y #N:
                     #{N} da la posibilidad de meter una expresión entre
                     las llaves, ejemplo: #{(2+sgn(#10)*sgn(#10))}. En
                     cambio, #N requiere que "N" sea una constante
                     numérica.
                     
   LET(N,S)          Cambia el contenido de la línea de BUFFER "N", por "S".
                     El cambio es permanente.
                     Este comando sirve para emular variables.
                     Es posible que Tolin devuelva un mensaje de error del tipo
                     "Operación no válida", si este comando se ejecuta en
                     solitario, pero hay que omitirlo si no lo acompaña un
                     mensaje en la base de la pantalla.
                     
   COPY(V)           Toma el valor de "V" y lo deja en el BUFFER, bajo las
                     siguientes condiciones:

                  1) "V" debe contener algo. No copia string vacío.

                  2) "V" debe ser distinto de "0".    

                     Esta función no devuelve nada a la pila.
                     
                     copy(@1)

        Importante   Esto sirve cuando quiere extraer líneas del texto procesado.
                     Estas quedarán en el BUFFER, el cual será guardado en un
                     archivo anexo al proceso.


   Funciones avanzadas de texto.


   CAT(V,W)          Concatena "V" con "W". Ambos, o cualquiera de ellos, pueden
                     ser números. Ejemplo:
                       cat("Número = ",(100+10))
                     resultará:
                       Número = 110
                        
      {V,W}          Idem.

   LEN(V)            Largo de "V".

   SUB(V,M,N)        Obtiene un substring de "V", que comienza en "M",
                     con "N" caracteres de largo.

      SUB{M,N}       Obtiene un substring de la línea procesada.

   TR(V,S,T)         Reemplaza "S" por "T", en "V". El reemplazo no
                     discrimina palabras completas de substrings.
                     Ejemplo: si busca "sa", y reemplaza por "xu", el
                     resultado final es:
                       "sapo"   ==> "xupo"
                       "salas"  ==> "xulas"
                       "pisala" ==> "pixula" 

      TR{S,T}        Idem, pero usa la línea procesada.

   TRE(V,S,T)        Reemplaza exactamente "S" por "T". Sirve para borrar
                     palabras si "T" es "".

      TRE{S,T}       Idem, pero usa la línea procesada.

   RPC(V,S,T)        Reemplaza en "V", todos los caracteres indicados por
                     "S", por lo caracteres indicados por "T".
                     Ejemplo:
                     Si V="Av. acacia #666"
                     rpc(V,".#1234567890","$@ABCDEFGHIJ")
                     ==> "Av$ acacia @GGG"

      RPC{S,T}       Idem, pero usa la línea procesada.

   INS(V,S,P)        Inserta "S" en la posición "P" de "V". Si "P" es 0,
                     devuelve la línea de "V" sin tocar.

      INS{S,P}       Idem. Más corto y usa la línea procesada.

   DC(V,S)           Elimina los caracteres en "V" indicados por "S".
                     Por ejemplo:
                     Si V="hola.. .mundo!$!"
                     dc{".$"}  ==> "hola mundo!!"
                     Puede usar caracteres no imprimibles, concatenando
                     "CH(n)" o "'{n}" al string. 

      DC{S}          Idem, pero en la línea procesada.

   ONE(V,S)          Reduce secuencias de caracteres iguales, a uno solo.
                     El caracter es indicado por "T".
                     Ejemplo:
                     Si V="2.00023     0.0289   1.29607  "
                     one(V," ") ==> "2.00023 0.0289 1.29607"

      ONE{S}         Idem, pero con la línea procesada.

   AT(V,S)           Devuelve la posición donde inicia "S", en "V",
                     contando de izquierda a derecha.

      AT{S}          Idem, pero en la línea procesada.

   RAT(V,S)          Devuelve la posición donde inicia "S", en "V",
                     contando de derecha a izquierda.

      RAT{S}         Idem, pero en la línea procesada. 

   AF(V,S)           Tal como AT(), pero busca exactamente "S".
                     La búsqueda se realiza de derecha a izquierda.

      AF{S}          Idem, pero usando la línea procesada.

   RANGE(V,C,D)      Busca en "V" los caracteres que están en el rango
                     entre "C" y "D". "C" y "D" son números ASCII. Si
                     encuentra alguno de ellos, devuelve su posición.
                     Si no encuentra nada, devuelve "0".
                     Si se usa dentro de POOL/LOOP, RANGE buscará más
                     caracteres omitiendo el último hallazgo.
                     Una aplicación de esta función se puede ver como
                     un comando de CTRL-NN (e.g: "R 100, 120").
                     Ejemplo:
                        range(#,1,8)
                     busca en "#" algún caracter ubicado entre ASCII 1
                     y ASCII 8, y devuelve su posición.
     
     RANGE{C,D}      Idem, pero usa la línea procesada.

   PTRP(V,N)         Avanza el inicio del string "V", "N" caracteres.
                     Ejemplo:
                         V="Postula"
                         ptrp(V,4) ==> "tula"

      {+N}           Idem, pero usa la línea procesada.
                     Ejemplo:
                         #="Postula"
                         {+4} ==> "tula"

   PTRM(V,N)         Retrocede el final del string "V", "N" caracteres.

      {-N}           Idem, pero usa la línea procesada.



   Tokens.

   DEFT(S)           Define localmente un nuevo tokenizer.
      
   TK(V,N)           Obtiene el token "N" de "V". "N" comienza en 1.
                     Si "N" es 0, devuelve la línea completa.
                     Un token se devuelve sin espacios laterales.
                     Un índice de token negativo da error.

      ${N}           Obtiene el token "N" de la línea procesada.

      $N             Obtiene el token "N" de la línea procesada.

   Diferencia entre ${N} y $N:
                     ${N} da la posibilidad de meter una expresión entre
                     las llaves, ejemplo: ${2+sgn(#10)}. En cambio, $N
                     requiere que "N" sea una constante numérica, tal y
                     como se usa en AWK.
                     Ejemplos:
                       tolin -c 'ls -l' '$9'
                       tolin -c 'ls -l' '${nt}'
                       tolin -c 'ls -l' 'tk(#,9)'
                       tolin -c 'ls -l' 'tk(#,nt)'
                     despliega el nombre de los archivos listados.

   LETK(V,N,M)       Cambia el token indicado por "N", por el token
                     indicado por "M", de "V".
                     Si "M" es un tipo string, cambia el token "N" por el
                     string. 
                     Este comando no cambia el valor de "V", sino, su copia,
                     la que es dejada en la pila de proceso.

      LETK{N,M}      Idem, pero usa la línea procesada.
                     Ejemplo:
                       tolin -c 'ls -l' 'letk{9,up($9)}'
                       tolin -c 'ls -l' 'letk(#,9,up($9))'
                     ambos convierten los nombres de archivos en mayúsculas:
                     ...
                     -rw-r--r-- 1 xu xu 1181 feb 9 13:06 UPPER.C
                     ...


   Funciones utilitarias.


   GLOSS(N)          Convierte un número en palabras. Si "N" es un string,
                     acepta un número de 69 dígitos (mil decillones).
                     Si "N" es un número "numérico", el máximo aceptado
                     oscila en una potencia de 10 elevado a 19.
                     Acepta como máximo 2 decimales, y si hay más, trunca.
                     Ejemplo:
                       tolin -f foo 'gloss(2001)'
                   ==> dos mil uno

                       tolin -f foo 'gloss(1023890201.189)'
                   ==> mil veintitres millones ochocientos noventa mil 
                       docientos uno con dieciocho
                       
                       tolin -f foo 'gloss(9.9E19)'
                   ==> noventa y nueve trillones.
                   
                       tolin -f foo 'gloss(9.9E20)'
                   ==> ** no se puede convertir [****************] **
                       
   MON(V,S,M,N)      Da formato moneda al número en "V", con un signo 
                     monetario "S", un ancho "M", y "N" decimales. El
                     primer caracter de "S" es un relleno.
                     Ejemplo:
                         mon("12345.3567",".US$",17,2)
                     ==> US$.....12,345.36

      MON{S,M,N}     Idem, pero usa la línea procesada.

   MSK(V,S)          Da formato a "V", siguiendo un patrón "S". El
                     primer caracter de "S" es un relleno.
                     Ejemplo:
                         msk("123456768"," ##.###.###-#")
                     ==> 12.345.676-8

      MSK{S}         Idem, pero usa la línea procesada.

   SAT(V,S)          Crea, a partir de "V", un string formateado por "S".
                     Sirve para dar formato a archivos de datos como 
                     archivos largo-posición, por ejemplo.
                     
                     Un campo está formado por el signo "$", un número que
                     indica posición de token (que inicia en 0), y, 
                     opcionalmente, el ancho en caracteres seguido por la 
                     justificación del texto (C,L,R), separado de "$n" por ":".
                     Puede ser usado un campo simplemente indicando "$n", sin
                     otro tipo de formateo.
                     La función de XU "SATURA()", en el menú "CTRL-OP", sección
                     "STANDARD" de ED4XU, posee información más detallada sobre el 
                     formato de "S".
             Ejemplo:

                     si #=Juanito Pérez,5.334.234-K,Av. El Desguesadero S/N,
                          Pedro Aguirre Cerda,300.000

                     sat(#,"$0:30L$1:15L$2:25L$3:20L$4:10R")

            devuelve:

                   Juanito Pérez                 5.334.234-K    Av. El Desguesadero S/N                      Pedro Aguirre Cerda    300.000

            Lo mismo hace:

                   sat{"$0:30L$1:15L$2:25L$3:20L$4:10R"}

                     Nuevamente, use "sat{}" si no piensa usar "#" como argumento
                     de otra función. Si hace esto último, debe usar la forma "SAT()".

      SAT{S}         Idem, pero usa la línea procesada.

   MATCH(V,S)        Devuelve "0" si todos los tokens de "S" están en "V";
                     de lo contrario, devuelve un número negativo.
                     "S" debe separar sus tokens con "\;". Ejemplo:
                     Si V="Mensaje a analizar por tokens"
                     match(V,"analizar\;tokens") ==> 0
                     match(V,"analiza\;tokens")  ==> -1
                     match(V,"analiza\;token")   ==> -2
                     Esta función es ideal para trabajar con IF() y con el
                     BUFFER. Por ejemplo, en la siguiente línea, si el match
                     es "0", devuelve la primera línea del BUFFER; de lo
                     contrario, devuelve la segunda línea del BUFFER:
                     
                     if ( match{"string1\;string2"}, #1, #2 )
                     
      MATCH{S}       Idem, pero usa la línea procesada.
   
   EXPR-A-EVALUAR ? <EXPR1> [ : <EXPR2> ] ;|.
                     Evalúa "EXPR-A-EVALUAR":
                     
                     1) Si es 0 o vacío, ejecuta <EXPR1>.
                     2) (Opcional) De lo contrario, ejecuta <EXPR2>.
                     
                     El terminador ";"|"." es OBLIGATORIO, pues indica donde
                     finaliza "?". Si no lo coloca, podría haber un error.
                     Ejemplo:
                       tolin -c 'ls -l' 'match{"tolin"}?#.'
                     despliega:
                       -rwxr-xr-x 1 xu xu  1840368 may 20 22:52 tolin
                       -rw-r--r-- 1 xu xu   111194 may 11 14:27 tolin.bak
                       -rw-r--r-- 1 xu xu    51216 may 21 01:09 tolin.help
                       -rw-r--r-- 1 xu xu   154893 may 21 00:54 tolin.prg
                     
                     Mismo ejemplo, pero despliega el tamaño en KB:
                       tolin -c 'ls -l' 'match{"tolin"}?letk{5,{pl(($5/1024),8)," KB"}}.'
                     despliega:
                       -rwxr-xr-x 1 xu xu  1797.23 KB may 21 01:16 tolin
                       -rw-r--r-- 1 xu xu   108.59 KB may 11 14:27 tolin.bak
                       -rw-r--r-- 1 xu xu    50.68 KB may 21 01:14 tolin.help
                       -rw-r--r-- 1 xu xu   151.41 KB may 21 01:16 tolin.prg

          <<IMPORTANTE>>
                     Puede anidar este comando.
                     Puede usar "?" sin ":", pero no olvide el terminador ";"|".".
                     Puede usar AND(), OR(), XOR() y "~" (negación), explicados
                     más adelante.
                     Puede usar más de una expresión en <EXPR1> y <EXPR2>, siempre
                     y cuando estas no dejen más de un resultado en la pila
                     al finalizar su macro.

         >>COMENTARIOS>>
                     Si usa ":" sin "?", saltará todo lo que venga después,
                     dado que buscará ";" o ".".
                     Este comando es más útil y eficiente que IFxx, dado que
                     solo ejecuta lo que debe ejecutar, no como IFxx, que
                     ejecuta todo, y luego elige el resultado en función de
                     la evaluación.
      
   IF(F,S,T)         Si "F" es vacío o 0, devuelve "S", de lo contrario,
                     devuelve "T".

         <<IMPORTANTE>>
                     IF (y sus variantes) necesita que "S" y "T" generen
                     resultados que puedan ser guardados en la pila de
                     proceso.
                     Tanto "S" como "T" son ejecutados, pero uno de esos
                     resultados será el ganador; el otro se desechará.
                     Así que trate de que no haya error en ambos. Si no
                     necesita un "ELSE", use NOP.

                     "IF" devuelve un tipo string; por tanto, si trabaja con
                     números, debe usar "VAL()" o "!{}". Ejemplo:
                        val( if( ($1%2), $2, $3))*100
                     Si el primer token es par, usa el token 2; sino, usa el
                     token 3.
                     Si desea comprobar cosas como si la expresión es negativa
                     o positiva (distinta de 0), puede usar cosas como esta:

                        if( sgn($1)+1, ..., ...)  Comprueba por negativo
                        if( sgn($1)-1, ..., ...)  Comprueba por positivo
                        if( sgn($1)+1, ..., if( sgn($1), ... ,...)  )
                                                  Comprueba si es menor o igual
                                                  a 0. Etc.

                     El problema con el último ejemplo, es que tendrá que 
                     repetir la operación tanto para "menor" como para "igual"
                     a 0. Salvo que use las siguientes funciones, que solo
                     trabajan con expresiones que devuelven números:

    IFLE(F,S,T)      Comprueba si "F" es menor o igual a cero. 

    IFGE(F,S,T)      Comprueba si "F" es mayor o igual a cero.
            
            NOTA     Si desea hacer algo cuando "F" sea menor que cero, solo use
                     la parte "falso" de IFGE(); idem cuando desee hacer algo
                     para "F" mayor que cero (IFLE()). Idem cuando desee hacer 
                     algo con "F" distinto de cero, usando el falso de IF().

    DIFERENCIAS ENTRE IFxx Y "?"
                     Mientras IFxx deja un resultado en la pila en función de su
                     evaluación, "?" no devuelve nada, sino que son las expresiones
                     en su interior las que devuelven resultados.
                     Tenga presente esta diferencia.

    AND, OR y XOR    Se puede simular AND sumando el resultado de las operaciones
                     de IFxx. Ejemplo:
                        if( ( match{"word"} + (sgn($1)-1) ),...,...)
                     si "match" encuentra una palabra, es "0", y si el primer
                     token es positivo, el resultado es "0": AND.
                     OR se puede simular con una multiplicación. 
                        if( ( match{"word"} * (sgn($1)-1) ),...,...)
                     Si uno de los resultados es "0", hará todo cero y se obtendrá
                     la opción para "verdad"; lo mismo sucede si todos los resultados
                     son "0". De lo contrario, si ninguno es "0", se obtendrá la
                     opción para "falso".
                     XOR es algo más rebuscado. Se puede simular así, con la 
                     ayuda de registros de memoria para hacer el trabajo una
                     sola vez:

                        @1(sgn(match{"word"})*(-1))
                        @2(sgn($1)-1)
                        if ( ( (@1+(1-@2)) * ((1-@1)+@2) ), ..., ...)

    AND(), OR(), XOR()
                     Si todo lo anterior te parece "pajero", existen las funciones
                     aludidas que hacen el mismo trabajo. Estas devuelven "0" si
                     sus argumentos son "0", o "1" si alguno de ellos no cumple con
                     la condición esperada. Solo aceptan dos argumentos. Ejemplo:
                        if( and(match{"word"}, (sgn($1)-1)), ..., ...)
                        if( or(match{"word"},  (sgn($1)-1)), ..., ...)
                        if( xor(match{"word"}, (sgn($1)-1)), ..., ...)
                     Se permite anidar dichas funciones. Obvio.        


   Operadores de bits.

   
   Números de base diferente al decimal.
                     Tolin convertirá cualquier número de base hexadecimal, octal y
                     binaria, a decimal, y lo hará por defecto en el análisis
                     sintáctico. Igual se incluye un convertidor a decimal, por si
                     desea convertir una cadena formada dentro de la expresión.
                     Los números de base diferente son, y se deben escribir, así:
   
   BINARIA           Prefijo: "0x", dígitos "0" y "1", y sufijo "b". Ejemplo:
                     0x10100101b 
                     
   HEXADECIMAL       Prefijo: "0x", dígitos 0-9, caracteres mayúsculas A,B,C,D,E,F,
                     y sufijo "h". Ejemplo:
                     0xA0389FFh
   
   OCTAL             Prefijo "0x", dígitos 0-7, y sufijo "o". Ejemplo:
                     0x7165o.
   
   Funciones de bits y cambio de base:
   
   BIT(N,P)          Devuelve el bit de "N" ubicado en la posición "P".

   ON(N,P)           Enciende el bit "P" de "N" (lo deja en "1").

   OFF(N,P)          Apaga el bit "P" de "N" (lo deja en "0").

   NOT(N)            Negación binaria de "N" (complemento a 1).

   BIN(N)            Devuelve la versión binaria de N.

   HEX(N)            Devuelve la versión hexadecimal de N.

   OCT(N)            Devuelve la versión octal de N.

   DEC(S)            Devuelve la versión decimal numérica de la cadena S.
                     Ejemplo:
                        dec("0xFFh")+1 ==> 256.00
                     Si intenta convertir una expresión constante sin comillas, habrá
                     error, lo mimso si intenta usar DEC con un número decimal.
   
   Para realizar el cálculo de complemento a 2, simplemente escriba:
   num-binario ! 0x11111...(n-bits)b + 1
   También puede usar números hexadecimales, si desea.
 

 EJEMPLO DE EXPRESION "Tolin":
   Las siguientes expresiones extraen un string separado con comillas,
   en cualquier ubicación.
   La primera expresión está escrita con atajos, y la segunda, con sus
   funciones equivalentes:
   
   sub{ (!{at{"\""})+1}, (!{rat{"\""}) - !{at{"\""}}-1 )  }

   sub(#,val(at(#,ch(34))+1), (val(rat(#,ch(34)))-val(at(#, ch(34)))-1))
   
   (Es mucho más compacto escribir lo de arriba que lo de abajo, aunque esté
    escrito en proto-sumerio)
   
   Si # = var<-getenv("SHELL")
   La expresión devuelve: SHELL  (sin comillas)
   
 IMPORTANTE
   Cualquier expresión aritmética usada como argumento de función, debe estar
   escrita entre paréntesis. Por ejemplo:
   
   25,7 = _
   
   Tolin: { ($1 \ $2), {" Resto: ", ($1 % $2) } }   
   
   25,7 = 3 Resto: 4.0000000000000_
   
   La división entera y el resto módulo de los tokens 1 y 2, deben estar entre
   paréntesis.

 OTRO EJEMPLO.
   Suponga que desea dejar en blanco aquellas líneas que no cumplen una condición:
   
   void  /* acepte la línea vacía como resultado valido */
   #*(1-(match{"word"}*(-1)))
   
   o bien, para irse más a la segura:
   
   void
   #*(1 - (sgn(match{"word"})) * (-1))
   
   Dejará solo las líneas que tienen "word", y las demás las dejará en blanco.

 Y OTRO EJEMPLO.
   Suponga que edita un archivo de cadenas de ADN, y desea encontrar, en una misma
   línea, dos subcadenas, pero que no contenga una tercera subcadena:
   
   @1(match{"ATGCTT"})
   @2(match{"ATAATC"})
   @3(match{"ATTTAA"})
   copy( if( and(and(@1,@2),(@3+1) ),I,0 ))
   
   Dejará en el BUFFER las líneas que cumplen con la condición.

   Explicación: Si el match es realizado, devolverá "0". Así, si encuentra las cadenas
   en @1 y @2, AND de más adentro devolverá "0". Luego, si encuentra un match para @3,
   devolverá 0, pero no nos sirve, luego, se le suma 1, como una especie de negación.
   Aquí, NOT() es un negador binario, no de valores de "verdad".
   El primer AND evaluará todo, y el IF devolverá el número de línea actual si todo se
   cumple; de lo contrario, devuelve "0". Ahora, COPY solo guardará en el BUFFER un
   valor que sea distinto de vacío, o distinto de 0.

 Y EL ULTIMO EJEMPLO.
   Usted desea copiar al BUFFER las líneas que contengan, al menos, una comilla.

   copy( sgn(at{"\""})*# )
   
   Copiará las líneas al BUFFER que contengan comillas. Si no encuentra comillas, 
   AT() devuelve "0", SGN() devuelve 0, y 0*STRING es nada. Ahora, si encuentra,
   AT() devolverá un número mayor que cero, SGN() devolvera "1", y 1*STRING es
   el mismo STRING. Recordar que un string multiplicado por un número "N", produce una
   réplica del mismo, "N" veces.

  AUTOR.
           Don Dalien, mayo de 2019. daniel.stuardo@gmail.com
           Bugs, consultas, al mail.

