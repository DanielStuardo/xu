//
// Notas:
//  * declaracion de PATH_XU variable de entorno
//  * se agrega 231 y 232 manejo cola impl¡cita. OJO: hay potencial Excepción
//    del sistema si el tama€o de sincronize es 0.
// 
// 
// 


//#include "fileio.ch"
//#include "simpleio.ch"

//#define THREAD 3

REQUEST HB_LANG_ES
HB_LANGSELECT( "ES" )
REQUEST HB_CODEPAGE_UTF8
hb_cdpSelect( "UTF8" )

function main()

public _CR:=HB_OSNewline()           //chr(13)+chr(10)
PUBLIC _arr_par:=array(0)
public _sw_source:=.F.
public _file

// Chequea parametros y los asigna a un array (esto queda para la ejecucion)

numParam:=PCOUNT()
if numParam==0
    _header()
    _modo_de_uso()
    release all
    quit
end

iParam:=1
if hb_pValue(1)=="-s"
   _sw_source:=.T.
   if numParam>=2
      _file:=hb_pValue(2)    // el nombre del archivo
      iParam:=3
   else
      _header()
      _modo_de_uso()
      release all
      quit
   end
else
   _file:=hb_pValue(1)    // el nombre del archivo
   iParam:=2
end

//?"iParam=",iParam," NumParam=",numParam
if numParam>=iParam
   //_arr_par:=array(numParam-1)
   _arr_par:=array(numParam-(iParam-1))
//end
  //  rellenar array de parametros para distribuir despues de la carga de variables
   nParametro:=1
   WHILE iParam<=numParam
 //  if hb_pValue(iParam) == "-s"
 //     _sw_source:=.T.
 //  else
      _arr_par[nParametro]:=hb_pValue(iParam)
     // ? "Pram ",iParam," Valor ", _arr_par[nParametro]
      ++nParametro
 //  end
   
      ++iParam
   END
else
   _arr_par:={}
end

set date french
set century on

//altd(1)
SETCANCEL(.T.)
set fixed off
Set decimals to 14

public _GET_FIX:=16
PUBLIC BSTACK_RECURSIVE:=256
PUBLIC BSTACK_NORMAL:=20
public _fileSeparator

Public _METODO
public CONTEXT_TRUE:="YES"
public CONTEXT_FALSE:="NO" 
public CONTEXT_NUMBER:="N"  // puede ser "E"

public __POSXX:=0
public __POSYY:=0

public stk_prg    // segmento de programa
//public stk_var_01    // segenbto de datos
public stk_var_02    // segenbto de datos

//public stk_vudf   // segmento temporal de variables con sus direcciones udf
//public stk_dudf   // segmento de variables definitivo
public _stk_temp   // segmento de datos de ejecucion

PUBLIC CWM    
PUBLIC TopCWM 
PUBLIC TopApp 
//
PUBLIC STACK   
PUBLIC CS      
PUBLIC CP      
PUBLIC OP_CODE 

PUBLIC stk_local    
PUBLIC stk_var_local
PUBLIC stk_try      

PUBLIC STK_ARRAY_DIR
PUBLIC STK_ARRAY_DIM
PUBLIC STK_ARRAY_ROW
PUBLIC STK_ARRAY_COL
PUBLIC STK_ARRAY_PAG
PUBLIC STK_ARRAY_BLK
PUBLIC STK_ARRAY_TYP
PUBLIC STK_ARRAY_HIE   // jerarquia: 0=dir fija 3n tabla 1=temporal
PUBLIC SFLAGDIR
PUBLIC SFLAGDIM
PUBLIC SFLAGSTK
PUBLIC SFLAGROW
PUBLIC SFLAGCOL
PUBLIC SFLAGPAG
PUBLIC SFLAGBLK
PUBLIC SFLAGTYP
//
PUBLIC STK_TEMP_DIR
PUBLIC STK_TEMP_DIM
PUBLIC STK_TEMP_ROW
PUBLIC STK_TEMP_COL
PUBLIC STK_TEMP_PAG
PUBLIC STK_TEMP_BLK
PUBLIC STK_TEMP_TYP
PUBLIC STK_CWMTOP:=0  // tope de pila de stack temporales

PUBLIC FEVAL    
PUBLIC OKFLAG   
PUBLIC DFLAG    
PUBLIC FLAG     
//PUBLIC SFLAG    
//PUBLIC LFLAGPTR, LFLAGSTK

PUBLIC PFLAG    

PUBLIC FLOCV    
//PUBLIC SWFLOCV  
PUBLIC FLOCW    
PUBLIC FLOCX    
PUBLIC FLOCY    

PUBLIC FLAGREF  

PUBLIC Stack_refRecept 
PUBLIC Stack_refOrigin 
PUBLIC _StackPops   

//PUBLIC NEDFLAG  

PUBLIC FHNDLOUT  

PUBLIC SW_FHNDLOUT
PUBLIC SW_CONSOLE 

//thread_focus:= 1              // en que hilo esta el foco para input?

PUBLIC VEXCEPTION
PUBLIC SW_TRY    
//PUBLIC SW_TRY_ON 


// para triggers
//PUBLIC STACK_TRIGG1,STACK_TRIGG2,STACK_TRIGG3,STACK_TRIGG4,
//PUBLIC CNT_TRIGG

PUBLIC GET_COLOR
PUBLIC XUPRECISION:=16
PUBLIC _XU_SEMANA
PUBLIC _XU_ANO

PUBLIC FVWITH 
PUBLIC FTWITH 

//////PUBLIC _EXISTE_COLA
//////PUBLIC _ACCESO_COLA_COMP

PUBLIC _APPLICATION
PUBLIC _LEVEL
PUBLIC _OUTPUT
PUBLIC _DEPENDENCE

// para ejecucion: toda direccion debera ser offseteada a 254 bytes
PUBLIC DIR
PUBLIC CWM_INICIAL
PUBLIC EMEM

// PUNTEROS A FUNCIONES Y OPERACIONES
PUBLIC __P:=ARRAY(254)       // FUNCIONES Y OPERACIONES PRINCIPALES
PUBLIC __PMATCOM:=ARRAY(7)   // FUNCIONES UTILITARIAS
PUBLIC __PTRGCOM:=ARRAY(6)
PUBLIC __PMATOTHER:=ARRAY(6)
PUBLIC __PTRGESP:=ARRAY(6)
PUBLIC __PBIT:=ARRAY(8)
PUBLIC __PLIST:=ARRAY(6)
PUBLIC __PCONFARR:=ARRAY(4)
PUBLIC __PFUNGET:=ARRAY(4)
PUBLIC __PFUNPUT:=ARRAY(4)
PUBLIC __PTRSTK:=ARRAY(1)
PUBLIC __PCODCC:=ARRAY(6)
PUBLIC __PXCODNC:=ARRAY(4)
PUBLIC __PXCOD2NC:=ARRAY(6)
PUBLIC __PTDAT:=ARRAY(5)
PUBLIC __PDAT2COD:=ARRAY(8)
PUBLIC __PXCODCN:=ARRAY(5)
PUBLIC __PXCODCCC:=ARRAY(3)

PUBLIC __POPEMATNOR1D:=ARRAY(13)

PUBLIC __POPEESCMATSUB1D:=ARRAY(2)
PUBLIC __POPEMATSUB1D:=ARRAY(2)

PUBLIC __POPEESCMAT1D:=ARRAY(7)

PUBLIC __PSETCODE:=ARRAY(4)

__P[1]:=@FUNSTRGET()
__P[2]:=@FUNSTRPUT()
__P[3]:=@FUNCHARGET()
__P[4]:=@FUNXTOBOOL()
__P[5]:=@FUNROUND()
__P[6]:=@FUNPOSCHAR()
__P[7]:=@FUNUNIQUE()
__P[8]:=@FUNSETCODE()
__P[9]:=@FUNCLS()
__P[10]:=@FUNJT()
__P[11]:=@FUNGOODBYE()
__P[12]:=0
__P[13]:=@FUNJNT()
__P[14]:=@FUNLASTKEY()
__P[15]:=@FUNFACTORIAL()
__P[16]:=@FUNLETSTRSTK()
__P[17]:=@MOV()
__P[18]:=@FUNSTRLOAD()
__P[19]:=@NEGATION()
__P[20]:=@FUNSTRDIFF()
__P[21]:=@XCODE2_NC()
__P[22]:=@FUNPOSITIVE()
__P[23]:=@FUNJMP()
__P[24]:=@FUNFREADS()
__P[25]:=@FUNSTOP()
__P[26]:=@FUNPAUSE()
__P[27]:=@FUNISANY()
__P[28]:=@FUNNEGATIVE()
__P[29]:=@FUNREADKEY()
__P[30]:=@FUNBETWEEN()
__P[31]:=@FUNFLAG()
__P[32]:=@FUNISALL()
__P[33]:=@FUNTRIGESPECIAL()
__P[34]:=@FUNSYSTEM()
__P[35]:=@FUNIIF()
__P[36]:=@FUNBRKZ()
__P[37]:=@FUNFCREATE()
__P[38]:=@FUNTRIGCOMMON()
__P[39]:=@FUNXUMLUNPARSER()
__P[40]:=@FUNNOP()
__P[41]:=@FUNTOSTRING()
__P[42]:=@FUNJUDF()
__P[43]:=@FUNADD()
__P[44]:=@XCODE_CN()
__P[45]:=@XCODE_CCC()
__P[46]:=@FUNTONUMBER()
__P[47]:=@FUNCWMTOLET()
__P[48]:=@FUNAPI()
__P[49]:=@FUNOUT()
__P[50]:=@FUNEVALUATE()
__P[51]:=0
__P[52]:=@FUNPOPL()
__P[53]:=@FUNMINMAX()
__P[54]:=@FUNXUMLPARSER()
__P[55]:=@FUNLETSTKSTK()
__P[56]:=@FUNDIM()
__P[57]:=@FUNRETV()
__P[58]:=@FUNRET()
__P[59]:=@FUNFWRITES()
__P[60]:=@LOPERA_CODE()
__P[61]:=@STRAT()
__P[62]:=@XMATALTER()
__P[63]:=@XUCODESTATIC()
__P[64]:=@FUNSUBSADDSTR()
__P[65]:=@FUNSUBSSUBSTR()
__P[66]:=@FUNSWAP()
__P[67]:=@FUNCONSOLE()
__P[68]:=@FUNVIDEO()
__P[69]:=@XCODE_NC()
__P[70]:=@FUNSEQUENCE()
__P[71]:=@FUNNEAR()
__P[72]:=@META_SMINMAX()
__P[73]:=@FUNBLKCOPY()
__P[74]:=@FUNCONFIGARRAY()
__P[75]:=@FUNEPREC()
__P[76]:=@FUNBRKNZ()
__P[77]:=@YMATALTER()
__P[78]:=@XVTMATFILE()
__P[79]:=@FUNSTRREPC()
__P[80]:=@FUNPV()
__P[81]:=@FUNGV()
__P[82]:=@FUNMEMSTRWRITE()
__P[83]:=@STRREP()
__P[84]:=@FUNSHOW()
__P[85]:=@FUNCONTEXT()
__P[86]:=@STRINS()
__P[87]:=@STRCHG()
__P[88]:=@STRLZ()
__P[89]:=@FUNFSEEK()
__P[90]:=@FUNGP()
__P[91]:=@FUNPP()
__P[92]:=@FUNSUBSTR()
__P[93]:=@FUNSTATUS()
__P[94]:=@FUNSTRFIND()
__P[95]:=@FUNSEQSP()
__P[96]:=@INC()
__P[97]:=@DEC()
__P[98]:=@INCVOID()
__P[99]:=@DECVOID()
__P[100]:=@FUNMNELAP()
__P[101]:=@MATMINMAX_CODE() 
__P[102]:=@STRTOK()
__P[103]:=@FUNRESHAPE()
__P[104]:=@FUNPUSHD()
__P[105]:=@FUNLREPLEFT()
__P[106]:=0
__P[107]:=@FUNPOPSR()
__P[108]:=@FUNGB()
__P[109]:=@FUNPB()
__P[110]:=@FUNPOPS()
__P[111]:=@FUNSSTRCUT()
__P[112]:=@FUNLETESPSTK()
__P[113]:=@FUNTMATHCODE()
__P[114]:=@FUNGETGBIT()
__P[115]:=@FUNMATCOMMON()
__P[116]:=@FUNSETGBIT()
__P[117]:=@FUNFEXIST()
__P[118]:=@FUNISTYPE()
__P[119]:=@TRSTK_CODE()
__P[120]:=@FUNISEMPTY()
__P[121]:=@FUNTYPE()
__P[122]:=@FUNMATRANGE()
__P[123]:=@AFINDSTK()
__P[124]:=@FUNSIZE()
__P[125]:=0
__P[126]:=@FUNGETENV()
__P[127]:=@TSTATS_CODE()
__P[128]:=@FUNXOR()
__P[129]:=@FUNSETBIT()
__P[130]:=@FUNGETBIT()
__P[131]:=@FUNVTAB()
__P[132]:=@FUNHTAB()
__P[133]:=@FUNMILLISECONDS()
__P[134]:=@FUNISNAN() 
__P[135]:=@STRCCAR()
__P[136]:=@FUNNOTBIT()
__P[137]:=@TOKENSTRMAT()
__P[138]:=@STRLIN()
__P[139]:=@FUNISINF()
__P[140]:=@FUNJOIN()
__P[141]:=@FUNPM()
__P[142]:=@FUNGM()
__P[143]:=@FUNSEED()
__P[144]:=@FUNKEYPUT()
__P[145]:=@FUNMATMULT()   
__P[146]:=@TSTK_CODE()
__P[147]:=@TFSTK_CODE()
__P[148]:=@FUNFSHELL()
__P[149]:=@FUNSHELL()
__P[150]:=@FUNFIX()
__P[151]:=@FUNGET()
__P[152]:=@FUNPUT()
__P[153]:=@FUNCURSOR()    
__P[154]:=@FUNSTRPAD()
__P[155]:=@FUNCLEARTRY()
__P[156]:=@FUNPROCESS()
__P[157]:=@FUNCASTEO()
__P[158]:=@FUNENDT()
__P[159]:=@FUNTRY()
__P[160]:=@CODESUBMAT()
__P[161]:=@FUNCATCH()
__P[162]:=@FUNOK()
__P[163]:=@FUNFWRITEB()
__P[164]:=@FUNFREADB()
__P[165]:=@FUNFWRITEL()
__P[166]:=@FUNISTIME()
__P[167]:=@XPUTRANGE()
__P[168]:=@XGETRANGE()
__P[169]:=@FUNSERVERMSG()
__P[170]:=@FUNRESPONSE()
__P[171]:=@FUNSATURA()
__P[172]:=@FUNMONEY()
__P[173]:=@FUNFEOF()
__P[174]:=@FUNFREADL()
__P[175]:=0
__P[176]:=@FUNFCLOSE()
__P[177]:=@FUNFOPEN()
__P[178]:=@FUNMASK()
__P[179]:=@FUNRPUSH()
__P[180]:=@FUNSTPOP()
__P[181]:=@FUNFLUSH()
__P[182]:=@FUNMSLEEP()
__P[183]:=@FUNSLEEP()
__P[184]:=@FUNFPOP()
__P[185]:=@XCODE_CC()

  __P[186]:=@FUNBRKGZ()
  __P[187]:=@FUNBRKLZ()
  __P[188]:=@FUNBRKLEZ()
  __P[189]:=@FUNBRKGEZ()

__P[190]:=@TDATE2_CODE()

  __P[191]:=0
  __P[192]:=0
  __P[193]:=0
  __P[194]:=0

__P[195]:=@FUNNOT()
__P[196]:=@FUNISLEAP()
__P[197]:=@FUNBACK()             // retorno de GOSUB. NO USAR.
__P[198]:=@FUNGOSUB()             // llamada a subrutina. NO USAR.
__P[199]:=@FUNDATEADD()
__P[200]:=@FUNSORT()
__P[201]:=@FUNFLC()
__P[202]:=@FUNADDMATSTR()
__P[203]:=0
__P[204]:=0
__P[205]:=@FUNXTOSTACK()
__P[206]:=0
__P[207]:=@FUNDATEDIFF()
__P[208]:=0 
__P[209]:=@FUNGCD()
__P[210]:=@FUNLCM()
__P[211]:=@BIT_CODE()
__P[212]:=@FUNPARSATT()
__P[213]:=0
__P[214]:=@FUNTRUE()
__P[215]:=@FUNFALSE()
__P[216]:=@FUNGARBAGE()
__P[217]:=0
__P[218]:=0
__P[219]:=@FUNRAISE()
__P[220]:=0
__P[221]:=@TDATE_CODE()
__P[222]:=0
__P[223]:=0
__P[224]:=@FUNDATENOW()
__P[225]:=0
__P[226]:=@FUNTIMENOW()
__P[227]:=@OPMATRICES()
__P[228]:=@FUNUSE()
__P[229]:=@FUNPUSH()
__P[230]:=0
__P[231]:=@FUNPOP()
__P[232]:=@FUNWRITE()
__P[233]:=0
__P[234]:=@FUNAT()
__P[235]:=@FUNAND()
__P[236]:=@FUNCOLOR()
__P[237]:=0
__P[238]:=@FUNOR()
__P[239]:=0
__P[240]:=@SUBSETSTR()
__P[241]:=@IS_NOT_EQUAL()
__P[242]:=@IS_GE()
__P[243]:=@IS_LE()
__P[244]:=@IS_GT()
__P[245]:=@IS_LT()
__P[246]:=@IS_EQ()
__P[247]:=@FUNMOD()
__P[248]:=@FUNPOW()
__P[249]:=@FUNIDIV()
__P[250]:=@FUNDIV()
__P[251]:=@FUNMUL()
__P[252]:=@FUNSUB()
__P[253]:=@FUNADDSTR()
__P[254]:=@PUSHDATA()

__PMATCOM[1]:=@FUNINT()
__PMATCOM[2]:=@FUNSQRT()
__PMATCOM[3]:=@FUNEXP()
__PMATCOM[4]:=@FUNLOG()
__PMATCOM[5]:=@FUNLN()
__PMATCOM[6]:=@FUNABS()
__PMATCOM[7]:=@FUNSGN()


__PTRGCOM[1]:=@FUNSIN()
__PTRGCOM[2]:=@FUNCOS()
__PTRGCOM[3]:=@FUNTAN()
__PTRGCOM[4]:=@FUND2R()
__PTRGCOM[5]:=@FUNR2D()
__PTRGCOM[6]:=@FUNCOT()


__PMATOTHER[1]:=@FUNRND()
__PMATOTHER[2]:=@FUNCEIL()
__PMATOTHER[3]:=@FUNFLOOR()
__PMATOTHER[4]:=@FUNCELSIUS()
__PMATOTHER[5]:=@FUNFAHRENHEIT()
__PMATOTHER[6]:=@FUNDELTA()


__PTRGESP[1]:=@FUNASIN()
__PTRGESP[2]:=@FUNACOS()
__PTRGESP[3]:=@FUNATAN()
__PTRGESP[4]:=@FUNSINH()
__PTRGESP[5]:=@FUNCOSH()
__PTRGESP[6]:=@FUNTANH()

__PBIT[1]:=@FUNBITBIT()
__PBIT[2]:=@FUNBITXOR()
__PBIT[3]:=@FUNBITAND()
__PBIT[4]:=@FUNBITSHL()
__PBIT[5]:=@FUNBITSHR()
__PBIT[6]:=@FUNBITOFF()
__PBIT[7]:=@FUNBITON()
__PBIT[8]:=@FUNBITOR()

__PLIST[1]:=@FUNLISTROW()
__PLIST[2]:=@FUNLISTCOL()
__PLIST[3]:=@FUNLISTPAGE()
__PLIST[4]:=@FUNLISTBLOCK()
__PLIST[5]:=@FUNLISTINS()
__PLIST[6]:=@FUNLISTDEL()

__PCONFARR[1]:=@CONFARRONE()
__PCONFARR[2]:=@CONFARRTWO()
__PCONFARR[3]:=@CONFARRTHREE()
__PCONFARR[4]:=@CONFARRFOUR()

__PFUNGET[1]:=@FUNGET1()
__PFUNGET[2]:=@FUNGET2()
__PFUNGET[3]:=@FUNGET3()
__PFUNGET[4]:=@FUNGET4()


__PFUNPUT[1]:=@FUNPUT1()
__PFUNPUT[2]:=@FUNPUT2()
__PFUNPUT[3]:=@FUNPUT3()
__PFUNPUT[4]:=@FUNPUT4()

__PTRSTK[1]:=@FUNTOP()

__PCODCC[1]:=@FUNSTRUC()
__PCODCC[2]:=@FUNSTRLC()
__PCODCC[3]:=@FUNSTRERAC()
__PCODCC[4]:=@FUNSTR2DATE()
__PCODCC[5]:=@FUNSTRREV()
__PCODCC[6]:=@FUNSTRTRIM()
///__PCODCC[7]:=

__PXCODNC[1]:=@FUNSTRLEN()
__PXCODNC[2]:=@FUNSTRWCOUNT()
__PXCODNC[3]:=@FUNSTRNTOK()
__PXCODNC[4]:=@FUNASC()

__PXCOD2NC[1]:=@FUNSTRLCOUNT()
__PXCOD2NC[2]:=@FUNBASEBDEC()
__PXCOD2NC[3]:=@FUNBASEHDEC()
__PXCOD2NC[4]:=@FUNBASEODEC()
__PXCOD2NC[5]:=@FUNSTRCOUNT()
__PXCOD2NC[6]:=@FUNETOD()


__PTDAT[1]:=@FUNDATEANSI()
__PTDAT[2]:=@FUNDATEBQUARTER()
__PTDAT[3]:=@FUNDATEEQUARTER()
__PTDAT[4]:=@FUNDATESDWEEK()
__PTDAT[5]:=@FUNDATESMONTH()

__PDAT2COD[1]:=@FUNDATEQUARTER()
__PDAT2COD[2]:=@FUNDATEDAY()
__PDAT2COD[3]:=@FUNDATEMONTH()
__PDAT2COD[4]:=@FUNDATEYEAR()
__PDAT2COD[5]:=@FUNDATEDWEEK()
__PDAT2COD[6]:=@FUNDATEDYEAR()
__PDAT2COD[7]:=@FUNDATEWEEK()
__PDAT2COD[8]:=@FUNDATEDMONTH()

__PXCODCN[1]:=@FUNCHAR()
__PXCODCN[2]:=@FUNBASEHEXA()
__PXCODCN[3]:=@FUNBASEOCTAL()
__PXCODCN[4]:=@FUNTONATURAL()
__PXCODCN[5]:=@FUNBASEBIN()

__PSETCODE[1]:=@FUNSETUNION()
__PSETCODE[2]:=@FUNSETINTERSECTION()
__PSETCODE[3]:=@FUNSETDIFF()
__PSETCODE[4]:=@FUNSETSDIFF()

__PXCODCCC[1]:=@FUNCRYPT()
__PXCODCCC[2]:=@FUNELAPTIME()
__PXCODCCC[3]:=@FUNREADINPUT()

__POPEMATNOR1D[1]:=0 //NO USAR NUNCA.
__POPEMATNOR1D[2]:=0 //NO USAR NUNCA.
__POPEMATNOR1D[3]:=0 //NO USAR NUNCA.
__POPEMATNOR1D[4]:=0 //NO USAR NUNCA.
__POPEMATNOR1D[5]:=0 //NO USAR NUNCA.
__POPEMATNOR1D[6]:=@FUNEQU1D()
__POPEMATNOR1D[7]:=@FUNMOD1D()
__POPEMATNOR1D[8]:=@FUNPOW1D()
__POPEMATNOR1D[9]:=@FUNIDIV1D()
__POPEMATNOR1D[10]:=@FUNDIV1D()
__POPEMATNOR1D[11]:=@FUNMUL1D()
__POPEMATNOR1D[12]:=@FUNSUB1D()
__POPEMATNOR1D[13]:=@FUNADD1D()

__POPEESCMATSUB1D[1]:=@FUNSUBEMSTR()
__POPEESCMATSUB1D[2]:=@FUNADDEMSTR()

__POPEMATSUB1D[1]:=@FUNSUBMMSTR()
__POPEMATSUB1D[2]:=@FUNADDMMSTR()

__POPEESCMAT1D[1]:=@FUNMODEM1D()
__POPEESCMAT1D[2]:=@FUNPOWEM1D()
__POPEESCMAT1D[3]:=@FUNIDIVEM1D()
__POPEESCMAT1D[4]:=@FUNDIVEM1D()
__POPEESCMAT1D[5]:=@FUNMULEM1D()
__POPEESCMAT1D[6]:=@FUNSUBEM1D()
__POPEESCMAT1D[7]:=@FUNADDEM1D()


PUBLIC __LOOP:=.T.
PUBLIC BREAKCS
PUBLIC BREAKCWM
public PIDMESSAGE:=0,STACK_MSG:={}

PUBLIC GOSUBDIR:=ARRAY(5) //STACKNEW()   // DIRECCIONES DE SALTO DE GOSUB
PUBLIC LENGOSUB:=0

_Carga_Configuracion()  // carga configuracion.

// chequea si el archivo es valido
if _sw_source
   if !file(PATH_BINARY+_fileSeparator+_file)
      _header()
      _modo_de_uso()
      release all
      quit
   end
else
   if !file(_file)
      _header()
      _modo_de_uso()
      release all
      quit
   end
end

_DefineSegmentos()     // define los segmentos de trabajo

// Carga Variables del sistema
_SettingVar()

// Carga archivo y objetos de memoria. Carga segmentos de programa
_CargaArchivo(_file)

CP:=1
CS:=0

WHILE __LOOP     // CICLO PRINCIPAL DE EJECUCIoN

/* if SW_TRY_ON==1      // hay exception!!!
    // existe una variable previa de exception definida por TRY?
    if len(stk_try)==0  // Excepción dentro de otra, sin manejar
       _ErrorSys("ERROR: Excepción sin manejar, dentro de otra excepción!",0,CP+254)
    end
    CP:=stackpop(stk_try)
    SW_TRY_ON:=0
    CS:=stackpop(BREAKCS)    //0
    // Aniadido el 8 de agosto de 2016: es posible que falle
    CWM :=stackpop(BREAKCWM)    //TopCWM
 end */
 
// LA SIGUIENTE PORCION SERÁ DESCOMENTADA CUANDO SE PRUEBE UNA INSTRUCCION. DE LO CONTRARIO, COMENTAR. 
/* if CWM < TopCWM  // prueba: si CWM < TopCWM, mostrar en quE operacion falla
      outstd( hb_UTF8tostr(" 8=D~ ()*()  ESTO ES VERGONZOZO!!"),_CR)
      outstd( hb_UTF8tostr("El siguiente OP_CODE provocó un error en el puntero de área de trabajo:"),_CR)
      outstd( "CWM=",CWM," TopCWM=",TopCWM,_CR)
      outstd( "CS=",CS,_CR)
      outstd( "OP_CODE=",stk_prg[CP-1],_CR)
      outstd( " ",_CR)
      outstd( hb_UTF8tostr("Comunícate con el aweonao que me inventó al correo: daniel.stuardo@gmail.com "),_CR)
      inkey(0)
      Quit
 end */

 OP_CODE:=stk_prg[CP]   // siguiente codigo de operacion
//? "OP_CODE=";??OP_CODE

 IF OP_CODE>254     // es una direccion de RPUSH
    ++CS                // apunto a siguiente direccion de stack
    STACK[CS]:=OP_CODE  // guardo direccion de var referenciada
    ++CP
    LOOP
 ELSE
    IF (__P[OP_CODE]:EXEC())
       ++CP
/*       LOOP
    ELSE
       LOOP   // SE VA AL ERROR!
       */
    END
    LOOP
 END
 
END   // Loop

//if _OUTPUT==chr(2)
 /*  ?;? "*********************** END PROGRAM AT "+dtoc(date())+", "+time()
   ?
   debug_off() */
//end

RELEASE ALL  // borro todas las variables empleadas

RETURN NIL

/**************************************************************************
                           FUNCIONES DEL LENGUAJE
***************************************************************************/
 FUNCTION PUSHDATA()
LOCAL EAX,AX,EDX,ETX,EHX,EIX,EJX,EKX
LOCAL DIM,TYP,ROW,COL,PAG,BLK
  while OP_CODE == 254
     ++CP          // sig. op-code (una direccion de variable o const)
     // guardo direccion de var referenciada. El desplazamiento solo correra
     // para aquellas direcciones pertenecientes a una UDF.
     ++CS
      
     STACK[CS]:=stk_prg[CP]     //stk_var_02[BX]
     OP_CODE:=stk_prg[++CP]

     //***********************************************
     if OP_CODE == 51          // PUSHL: pone dato en stack por llamado a udf desde udf, caso normal nomas
        EAX:=STACK[CS]
        AX:=stk_var_02[EAX]
        --CS
        if valtype(AX)=="A"  // es una puta maraca matriz inexorable chupacalugas!
           
           EDX := ASCAN(STK_ARRAY_DIR,EAX)
           DIM:=STK_ARRAY_DIM[EDX]
           TYP:=STK_ARRAY_TYP[EDX]
           ROW:=STK_ARRAY_ROW[EDX]
           COL:=STK_ARRAY_COL[EDX]
           PAG:=STK_ARRAY_PAG[EDX]
           BLK:=STK_ARRAY_BLK[EDX]
           stackpush(stk_dim_local,{EAX,DIM,TYP,ROW,COL,PAG,BLK})
           ////ETX:=ARRAY(ROW,COL,PAG,BLK)
           ETX:=AX    /////XMMLET(AX,DIM,ROW,COL,PAG,BLK,0)
           stackpush(stk_var_local,ETX)
        else
           stackpush(stk_var_local,AX)
        end
        OP_CODE:=stk_prg[++CP]
     end 
  end
  --CP
RETURN .T.

FUNCTION MOV()    // 17
LOCAL EAX,EBX
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  stk_var_02[EBX] := stk_var_02[EAX]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CS -= 2              // ajusta puntero de Stack
RETURN .T.

FUNCTION FUNSTOP()   // 25

  setcolor("")
  __LOOP:=.F.

RETURN .T.

FUNCTION FUNNOP()   // 40 NADA. No operacion.

RETURN .T.

FUNCTION FUNGOSUB()  // 198

    GOSUBDIR[++LENGOSUB]:=CP+2

    CP:=stk_prg[++CP]-DIR-1      // -1 por el ajuste del ++CP

RETURN .T.

FUNCTION FUNBACK()  // 197
    CP:=GOSUBDIR[LENGOSUB]-1
    --LENGOSUB
RETURN .T.

 FUNCTION FUNAT()   // 234
LOCAL EAX,EBX  //,AX,BX
   EAX:=STACK[CS]
   EBX:=STACK[CS-1]
   CWM:=CMPCWM(EAX,CWM,TopCWM)
   CWM:=CMPCWM(EBX,CWM,TopCWM)
   CS -= 2
   __POSXX:=int(stk_var_02[EBX])  //BX
   __POSYY:=int(stk_var_02[EAX])  //AX
   SETPOS(__POSXX, __POSYY)

RETURN .T.

FUNCTION FUNCWMTOLET()   // 47  WPOP saca un dato del stack
LOCAL EAX,EBX,OP_CODE:=470
   EAX:=STACK[CS]     // VARIABLE
   EBX:=STACK[CS-1]
   CS -= 2
   stk_var_02[EAX]:=stk_var_02[EBX]
   CWM:=CMPCWM(EAX,CWM,TopCWM)
   CWM:=CMPCWM(EBX,CWM,TopCWM)
RETURN .T.

FUNCTION FUNRESPONSE()   // 170
LOCAL EAX,EFX,OP_CODE:=1700,XPID,BX,XMESS,XLEN,I
LOCAL DIM,TYP,DIMR,DIMC,DIMP,DIMB,TEMPORAL

   EAX:=STACK[CS]     // ARGUMENTO ARRAY CON PID y MENSAJE
   CWM:=CMPCWM(EAX,CWM,TopCWM)
   AX:=stk_var_02[EAX]
   --CS
   
   IF VALTYPE(AX)!="A"
      RETURN _FUNPUTERROR("RESPONSE/I NEED A MATRIX TO RESPONSE HERE",OP_CODE,CP)
   END

   if !FUNGETDIMS(EAX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
      RETURN _FUNPUTERROR("RESPONSE/MATRIX NOT INITIALIZED",OP_CODE,CP)
   end
   XLEN:=LEN(AX)
   FOR I:=1 TO XLEN
      XPID:=AX[I][1]
      XMESS:=AX[I][2]
      BX:=PATH_LOG+_fileSeparator+XPID
      IF (FX:=FCREATE(BX+".request"))<0  // CREATE
         RETURN _FUNPUTERROR("RESPONSE/ERROR CREATING MESSAGE",OP_CODE+1,CP)
      END
      IF RIGHT(XMESS,1)==HB_OSNEWLINE()
         XMESS:=SUBSTR(XMESS,1,LEN(XMESS)-1)
      END
      FWRITE(FX,ALLTRIM(hb_STRtoutf8(XMESS)))
      FCLOSE(FX)
      IF (FX:=FCREATE(BX+".end"))<0  // CREATE
         RETURN _FUNPUTERROR("RESPONSE/ERROR FINISH MESSAGE",OP_CODE+1,CP)
      END
      FCLOSE(FX)
   END
   
RETURN .T.

FUNCTION FUNSERVERMSG()   // 169
LOCAL EAX,CX,XPID:=1,BX,FX,LX,XDIR,AX,DX,XFILE,RX,TX,EX,XMESS,XLOOP:=.T.,XPDFILE
LOCAL SW_RESP,OP_CODE:=1690
   EAX:=STACK[CS]     // ARGUMENTO
   CWM:=CMPCWM(EAX,CWM,TopCWM)
   AX:=stk_var_02[EAX]
   
   IF VALTYPE(AX)!="N"
      RETURN _FUNPUTERROR("SERVER/I NEED A NUMBER REQUEST HERE",OP_CODE,CP)
   END
   TX:=PATH_LOG+_fileSeparator+"*.message"
   
WHILE XLOOP
   XDIR:={}
   XDIR := Directory(TX)
   LX:=LEN(XDIR)
   /*XDIR:=ARRAY(LX)
   FOR I:=1 TO LX
      XDIR[I]:=YDIR[I][1]
   END
   XDIR:=asort(XDIR) */
   //?? hb_ntos(LX),","
   ///inkey(0.2) 

   IF LX>0
      //XDIR:=ASORT(BX,1,LX, { |x, y| x < y })

      IF LX>AX
         LX:=AX
      END
      DX:=1
      RX:={}
      SW_RESP:=.F.
      WHILE DX<=LX
         XFILE:=XDIR[DX][1]   //solo el nombre
         XPID:=alltrim(SUBSTR(XFILE,1,AT(".",XFILE)-1))
         XPDFILE:=PATH_LOG+_fileSeparator+XPID
        // ? XPDFILE," PID=",XPID
         // puede que si hay otra instancia de server, el archivo que recién leyó ya no esté disponible
         // luego, hay que preguntar siempre por el archivo.
         IF FILE(XPDFILE+".message")
            IF RENAMEFILE(XPDFILE+".message", XPDFILE+".server") == 0
               // PREPARA EL ARCHIVO DE SERVICIO
               FX:=FOPEN(XPDFILE+".server")
               EX:=FSEEK(FX, 0, 2)  // final del archivo
               FSEEK(FX, 0, 0)
             //  ? EX
               XMESS:=ALLTRIM(HB_UTF8TOSTR(FREADSTR(FX,EX)))
               FCLOSE(FX)
             //  ? XPID,XMESS
               AADD(RX,{XPID,XMESS})
               SW_RESP:=.T.
               ++DX
            //   IF DELETEFILE(XPDFILE+".server")!=0
            //      RETURN _FUNPUTERROR("SERVER/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
            //   END
            
            ELSE
               RETURN _FUNPUTERROR("SERVER/MESSAGE WAS NOT PROCESSED (RENAME)",OP_CODE+1,CP)
            END
         END
         
      END
      IF SW_RESP
         stk_var_02[++CWM]:=RX
         FUNPUTDIMS(CWM,2,"C",LEN(RX),2,0,0)
         STACK[CS] := CWM
         XLOOP:=.F.
      END
   END

END  // WHILE INFINITO
RETURN .T.

FUNCTION FUNPROCESS()   // 156  PROCESOS DE MENSAJERÍA ENTRE PROGRAMAS
LOCAL EAX,EBX,ECX,EEX,AX,BX,FX,EX,XPID:=0,CX,OP_CODE:=1560,I,J,SW,TEMPORAL:={},XLEN
   EAX:=STACK[CS]     // ARGUMENTO
   EBX:=STACK[CS-1]   // VARIABLE DE RETORNO DE VALOR
   ECX:=STACK[CS-2]   // TIPO
   CS-=3
   AX:=stk_var_02[EAX]
   CWM:=CMPCWM(EAX,CWM,TopCWM)
   CWM:=CMPCWM(EBX,CWM,TopCWM)
   CWM:=CMPCWM(ECX,CWM,TopCWM)
   SWITCH stk_var_02[ECX]
      CASE 0    // SEND MESSAGE
        IF LEN(STACK_MSG)==0
           OKFLAG:=.T.
        END
        IF VALTYPE(AX)!="C"
           RETURN _FUNPUTERROR("PROCESS.MESSAGE/I NEED A MESSAGE STRING HERE",OP_CODE,CP)
        END
        IF VALTYPE(stk_var_02[EBX])!="N"
           RETURN _FUNPUTERROR("PROCESS.MESSAGE/I NEED A NUMBER VAR HERE",OP_CODE,CP)
        END
        //PATH_LOG+_fileSeparator+"XUANS_"+EX+".log"
        ++PIDMESSAGE
        if PIDMESSAGE==9999999999
           PIDMESSAGE:=1
        END
        BX:=PATH_LOG+_fileSeparator+ALLTRIM(STR(PIDMESSAGE))
        IF (FX:=FCREATE(BX+".message"))<0  // CREATE
          RETURN _FUNPUTERROR("PROCESS.MESSAGE/ERROR CREATING MESSAGE",OP_CODE+1,CP)
        ELSE
          IF RIGHT(AX,1)==HB_OSNEWLINE()
             AX:=SUBSTR(AX,1,LEN(AX)-1)
          END
          FWRITE(FX,ALLTRIM(hb_STRtoutf8(AX)))
          FCLOSE(FX)
          // ARMA MENSAJE
          AADD(STACK_MSG,{PIDMESSAGE,BX,.F.})
          // DEVUELVE PID A VARIABLE DE RETORNO
          stk_var_02[EBX]:=PIDMESSAGE
        END
        EXIT
        
      CASE 1   // LISTEN
        IF LEN(STACK_MSG)==0
           OKFLAG:=.F.
           stk_var_02[EBX]:=.F.
           EXIT
        ELSE
           OKFLAG:=.T.
        END
        IF VALTYPE(AX)!="N"
           RETURN _FUNPUTERROR("PROCESS.LISTEN/I NEED A NUMBER HERE",OP_CODE,CP)
        END
        IF VALTYPE(stk_var_02[EBX])!="L"
           RETURN _FUNPUTERROR("PROCESS.MESSAGE/I NEED A BOOLEAN VAR HERE",OP_CODE,CP)
        END
        XPID:=stk_var_02[EAX]
       /* IF XPID>0
           // ESCRIBIR ESTO EN "C"
           CX:=0
           FOR I:=1 TO LEN(STACK_MSG)
              IF STACK_MSG[I][1]==XPID
                 CX:=I
                 EXIT
              END
           END
           
           IF CX>0
              BX:=STACK_MSG[CX][2]   ///PATH_LOG+_fileSeparator+ALLTRIM(STR(XPID))
              IF FILE(BX+".end")
                 STACK_MSG[CX][3]:=.T.
              END
           ELSE
              RETURN _FUNPUTERROR("PROCESS.LISTEN/PID DON'T EXIST",OP_CODE+2,CP)
           END
           stk_var_02[EBX]:=STACK_MSG[CX][3]
        ELSE   // VE POR TODOS.
         */
           SW:=.F.
           CX:=0
           FOR I:=1 TO LEN(STACK_MSG)
            //  ?"ESTADO PID ",I," = ",STACK_MSG[I][3]
              IF !STACK_MSG[I][3]
                 BX:=STACK_MSG[I][2]
            //     ? "MESSAGE:",BX+".end"; inkey(1)
                 IF FILE(BX+".end")
                    STACK_MSG[I][3]:=.T.
                    SW:=.T.
                    ++CX
                    IF CX>XPID
                       EXIT
                    END
                 END
              END
            //  ?"ESTADO PID ",I," DESPUES = ",STACK_MSG[I][3]
           END
           stk_var_02[EBX]:=SW
       // END
        EXIT
        
      CASE 2    // REQUEST
        IF LEN(STACK_MSG)==0
           OKFLAG:=.F.
           exit
        ELSE
           OKFLAG:=.T.
        END
        IF VALTYPE(AX)!="N"
           RETURN _FUNPUTERROR("PROCESS.REQUEST/I NEED A NUMBER HERE",OP_CODE,CP)
        END
        XPID:=AX
        //CX:=AScan( STACK_MSG,,, {| x, y | x[ 1 ] := XPID) } )
        IF XPID>0
           CX:=0
           stk_var_02[EBX]:={}
           I:=1
          // ? "LEN(STACK_MSG)=",LEN(STACK_MSG)
           WHILE I <= LEN(STACK_MSG)
           /*   IF STACK_MSG[I][1]==XPID
                 CX:=I
                 EXIT
              END
           END*/
          // IF CX>0
            //  ? "ESTADO DE MSG ",I," = ",STACK_MSG[I][3]
            //  ? "PID DE ",I," = ",STACK_MSG[I][1]
              IF STACK_MSG[I][3] .and. STACK_MSG[I][1]>0
                /// BX:=PATH_LOG+_fileSeparator+ALLTRIM(STR(STACK_MSG[I][1]))
                 BX:=STACK_MSG[I][2]
                 
                 IF FILE(BX+".request")
                //    ? "ENCONTRO "+BX+".request..."
                    FX:=FOPEN(BX+".request")
                    EX:=FSEEK(FX, 0, 2)  // final del archivo
                    FSEEK(FX, 0, 0)
                    ///stk_var_02[EBX]:=HB_UTF8TOSTR(FREADSTR(FX,EX))
                    
                    AADD(stk_var_02[EBX],{ALLTRIM(STR(STACK_MSG[I][1])), HB_UTF8TOSTR(FREADSTR(FX,EX))})
                    FCLOSE(FX)
                    FX:="rm "+BX+".server "+BX+".request "+BX+".end"
                    //EX:=CMDSYSTEM(FX)
                    IF DELETEFILE(BX+".server")!=0
                       RETURN _FUNPUTERROR("REQUEST/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
                    END
                    IF DELETEFILE(BX+".request")!=0
                       RETURN _FUNPUTERROR("REQUEST/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
                    END
                    IF DELETEFILE(BX+".end")!=0
                       RETURN _FUNPUTERROR("REQUEST/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
                    END
                    STACK_MSG[I][1]:=0
                //    ? "PROCESO "+BX+".request..."
                //    inkey(1)
                    ++CX 
                 END
                 //++CX
                 IF CX>XPID
                    XLEN:=LEN(stk_var_02[EBX])
                    if XLEN>0
                       EEX := ASCAN(STK_ARRAY_DIR,EBX)       
                       // agrego valores del array fuente. procedimiento inverso al retorno!
                       STK_ARRAY_DIM[EEX]:=2
                       STK_ARRAY_TYP[EEX]:="C"
                       STK_ARRAY_ROW[EEX]:=XLEN
                       STK_ARRAY_COL[EEX]:=2
                       STK_ARRAY_PAG[EEX]:=0
                       STK_ARRAY_BLK[EEX]:=0
                       ///FUNPUTDIMS(EBX,2,"C",XLEN,2,0,0)
                    else
                       EEX := ASCAN(STK_ARRAY_DIR,EBX)       
                       // agrego valores del array fuente. procedimiento inverso al retorno!
                       STK_ARRAY_DIM[EEX]:=1
                       STK_ARRAY_TYP[EEX]:="C"
                       STK_ARRAY_ROW[EEX]:=0
                       STK_ARRAY_COL[EEX]:=0
                       STK_ARRAY_PAG[EEX]:=0
                       STK_ARRAY_BLK[EEX]:=0
                       ///FUNPUTDIMS(EBX,1,"C",0,0,0,0)
                    end  
                    // Elimino los mensajes
                    TEMPORAL:={}
                    XLEN:=LEN(STACK_MSG)
                    FOR J:=1 TO XLEN
                       IF STACK_MSG[J][1]>0
                          AADD(TEMPORAL,{STACK_MSG[J][1],STACK_MSG[J][2],STACK_MSG[J][3]})
                       END
                    END
                    XLEN:=len(TEMPORAL)
                    IF XLEN>0
                       STACK_MSG:=ARRAY(XLEN,3)
                       ACOPY(TEMPORAL,STACK_MSG) 
                    ELSE
                       STACK_MSG:={}
                    END
                    EXIT
                 END
              END
          // ELSE
          //    RETURN _FUNPUTERROR("PROCESS.REQUEST/PID DON'T EXIST",OP_CODE+2,CP)
              ++I
           END
          // IF I>LEN(STACK_MSG)
              XLEN:=LEN(stk_var_02[EBX])
              if XLEN>0
                 EEX := ASCAN(STK_ARRAY_DIR,EBX)       
                 // agrego valores del array fuente. procedimiento inverso al retorno!
                 STK_ARRAY_DIM[EEX]:=2
                 STK_ARRAY_TYP[EEX]:="C"
                 STK_ARRAY_ROW[EEX]:=XLEN
                 STK_ARRAY_COL[EEX]:=2
                 STK_ARRAY_PAG[EEX]:=0
                 STK_ARRAY_BLK[EEX]:=0
                 ///FUNPUTDIMS(EBX,2,"C",XLEN,2,0,0)
              else
                 EEX := ASCAN(STK_ARRAY_DIR,EBX)       
                 // agrego valores del array fuente. procedimiento inverso al retorno!
                 STK_ARRAY_DIM[EEX]:=1
                 STK_ARRAY_TYP[EEX]:="C"
                 STK_ARRAY_ROW[EEX]:=0
                 STK_ARRAY_COL[EEX]:=0
                 STK_ARRAY_PAG[EEX]:=0
                 STK_ARRAY_BLK[EEX]:=0
                 ///FUNPUTDIMS(EBX,1,"C",0,0,0,0)
              end  
              // Elimino los mensajes
              TEMPORAL:={}
              XLEN:=LEN(STACK_MSG)
              FOR J:=1 TO XLEN
                 IF STACK_MSG[J][1]>0
                    AADD(TEMPORAL,{STACK_MSG[J][1],STACK_MSG[J][2],STACK_MSG[J][3]})
                 END
              END
              XLEN:=len(TEMPORAL)
              IF XLEN>0
                 STACK_MSG:=ARRAY(XLEN,3)
                 ACOPY(TEMPORAL,STACK_MSG) 
              ELSE
                 STACK_MSG:={}
              END
         //  END
        ELSE   // procesa todo
           stk_var_02[EBX]:={}
           FOR I:=1 TO LEN(STACK_MSG)
              IF STACK_MSG[I][3]
                 BX:=STACK_MSG[I][2]  ///PATH_LOG+_fileSeparator+ALLTRIM(STR(STACK_MSG[I][1]))
                 //? "MESSAGE:",BX; 
                // inkey(0.1)
                 IF FILE(BX+".request")
                    FX:=FOPEN(BX+".request")
                    EX:=FSEEK(FX, 0, 2)  // final del archivo
                    FSEEK(FX, 0, 0)
                    ///stk_var_02[EBX]:=HB_UTF8TOSTR(FREADSTR(FX,EX))
                    AADD(stk_var_02[EBX],{ALLTRIM(STR(STACK_MSG[I][1])), HB_UTF8TOSTR(FREADSTR(FX,EX))})
                    STACK_MSG[I][1]:=0
                    FCLOSE(FX)
                    FX:="rm "+BX+".server "+BX+".request "+BX+".end"
                    ///EX:=CMDSYSTEM(FX)
                    IF DELETEFILE(BX+".server")!=0
                       RETURN _FUNPUTERROR("REQUEST/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
                    END
                    IF DELETEFILE(BX+".request")!=0
                       RETURN _FUNPUTERROR("REQUEST/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
                    END
                    IF DELETEFILE(BX+".end")!=0
                       RETURN _FUNPUTERROR("REQUEST/MESSAGE WAS NOT DELETE",OP_CODE+1,CP)
                    END
                 END
              END
           END
           // Elimino los mensajes
           TEMPORAL:={}
           FOR I:=1 TO LEN(STACK_MSG)
              IF STACK_MSG[I][1]>0
                 AADD(TEMPORAL,{STACK_MSG[I][1],STACK_MSG[I][2],STACK_MSG[I][3]})
              END
           END
           XLEN:=len(TEMPORAL)
           IF XLEN>0
              STACK_MSG:=ARRAY(XLEN,3)
              ACOPY(TEMPORAL,STACK_MSG) //XMMLET(TEMPORAL,2,LEN(TEMPORAL),2,0,0,0) //TEMPORAL  // si esto no funciona, probar con XMMLET...
           ELSE
              STACK_MSG:={}
           END
           XLEN:=LEN(stk_var_02[EBX])
           if XLEN>0
              EEX := ASCAN(STK_ARRAY_DIR,EBX)       
              // agrego valores del array fuente. procedimiento inverso al retorno!
              STK_ARRAY_DIM[EEX]:=2
              STK_ARRAY_TYP[EEX]:="C"
              STK_ARRAY_ROW[EEX]:=XLEN
              STK_ARRAY_COL[EEX]:=2
              STK_ARRAY_PAG[EEX]:=0
              STK_ARRAY_BLK[EEX]:=0
              ///FUNPUTDIMS(EBX,2,"C",XLEN,2,0,0)
           else
              EEX := ASCAN(STK_ARRAY_DIR,EBX)       
              // agrego valores del array fuente. procedimiento inverso al retorno!
              STK_ARRAY_DIM[EEX]:=1
              STK_ARRAY_TYP[EEX]:="C"
              STK_ARRAY_ROW[EEX]:=0
              STK_ARRAY_COL[EEX]:=0
              STK_ARRAY_PAG[EEX]:=0
              STK_ARRAY_BLK[EEX]:=0
              ///FUNPUTDIMS(EBX,1,"C",0,0,0,0)
           end   
        END
       // FIN DEL SWITCH
   END

RETURN .T.

FUNCTION FUNMSLEEP()   // 182
LOCAL EAX
  EAX:=STACK[CS]
  --CS
  XUSLEEP(stk_var_02[EAX])
  CWM:=CMPCWM(EAX,CWM,TopCWM)
RETURN .T.

FUNCTION FUNSLEEP()   // 183
LOCAL EAX
  EAX:=STACK[CS]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS
  XSLEEP(stk_var_02[EAX])
RETURN .T.


FUNCTION FUNSETBIT()  // 129
LOCAL EAX,EBX,ECX
  EAX:=STACK[CS]     // VALOR DE BIT A MODIFICAR
  EBX:=STACK[CS-1]   // POSICION DE BIT
  ECX:=STACK[CS-2]   // CAMPO DE BIT
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CS -= 3
  IF stk_var_02[EAX]==0
     stk_var_02[ECX]:=XCLEARBIT(stk_var_02[ECX],stk_var_02[EBX]+1)
  ELSE
     stk_var_02[ECX]:=XSETBIT(stk_var_02[ECX],stk_var_02[EBX]+1)
  END
RETURN .T.

FUNCTION FUNGETBIT()   // 130
LOCAL EAX,EBX
  EAX:=STACK[CS]     // POSICION DE BIT CONSULTADO
  EBX:=STACK[CS-1]   // CAMPO DE BIT
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  --CS
  stk_var_02[++CWM]:=XGETBIT(stk_var_02[EBX],stk_var_02[EAX],1)
  STACK[CS] := CWM
RETURN .T.

FUNCTION FUNSETGBIT()  // 116
LOCAL EAX,EBX,ECX,EDX,DX,AX,EX,LX,IX
  EAX:=STACK[CS]     // GRUPO DE BIT A MODIFICAR
  EBX:=STACK[CS-1]   // POSICION FINAL DE BIT
  ECX:=STACK[CS-2]   // POSICION INICIAL DE BIT
  EDX:=STACK[CS-3]   // CAMPO DE BIT
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CWM:=CMPCWM(EDX,CWM,TopCWM)
  CS -= 4

  IF stk_var_02[EAX]==0
     FOR LX := stk_var_02[ECX]+1 TO stk_var_02[EBX]+1
        stk_var_02[EDX]:=XCLEARBIT(stk_var_02[EDX],LX)
     END
  ELSEIF stk_var_02[EAX]==1
     FOR LX := stk_var_02[ECX]+1 TO stk_var_02[EBX]+1
        stk_var_02[EDX]:=XSETBIT(stk_var_02[EDX],LX)
     END
  ELSE
     EX:=DECTOBIN( stk_var_02[EAX] )
     //? EX
     IX:=1
     FOR LX := stk_var_02[EBX]+1 TO stk_var_02[ECX]+1 step -1
        DX:=VAL(SUBSTR(EX,IX,1))
       // ? "BIT = ",DX
        IF DX==0
           stk_var_02[EDX]:=XCLEARBIT(stk_var_02[EDX],LX)
        ELSE
           stk_var_02[EDX]:=XSETBIT(stk_var_02[EDX],LX)
        END
        ++IX
     END
  END

RETURN .T.

FUNCTION FUNGETGBIT() // 114
LOCAL EAX,EBX,ECX
  EAX:=STACK[CS]     // POSICION FINAL DE BIT CONSULTADO
  EBX:=STACK[CS-1]   // POSICION INICIAL
  ECX:=STACK[CS-2]   // CAMPO DE BIT
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CS-=2
  stk_var_02[++CWM]:=XGETBIT(stk_var_02[ECX],stk_var_02[EBX],stk_var_02[EAX])  
  STACK[CS] := CWM
RETURN .T.

FUNCTION FUNVTAB()    // 131
LOCAL COL,ROW,EIX,MAXROW,EAX
  EAX:=STACK[CS]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS

  ROW:=row()+stk_var_02[EAX]
  COL:=col()
  MAXROW:=maxrow()
  if ROW<=0
     ROW:=1
  elseif ROW>MAXROW
     for EIX:=MAXROW to ROW
       ?
     next
     ROW:=MAXROW  //-1
  end

  SETPOS(ROW,COL)  //

RETURN .T.

FUNCTION FUNHTAB()    // 132
LOCAL COL,ROW,MAXCOL,MAXROW,EAX
  EAX:=STACK[CS]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS
  COL:=stk_var_02[EAX]*8
  ROW:=row()
  MAXROW:=maxrow()
  MAXCOL:=maxcol()
  if COL==0
    COL:=1
  elseif COL<0 
    if col()+COL<0
      COL:=1
    end 
  elseif COL>MAXCOL
    if row()==MAXROW
      ? 
    end
    ++ROW
    COL:=COL-MAXCOL
  end   
  SETPOS(ROW,COL)  ///
  ///@ ROW,COL SAY ""
  
RETURN .T.

PROCEDURE ELIMINAVARS(VAR,DIM,DIMR,DIMC,DIMP,DIMB)
LOCAL I,J,K,L
  SWITCH DIM
     CASE 1
        FOR I:=1 TO DIMR
           RELEASE VAR[I]
        END
        RELEASE VAR
        EXIT
     CASE 2
        FOR I:=1 TO DIMR
           FOR J:=1 TO DIMC
              RELEASE VAR[I][J]
           END
           RELEASE VAR[I]
        END
        RELEASE VAR
        EXIT
     CASE 3
        FOR I:=1 TO DIMR
           FOR J:=1 TO DIMC
              FOR K:=1 TO DIMP
                 RELEASE VAR[I][J][K]
              END
              RELEASE VAR[I][J]
           END
           RELEASE VAR[I]
        END
        RELEASE VAR
        EXIT
     OTHERWISE
        FOR I:=1 TO DIMR
           FOR J:=1 TO DIMC
              FOR K:=1 TO DIMP
                 FOR L:=1 TO DIMB
                    RELEASE VAR[I][J][K][L]
                 END
                 RELEASE VAR[I][J][K]
              END
              RELEASE VAR[I][J]
           END
           RELEASE VAR[I]
        END
        RELEASE VAR
  END
RETURN

FUNCTION FUNEPREC()  // 75
LOCAL EAX,EBX,TEMPORAL
LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP,EFX
  EAX:=STACK[CS]    // DECIMALES
  EBX:=STACK[CS-1]  // NUMERO A PRECISIONAR
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  --CS
  ++CWM
  IF VALTYPE(stk_var_02[EBX])=="N"
     stk_var_02[CWM]:=XFUNEPREC(stk_var_02[EBX],stk_var_02[EAX])
  ELSE
     if !FUNGETDIMS(EBX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
        RETURN _FUNPUTERROR("PREC/MATRIX NOT INITIALIZED",OP_CODE,CP)
     end

     //////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     TEMPORAL:=XFUNMATPREC(stk_var_02[EBX],stk_var_02[EAX],{ DIM,DIMR,DIMC,DIMP,DIMB })
     ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   //////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     RELEASE TEMPORAL
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
  END
  STACK[CS] := CWM
RETURN .T.

FUNCTION FUNPOSCHAR() // 6
LOCAL EAX,EBX,ECX,EDX
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  ECX:=STACK[CS-2]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CS -= 3
  IF VALTYPE(stk_var_02[EAX])=="N"
     EDX:=CHR(stk_var_02[EAX])
  ELSE
     EDX:=stk_var_02[EAX]
  END
  stk_var_02[ECX]:=XPOSCHAR(stk_var_02[ECX],stk_var_02[EAX],stk_var_02[EBX])
RETURN .T.
/****************************************************/
FUNCTION FUNUNIQUE()   // 7
LOCAL EAX,ELX,EFX,AX,PX,EHX,EIX,EJX,EKX,OP_CODE:=8000
LOCAL DIM,TYP,DIMR,DIMC,DIMP,DIMB,TEMPORAL
  EAX:=STACK[CS]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  ++CWM
  if !FUNGETDIMS(EAX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
     RETURN _FUNPUTERROR("UNIQUE/MATRIX NOT INITIALIZED",OP_CODE,CP)
  end
  if DIM!=1
     ////ELX:=DIMR*IIF(DIMC==0,1,DIMC)*IIF(DIMP==0,1,DIMP)*IIF(DIMB==0,1,DIMB)
     ////TEMPORAL:=ARRAY(ELX)
     TEMPORAL:=XLETMTOV(stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,0)
     DIM:=1
     TEMPORAL:=ASORT(TEMPORAL)  // ORDENO EL ARRAY
     stk_var_02[CWM]:=UNIQUE(TEMPORAL,ELX,IIF(TYP=="N",1,0))
  else
     ELX:=DIMR
     stk_var_02[EAX]:=ASORT(stk_var_02[EAX])
     stk_var_02[CWM]:=UNIQUE(stk_var_02[EAX],ELX,IIF(TYP=="N",1,0))
  end
  RELEASE TEMPORAL
  FUNPUTDIMS(CWM,DIM,TYP,LEN(stk_var_02[CWM]),0,0,0)
  STACK[CS] := CWM
RETURN .T.

FUNCTION FUNSETCODE()  // 8
LOCAL EAX,EBX,ECX
  EAX:=STACK[CS]
  ECX:=STACK[CS-1]
  EBX:=STACK[CS-2]  // codigo de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CS -= 2  
  ++CWM    // CAGA EL COD. DE FUNCION. NO HAY ALTERACION DE DATOS IMPORTANTES.BIEN.
RETURN __PSETCODE[stk_var_02[EBX]]:EXEC(EAX,ECX)
    
  FUNCTION FUNSETUNION(EAX,ECX)  // 1
  LOCAL EDX,OP_CODE:=801
  LOCAL EHX,EIX,EJX,EKX
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
     RETURN _FUNPUTERROR("SETUNION/MATRIX NOT INITIALIZED",OP_CODE,CP) 
  END
  IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
     RETURN _FUNPUTERROR("SETUNION/MATRIX NOT INITIALIZED",OP_CODE,CP)
  END
  IF DIM1!=1 .OR. DIM2!=1
     RETURN _FUNPUTERROR("SETUNION/DIMENSION GARRAFAL ERROR (NEED 'UNIQUE')",OP_CODE,CP)
  END
  stk_var_02[CWM]:=SETUNION(stk_var_02[ECX],stk_var_02[EAX],DIM2R,DIM1R,;
                   IIF(TYP1=="N",1,0))
  stk_var_02[CWM]:=ASORT(stk_var_02[CWM])
  stk_var_02[CWM]:=UNIQUE(stk_var_02[CWM],LEN(stk_var_02[CWM]),;
                   IIF(TYP1=="N",1,0) )
  FUNPUTDIMS(CWM,DIM1,TYP1,LEN(stk_var_02[CWM]),0,0,0)
  STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSETINTERSECTION(EAX,ECX)  // 2
  LOCAL EDX,OP_CODE:=802
  LOCAL EHX,EIX,EJX,EKX
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
     RETURN _FUNPUTERROR("SETINTER/MATRIX NOT INITIALIZED",OP_CODE,CP) 
  END
  IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
     RETURN _FUNPUTERROR("SETINTER/MATRIX NOT INITIALIZED",OP_CODE,CP)
  END
  IF DIM1!=1 .OR. DIM2!=1
     RETURN _FUNPUTERROR("SETINTER/DIMENSION GARRAFAL ERROR (NEED 'UNIQUE')",OP_CODE,CP)
  END
  stk_var_02[CWM]:=SETINTERSECTION(stk_var_02[ECX],stk_var_02[EAX],DIM2R,DIM1R,;
                   IIF(TYP1=="N",1,0))
  
  FUNPUTDIMS(CWM,DIM1,TYP1,LEN(stk_var_02[CWM]),0,0,0)
  STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNSETDIFF(EAX,ECX)  // 3
  LOCAL EDX,OP_CODE:=803
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
     RETURN _FUNPUTERROR("SETDIFF/MATRIX NOT INITIALIZED",OP_CODE,CP) 
  END
  IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
     RETURN _FUNPUTERROR("SETDIFF/MATRIX NOT INITIALIZED",OP_CODE,CP)
  END
  IF DIM1!=1 .OR. DIM2!=1
     RETURN _FUNPUTERROR("SETDIFF/DIMENSION GARRAFAL ERROR (NEED 'UNIQUE')",OP_CODE,CP)
  END
  TEMPORAL:=SETINTERSECTION(stk_var_02[ECX],stk_var_02[EAX],DIM2R,DIM1R,IIF(TYP1=="N",1,0))
  stk_var_02[CWM]:=SETDIFF(stk_var_02[ECX],TEMPORAL,DIM2R,LEN(TEMPORAL),;
                   IIF(TYP1=="N",1,0) )
  
 /////// SETDIFF(A,T,LA,LEN(T),IIF(VALTYPE(A[1])=="N",1,0))
  FUNPUTDIMS(CWM,DIM1,TYP1,LEN(stk_var_02[CWM]),0,0,0)
  STACK[CS] := CWM
  RELEASE TEMPORAL
  RETURN .T.

  FUNCTION FUNSETSDIFF(EAX,ECX)  // 4
  LOCAL EDX,OP_CODE:=804
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL1,TEMPORAL2,TEMPORAL,LENTEMP
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
     RETURN _FUNPUTERROR("SETSDIFF/MATRIX NOT INITIALIZED",OP_CODE,CP) 
  END
  IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
     RETURN _FUNPUTERROR("SETSDIFF/MATRIX NOT INITIALIZED",OP_CODE,CP)
  END
  IF DIM1!=1 .OR. DIM2!=1
     RETURN _FUNPUTERROR("SETSDIFF/DIMENSION GARRAFAL ERROR (NEED 'UNIQUE')",OP_CODE,CP)
  END
//  stk_var_02[CWM]:=SETDIFFS(stk_var_02[ECX],stk_var_02[EAX],DIM2R,DIM1R)

  TEMPORAL1:=SETUNION(stk_var_02[ECX],stk_var_02[EAX],DIM2R,DIM1R,IIF(TYP1=="N",1,0))

  TEMPORAL1:=UNIQUE(ASORT(TEMPORAL1),LEN(TEMPORAL1),IIF(TYP1=="N",1,0) )
  LENTEMP:=LEN(TEMPORAL1)
  TEMPORAL2:=SETINTERSECTION(stk_var_02[ECX],stk_var_02[EAX],DIM2R,DIM1R,IIF(TYP1=="N",1,0))

  TEMPORAL :=SETINTERSECTION(TEMPORAL1,TEMPORAL2,LENTEMP,LEN(TEMPORAL2),;
             IIF(TYP1=="N",1,0))
/*  for pepe:=1 to LENTEMP
    ? TEMPORAL1[pepe]
  end
  ?"____"
  for pepe:=1 to LEN(TEMPORAL)
    ? TEMPORAL[pepe]
  end*/
  stk_var_02[CWM]:=SETDIFF(TEMPORAL1,TEMPORAL,LENTEMP,LEN(TEMPORAL),;
                   IIF(TYP1=="N",1,0))

  FUNPUTDIMS(CWM,DIM1,TYP1,LEN(stk_var_02[CWM]),0,0,0)
  STACK[CS] := CWM
  RELEASE TEMPORAL,TEMPORAL1,TEMPORAL2
  RETURN .T.
  
/****************************************************/
FUNCTION FUNMATRANGE()    // 122
LOCAL BX,EAX,EBX,ECX,EEX,EHX,EIX,EJX,EKX,EPX,OP_CODE:=1220
LOCAL DIMR,XDIM,XDIM2,DIMR2,TYP,DIMC,EZX,FUENTE,FUENTE1,TEMPORAL
  EAX:=STACK[CS]   // matriz/numero
  ECX:=STACK[CS-1]   // numero/cod fantasma/matriz
  EBX:=STACK[CS-2]     // cod de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  CS-=2
  if stk_var_02[EBX]==3
     EZX:=EAX; EAX:=ECX; ECX:=EZX
  end
  if STK_CWMTOP>0
     EEX := STK_TEMP_DIR[STK_CWMTOP]
     if EEX!=EAX
        EEX := ASCAN(STK_ARRAY_DIR,EAX)
        XDIM := STK_ARRAY_DIM[EEX]
        DIMR := STK_ARRAY_ROW[EEX]
        TYP := STK_ARRAY_TYP[EEX]
     else   
        XDIM:=STK_TEMP_DIM[STK_CWMTOP]
        DIMR:=STK_TEMP_ROW[STK_CWMTOP]
        TYP:=STK_TEMP_TYP[STK_CWMTOP]
        STK_TEMP_DIR[STK_CWMTOP]:=0
        STK_CWMTOP--
     end
  else  // es legal
     EEX := ASCAN(STK_ARRAY_DIR,EAX)
     XDIM := STK_ARRAY_DIM[EEX]
     DIMR := STK_ARRAY_ROW[EEX]
     TYP := STK_ARRAY_TYP[EEX]
  end
  IF TYP!="N"
     RETURN _FUNPUTERROR("INDEX MATRIX OBELIX/VECTOR TYPE FUCKING MISMATCH",OP_CODE,CP)
  END
  IF stk_var_02[EBX]==1  // COORDENADAS FIL,COL,FILF,COLF,PAG.....
     IF XDIM==1
        IF DIMR>0
           FUENTE:=stk_var_02[EAX]
           if DIMR==4   // 2D
              DIMR:=((FUENTE[3]-FUENTE[1])+1) * ((FUENTE[4]-FUENTE[2])+1)
              DIMC:=2
              XDIM:=2
              TEMPORAL:=INDEX({FUENTE[1],FUENTE[2],FUENTE[4]},DIMR)
           elseif DIMR==5 .or. DIMR==6   // 3D
              IF DIMR==5
                 DIMR:=((FUENTE[3]-FUENTE[1])+1) * ((FUENTE[4]-FUENTE[2])+1) 
                 EZX:=FUENTE[5]
                 EPX:=FUENTE[5]
              ELSE
                 DIMR:=((FUENTE[3]-FUENTE[1])+1) * ((FUENTE[4]-FUENTE[2])+1) * ((FUENTE[6]-FUENTE[5])+1)
                 EZX:=FUENTE[5]
                 EPX:=FUENTE[6]
              END
              DIMC:=3
              XDIM:=2
              TEMPORAL:=INDEX2({FUENTE[1],FUENTE[2],FUENTE[4],EZX,EPX},DIMR)
           elseif DIMR==7 .OR. DIMR==8   // 4D
              IF DIMR==7
                 DIMR:=((FUENTE[3]-FUENTE[1])+1) * ((FUENTE[4]-FUENTE[2])+1) * ((FUENTE[6]-FUENTE[5])+1) 
                 EZX:=FUENTE[7]
                 EPX:=FUENTE[7]
              ELSE
                 DIMR:=((FUENTE[3]-FUENTE[1])+1) * ((FUENTE[4]-FUENTE[2])+1) * ((FUENTE[6]-FUENTE[5])+1) * ;
                       ((FUENTE[8]-FUENTE[7])+1)
                 EZX:=FUENTE[7]
                 EPX:=FUENTE[8]
              END
              DIMC:=4
              XDIM:=2
              TEMPORAL:=INDEX3({FUENTE[1],FUENTE[2],FUENTE[4],FUENTE[5],FUENTE[6],EZX,EPX},DIMR)
           else
              RETURN _FUNPUTERROR("INDEX MATRIX/RANGE ERROR SHETOUMARE",OP_CODE,CP)
           end
        ELSE
           RETURN _FUNPUTERROR("INDEX MATRIX ASTERIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END  
     ELSE
        RETURN _FUNPUTERROR("INDEX MATRIX/RANGE DIMENSION GARRAFAL ERROR",OP_CODE,CP)
     END
  ELSEIF stk_var_02[EBX]==2   // ARRAY DE COLUMNAS, NUM DE FILAS (1..F)
     IF XDIM==1
        IF DIMR>0
           FUENTE:=stk_var_02[EAX]
           DIMC:=LEN(FUENTE)
           DIMR:=stk_var_02[ECX]; XDIM:=2   ///; EPX:=0
           
           TEMPORAL:={}   ///ARRAY(DIMR*DIMC,2)
           FOR EHX:=1 to DIMR ; FOR EIX:=1 TO DIMC
              ////TEMPORAL[++EPX]:={EHX,FUENTE[EIX]}
              AADD(TEMPORAL,{EHX,FUENTE[EIX]})
           END; END
           DIMR:=DIMR*DIMC
           DIMC:=2
        ELSE
           RETURN _FUNPUTERROR("INDEX MATRIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END  
     ELSE
        RETURN _FUNPUTERROR("INDEX MATRIX/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
     END
  ELSEIF stk_var_02[EBX]==3   // ES 3 ARRAY DE FILAS, NUM DE COLUMNAS (1..C).
     IF XDIM==1
        IF DIMR>0
           FUENTE:=stk_var_02[EAX]
           DIMR:=LEN(FUENTE)   // filas
           DIMC:=stk_var_02[ECX] ; XDIM:=2   ////; EPX:=0
           TEMPORAL:={}   ///ARRAY(DIMR*DIMC,2)
           FOR EHX:=1 to DIMR ; FOR EIX:=1 TO DIMC
              AADD(TEMPORAL,{FUENTE[EHX],EIX})
           END; END
           DIMR:=DIMC*DIMR
           DIMC:=2
        ELSE
           RETURN _FUNPUTERROR("INDEX MATRIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END  
     ELSE
        RETURN _FUNPUTERROR("INDEX MATRIX/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
     END
  ELSE    // ES 4: array de filas y array de columnas.
     if STK_CWMTOP>0
        EEX := STK_TEMP_DIR[STK_CWMTOP]
        if EEX!=ECX
           EEX := ASCAN(STK_ARRAY_DIR,ECX)
           XDIM2 := STK_ARRAY_DIM[EEX]
           DIMR2 := STK_ARRAY_ROW[EEX]
           TYP := STK_ARRAY_TYP[EEX]
        else   
           XDIM2:=STK_TEMP_DIM[STK_CWMTOP]
           DIMR2:=STK_TEMP_ROW[STK_CWMTOP]
           TYP:=STK_TEMP_TYP[STK_CWMTOP]
           STK_TEMP_DIR[STK_CWMTOP]:=0
           STK_CWMTOP--
        end
     else  // es legal
        EEX := ASCAN(STK_ARRAY_DIR,ECX)
        XDIM2 := STK_ARRAY_DIM[EEX]
        DIMR2 := STK_ARRAY_ROW[EEX]
        TYP := STK_ARRAY_TYP[EEX]
     end
     IF XDIM==1 .and. XDIM2==1
        IF DIMR>0 .AND. DIMR2>0
           FUENTE:=stk_var_02[EAX]
           DIMR:=LEN(FUENTE)   // COLS
           FUENTE1:=stk_var_02[ECX]
           DIMR2:=LEN(FUENTE1) ; XDIM:=2   //FILS
           TEMPORAL:={}
           FOR EHX:=1 to DIMR2 ; FOR EIX:=1 TO DIMR
              AADD(TEMPORAL,{FUENTE1[EHX],FUENTE[EIX]})
           END; END
           DIMR:=DIMR2*DIMR
           DIMC:=2
        ELSE
           RETURN _FUNPUTERROR("INDEX MATRIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END  
     ELSE
        RETURN _FUNPUTERROR("INDEX MATRIX/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
     END
  END
  ///stk_var_02[CWM]:=ARRAY(DIMR,DIMC)
  stk_var_02[CWM]:=TEMPORAL   //////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,0,0,0)
  RELEASE TEMPORAL
  FUNPUTDIMS(CWM,XDIM,"N",DIMR,DIMC,0,0)
  STACK[CS] := CWM   
RETURN .T.

/****************************************************/
FUNCTION FUNRESHAPE()  // 103
LOCAL DIM,OP_CODE:=1030
LOCAL AX,BX,CX,DX,EX,EAX,ECX,EDX,EEX,EFX,EMX,EPX,EHX,EIX,EJX,EKX,EWX
LOCAL DIMR,DIMC,DIMP,DIMB,TYP
  EEX:=STACK[CS]   // RANGO B
  EDX:=STACK[CS-1] // RANGO P
  ECX:=STACK[CS-2] // RANGO C 
  EBX:=STACK[CS-3] // RANGO R
  EAX:=STACK[CS-4] // matriz FUENTE
  CWM:=CMPCWM(EEX,CWM,TopCWM)
  CWM:=CMPCWM(EDX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CS-=5
  IF !FUNGETDIMS(EAX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.F.)
     RETURN _FUNPUTERROR("RESHAPE/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
  end
  BX:=stk_var_02[EBX]
  CX:=stk_var_02[ECX]
  DX:=stk_var_02[EDX]
  EX:=stk_var_02[EEX]
  EMX:=DIMR*IIF(DIMC>0,DIMC,1)*IIF(DIMP>0,DIMP,1)*IIF(DIMB>0,DIMB,1)
  IF EMX != BX*IIF(CX>0,CX,1)*IIF(DX>0,DX,1)*IIF(EX>0,EX,1)
     RETURN _FUNPUTERROR("RESHAPE/DIMENSION ERROR",OP_CODE+1,CP)
  ELSEIF BX==0
     RETURN _FUNPUTERROR("RESHAPE/PLEASE! ARE YOU A FUCKING JOKER???",OP_CODE+2,CP)
  END  
  
  /* ANALISIS DE FLAG */
       FVWITH := FLAG[1]   // valor
       FTWITH := UPPER(FLAG[2])   // tipo
       if FTWITH!="C"
          FVWITH:="RR"   // por defecto: filas leo, filas guardo.
          
          /* otros casos:
             RC leo filas, guardo columnas
             CC leo y guardo columnas
             CR leo columnas y guardo filas
          */
       end
       FVWITH:=UPPER(FVWITH)
       /*  */
       
  // CONVERTIR MATRIZ FUENTE EN VECTOR
  ////AX:=ARRAY(EMX)
  EPX:=0
  EWX:=SUBSTR(FVWITH,1,1)  // OBTENGO MODO LECTURA
  IF DIM==1
     AX:=XLETMTOV(stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,0)  
  ELSE
     IF EWX == "R"  // por filas
        AX:=XLETMTOV(stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,0)
     ELSE
        AX:=XLETMTOV(stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,1)
     END
  END
  // COPIO A NUEVO RANGO:
  /////stk_var_02[EAX]:=ARRAY(BX,CX,DX,EX)
  
  EPX:=0
  EWX:=SUBSTR(FVWITH,2,1)  // OBTENGO MODO ESCRITURA
  DIM := IIF(EX!=0,4,IIF(DX!=0,3,IIF(CX!=0,2,1)))
  IF DIM==1
     stk_var_02[EAX]:=XLETVTOM(AX,DIM,BX,CX,DX,EX,0)  
  ELSE
     IF EWX=="R"
        stk_var_02[EAX]:=XLETVTOM(AX,DIM,BX,CX,DX,EX,0)
     ELSE
        stk_var_02[EAX]:=XLETVTOM(AX,DIM,BX,CX,DX,EX,1)
     END
  END
  
  RELEASE AX
  STK_ARRAY_DIM[EFX]:=DIM
  STK_ARRAY_ROW[EFX]:=BX
  STK_ARRAY_COL[EFX]:=CX
  STK_ARRAY_PAG[EFX]:=DX
  STK_ARRAY_BLK[EFX]:=EX
  STK_ARRAY_TYP[EFX]:=TYP
  
RETURN .T.

/*****************************************************/

FUNCTION FUNADDMATSTR()   // 202
LOCAL XDIM,XOP_CODE:=2020
LOCAL AX,EAX,EBX,ECX,EDX,EEX,TEMPORAL
LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
LOCAL DIMR,DIMC,DIMP,DIMB,TYP

     EAX:=STACK[CS]     //B
     EBX:=STACK[CS-1]   //A   Orden: A op B EBX op EAX
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)    
     ++CWM
     ECX:=valtype(stk_var_02[EBX])+valtype(stk_var_02[EAX])
     if valtype(stk_var_02[EAX])=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("MATRIX OPE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
        END
     end
     if valtype(stk_var_02[EBX])=="A"
        IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MATRIX OPE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
        END
     end
     if ECX=="AA"
        if DIM1==DIM2
           if DIM1R==DIM2R .and. DIM1C==DIM2C .and. DIM1P==DIM2P .and. DIM1B==DIM2B
              DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B; XDIM:=DIM1
              /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
              TEMPORAL:=XMMSTRLET(stk_var_02[EBX],stk_var_02[EAX],XDIM,DIMR,DIMC,DIMP,DIMB)
              IF LEN(TEMPORAL)>0
                 ///stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
                 stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
              ELSE
                 RETURN _FUNPUTERROR("MATRIX OPE/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
              END
           else
              RETURN _FUNPUTERROR("MATRIX OPE/DIMENSION GARRAFAL ERROR",XOP_CODE,CP)
           end
        else
           RETURN _FUNPUTERROR("MATRIX OPE/DIMENSION GARRAFAL ERROR",XOP_CODE,CP)
        end
     elseif ECX=="AC"
        DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        XDIM:=DIM1
  /*****/
       //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        TEMPORAL:=XMESTRLET(stk_var_02[EBX],stk_var_02[EAX],XDIM,DIMR,DIMC,DIMP,DIMB,0)
        IF LEN(TEMPORAL)>0
           ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           stk_var_02[CWM]:= TEMPORAL //// XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
        ELSE
           RETURN _FUNPUTERROR("MATRIX OPE/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
        END
  /*****/

     else   // debe ser "CA"
        DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        XDIM:=DIM2
  /*****/
        ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        TEMPORAL:=XMESTRLET(stk_var_02[EAX],stk_var_02[EBX],XDIM,DIMR,DIMC,DIMP,DIMB,1)
        IF LEN(TEMPORAL)>0
           ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
        ELSE
           RETURN _FUNPUTERROR("MATRIX OPE/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
        END
  /*****/
     end
  RELEASE TEMPORAL
  FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
  STACK[--CS] := CWM
RETURN .T.

/***********************************************************/

FUNCTION CODESUBMAT()   // 160
LOCAL XDIM,XOP_CODE:=1600
LOCAL EAX,EBX,ECX,EEX,EDX,TEMPORAL
LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
LOCAL DIMR,DIMC,DIMP,DIMB,TYP

  OP_CODE:=stk_prg[++CP]  // siguiente

     EAX:=STACK[CS]     //B
     EBX:=STACK[CS-1]   //A   Orden: A op B EBX op EAX
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     ++CWM
     ECX:=valtype(stk_var_02[EBX])+valtype(stk_var_02[EAX])
     if valtype(stk_var_02[EAX])=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("MATRIX STRING OPE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
        END
     end
     if valtype(stk_var_02[EBX])=="A"
        IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MATRIX STRING OPE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
        END
     end
     if ECX=="AA"
        // VALIDACIONES PARA ESTA COMBINACION
        if DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P .AND. DIM1B==DIM2B
           // OPERACIONES:
           DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B; XDIM:=DIM1
           if DIM1==DIM2 // OPERA MATRICES DEL MISMO TAMANIO
              if OP_CODE==43
                 OP_CODE:=253
              end
              OP_CODE:=OP_CODE-251  // NORMALIZA PARA CREAR FUNCION DE LLAMADA!
              IF !(__POPEMATSUB1D[OP_CODE]:EXEC(CWM,EAX,EBX,DIM1,DIMR,DIMC,DIMP,DIMB,TYP2+TYP1))
                 RETURN .F.
              END
           
           else
              RETURN _FUNPUTERROR("MATRIX STRING OPE/DIMENSIONS COMOU EL CULOU",XOP_CODE,CP)
           end
        else
           RETURN _FUNPUTERROR("MATRIX STRING OPE/DIMENSION CTHULU GARRAFAL ERROR",XOP_CODE,CP)
        end
     elseif ECX=="AN".or.ECX=="NA"   // matriz POR ESCALAR A op N
        if ECX=="AN"
           DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B; XDIM:=DIM1
        else
           DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B; XDIM:=DIM2
        end
        if OP_CODE==43
           OP_CODE:=253
        end
        OP_CODE:=OP_CODE-251   // NORMALIZA PARA CREAR FUNCION DE LLAMADA!

        IF !(__POPEESCMATSUB1D[OP_CODE]:EXEC(CWM,EAX,EBX,XDIM,DIMR,DIMC,DIMP,DIMB,ECX))
           RETURN .F.
        END
     end
  RELEASE TEMPORAL
  FUNPUTDIMS(CWM,XDIM,"N",DIMR,DIMC,DIMP,DIMB)
  STACK[--CS] := CWM

RETURN .T.

/***********************************************************/

FUNCTION FUNSUBEMSTR(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)
LOCAL TEMPORAL
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  IF TYP=="AN"
     TEMPORAL:=XMEADDSTR(stk_var_02[EBX],stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,2)
  ELSE
     TEMPORAL:=XMEADDSTR(stk_var_02[EAX],stk_var_02[EBX],DIM,DIMR,DIMC,DIMP,DIMB,2)
  END
  IF LEN(TEMPORAL)>0
    /// stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  ELSE
     RETURN _FUNPUTERROR("MATRIX STRING OPE/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
  END
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNADDEMSTR(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)
LOCAL TEMPORAL,XRT
  /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  IF TYP=="AN"
     TEMPORAL:=XMEADDSTR(stk_var_02[EBX],stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,1)
  ELSE
     TEMPORAL:=XMEADDSTR(stk_var_02[EAX],stk_var_02[EBX],DIM,DIMR,DIMC,DIMP,DIMB,1)
  END
  IF LEN(TEMPORAL)>0
     ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:= TEMPORAL   ////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  ELSE
     RETURN _FUNPUTERROR("MATRIX STRING OPE/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
  END
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNSUBMMSTR(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)
LOCAL TEMPORAL
  ///TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  IF TYP=="CN"
     TEMPORAL:=XRPSUBSTR(stk_var_02[EAX],stk_var_02[EBX],DIM,DIMR,DIMC,DIMP,DIMB,2)
  ELSE
     TEMPORAL:=XRPSUBSTR(stk_var_02[EBX],stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,2)
  END
  IF LEN(TEMPORAL)>0
     ///stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:= TEMPORAL  ///  XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  ELSE
     RETURN _FUNPUTERROR("MATRIX STRING OPE/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
  END
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNADDMMSTR(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)
LOCAL TEMPORAL,XRT
  /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  IF TYP=="CN"
     TEMPORAL:=XRPSUBSTR(stk_var_02[EAX],stk_var_02[EBX],DIM,DIMR,DIMC,DIMP,DIMB,1)
  ELSE
     TEMPORAL:=XRPSUBSTR(stk_var_02[EBX],stk_var_02[EAX],DIM,DIMR,DIMC,DIMP,DIMB,1)
  END
  IF LEN(TEMPORAL)>0
     ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:= TEMPORAL   ////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  ELSE
     RETURN _FUNPUTERROR("MATRIX STRING OPE/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
  END
  RELEASE TEMPORAL
RETURN .T.

/***********************************************************/

FUNCTION OPMATRICES()   // 227
LOCAL XDIM,XOP_CODE:=2270
LOCAL AX,EAX,EBX,ECX,EDX,EEX
LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
LOCAL DIMR,DIMC,DIMP,DIMB,TYP,SW_MATRICIAL:=.F.
//PUBLIC EZX
  /******************************************************************
            INNOVACION!! INSERTO UN CODIGO DE OPERACION
            DE MATRICES: VALIDO PARA FUNCIONES Y OPERACIONES
            MATEMATICAS.
            ESTO IMPLICA DUPLICAR LOS CODIGOS...
   ******************************************************************/   

  OP_CODE:=stk_prg[++CP]  // siguiente

     EAX:=STACK[CS]     //B
     EBX:=STACK[CS-1]   //A   Orden: A op B EBX op EAX
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     ++CWM
     ECX:=valtype(stk_var_02[EBX])+valtype(stk_var_02[EAX])
     if valtype(stk_var_02[EAX])=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("MATRIX OPE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
        END
     end
     if valtype(stk_var_02[EBX])=="A"
        IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MATRIX OPE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
        END
     end
     if ECX=="AA"
        // VALIDACIONES PARA ESTA COMBINACION
        if DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P .AND. DIM1B==DIM2B
           // OPERACIONES:
           DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B; XDIM:=DIM1
           if DIM1==DIM2 // OPERA MATRICES DEL MISMO TAMANIO
              if OP_CODE==43
                 OP_CODE:=253
              end
              ////////////OP_CODE:=OP_CODE-245   // NORMALIZA PARA CREAR FUNCION DE LLAMADA!
              OP_CODE:=OP_CODE-240   // para incluir operadores lógicos solo para números.
              IF OP_CODE>6
                 AX:=(__POPEMATNOR1D[OP_CODE]:EXEC(CWM,EAX,EBX,DIM1,DIMR,DIMC,DIMP,DIMB))
              ELSE
                 // OP "EQUAL" CON CÓDIGO DE FUNCION (< 6) PARA OTROS OPERADORES
                 AX:=(__POPEMATNOR1D[ 6 ]:EXEC(CWM,EAX,EBX,DIM1,DIMR,DIMC,DIMP,DIMB,OP_CODE))
                 IF AX
                    STACK[--CS] := CWM
                    RETURN .T.
                 ELSE
                    RETURN .F.
                 END
              END
              IF !AX   //EMPTY(AX)
                 RETURN .F.
              END
           
           else
              RETURN _FUNPUTERROR("MATRIX OPE/DIMENSIONS COMOU EL CULOU",XOP_CODE,CP)
           end
        else
           RETURN _FUNPUTERROR("MATRIX OPE/DIMENSION CTHULU GARRAFAL ERROR",XOP_CODE,CP)
        end
     elseif ECX=="AN".or.ECX=="NA"   // matriz POR ESCALAR A op N
        if ECX=="AN"
           DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B; XDIM:=DIM1
        else
           DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B; XDIM:=DIM2
        end
        if OP_CODE==43
           OP_CODE:=253
        end
        OP_CODE:=OP_CODE-246   // NORMALIZA PARA CREAR FUNCION DE LLAMADA!
        
        AX:=(__POPEESCMAT1D[OP_CODE]:EXEC(CWM,EAX,EBX,XDIM,DIMR,DIMC,DIMP,DIMB,ECX))

        IF !AX
           RETURN .F.
        END
     end
     
  //if valtype(stk_var_02[CWM])!="L"
  FUNPUTDIMS(CWM,XDIM,"N",DIMR,DIMC,DIMP,DIMB)
  //end
  STACK[--CS] := CWM
RETURN .T.

/**********************************************************
    FUNCIONES UTILITARIAS DE OPERACIONES CON MATRICES
***********************************************************/   

FUNCTION FUNMODEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 247
LOCAL OP_CODE:=2470,TEMPORAL,ERX:=1
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 1
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,7,0 })
     ELSE
        TEMPORAL:=XEMLET(0,DIM,DIMR,DIMC,DIMP,DIMB) // LO LLENO CON 0
     END
  ELSE
     IF BBX != 1
        TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,7,1 })
     ELSE
        TEMPORAL:=XEMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB)  // LO LLENO CON 1
     END
  END
  IF LEN(TEMPORAL)==0
     _FUNPUTERROR("MOD (%)/MODULE BY CERO (WEON-ERROR)",OP_CODE,CP)
     RETURN .F.
  END
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNPOWEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 248
LOCAL OP_CODE:=2480,TEMPORAL,ERX:=1
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 0
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,6,0 })
     ELSE
        TEMPORAL:=XEMLET(AAX,DIM,DIMR,DIMC,DIMP,DIMB) // LO LLENO CON 0
     END
  ELSE
     IF BBX != 1
        TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,6,1 })
     ELSE
        TEMPORAL:=XEMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB)  // LO LLENO CON 1
     END
  END
  IF LEN(TEMPORAL)==0
     _FUNPUTERROR("POW (^)/COMPUTE ERROR",OP_CODE+1,CP)
     RETURN .F.
  END
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.


FUNCTION FUNIDIVEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 249
LOCAL BBX,AAX,ERX,OP_CODE:=2490,TEMPORAL
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)   // al final hay que borrar esto
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 1 .AND. AAX != 0
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,5,0 })
        IF len(TEMPORAL)==0
           _FUNPUTERROR("INTEGER DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
           RETURN .F.
        END
     ELSEIF AAX == 1
        TEMPORAL:=XMMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB,2) // codfun=2 asigna entero
     ELSE
        _FUNPUTERROR("INTEGER DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
        RETURN .F.
     END
  ELSE
     // SI BBX==0, DEBE CALCULAR IGUAL, PORQUE LA MATRIZ PUEDE TENER UN CERO, Y ESO
     // PODRÍA AFECTAR FUTUROS CÁLCULOS
     TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,5,1 })
     IF LEN(TEMPORAL)==0
        _FUNPUTERROR("INTEGER DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
        RETURN .F.
     END
  END
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNDIVEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 250
LOCAL BBX,AAX,ERX,OP_CODE:=2500,TEMPORAL
 //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 1 .AND. AAX != 0
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,4,0 })
        IF LEN(TEMPORAL)==0
           _FUNPUTERROR("DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
           RETURN .F.
        END
     ELSEIF AAX == 1
        TEMPORAL:=BBX   ///XMMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     ELSE
        _FUNPUTERROR("DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
        RETURN .F.
     END
  ELSE
     // SI BBX==0, DEBE CALCULAR IGUAL, PORQUE LA MATRIZ PUEDE TENER UN CERO, Y ESO
     // PODRÍA AFECTAR FUTUROS CÁLCULOS
     TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,4,1 })
     IF LEN(TEMPORAL)==0
        _FUNPUTERROR("DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
        RETURN .F.
     END
  END
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNMULEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 251
LOCAL BBX,AAX,ERX,TEMPORAL
 //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 0 .AND. AAX != 1
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,3,0 })
     ELSEIF AAX == 1
        TEMPORAL:=BBX  ///XMMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     ELSEIF AAX == 0
        TEMPORAL:=XEMLET(AAX,DIM,DIMR,DIMC,DIMP,DIMB)
     END
  ELSE
     IF BBX != 0 .AND. BBX != 1
        TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,3,1 })
     ELSEIF BBX == 1
        TEMPORAL:=AAX   ///XMMLET(AAX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     ELSEIF BBX == 0
        TEMPORAL:=XEMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB)
     END
  END
  ///stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.


FUNCTION FUNSUBEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 252
LOCAL BBX,AAX,TEMPORAL,ERX
 //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 0
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,2,0 })
     ELSE
        TEMPORAL:=BBX ////XMMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     END
  ELSE   // da lo mismo que sea 0-A, porque tendríaque hacer otra funcion que asigne -A: paja.
     TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,2,1 })
  END
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:=TEMPORAL  ////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNADDEM1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,TYP)   // 253
LOCAL BBX,AAX,ERX,TEMPORAL
 //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  IF TYP=="AN"
     IF AAX != 0
        TEMPORAL:=XEMCOMPUTE(AAX,BBX,{ DIM,DIMR,DIMC,DIMP,DIMB,1,0 })
     ELSE
        TEMPORAL:=BBX ///XMMLET(BBX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     END
  ELSE
     IF BBX != 0
        TEMPORAL:=XEMCOMPUTE(BBX,AAX,{ DIM,DIMR,DIMC,DIMP,DIMB,1,1 })
     ELSE
        TEMPORAL:=AAX ////XMMLET(AAX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     END
  END
  /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:=TEMPORAL   ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.


FUNCTION FUNEQU1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB,CODFUN)  // 246
LOCAL EHX,AAX,BBX,ETX
  
  AAX:=stk_var_02[EAX]
  BBX:=stk_var_02[EBX]
// EVALUAR TIPOS SEGUN DIMENSION
  IF DIM==1
     ETX:=VALTYPE(AAX[1])
  ELSEIF DIM==2
     ETX:=VALTYPE(AAX[1][1])
  ELSEIF DIM==3
     ETX:=VALTYPE(AAX[1][1][1])
  ELSE
     ETX:=VALTYPE(AAX[1][1][1][1])  
  END

  EHX:=XMMEQUAL(BBX,AAX,DIM,DIMR,DIMC,DIMP,DIMB,CODFUN,ETX)
  IF EHX==0
     stk_var_02[CWM]:=.F.
     RETURN .T.
  END
  stk_var_02[CWM]:=.T.
RETURN .T.


FUNCTION FUNMOD1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)   // 247
LOCAL AAX,BBX,OP_CODE:=2470,ETX,TEMPORAL,ERX
  AAX:=stk_var_02[EAX]
  BBX:=stk_var_02[EBX]
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  TEMPORAL:=XMMCOMPUTE(BBX,AAX,{DIM,DIMR,DIMC,DIMP,DIMB,7})
  
  IF LEN(TEMPORAL)==0
     _FUNPUTERROR("MOD (%)/MODULE BY CERO (WEON-ERROR)",OP_CODE,CP)
     RETURN .F.
  END
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  //XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNPOW1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)   // 248
LOCAL AAX,BBX,OP_CODE:=2480,ETX,TEMPORAL,ERX
  AAX:=stk_var_02[EAX]
  BBX:=stk_var_02[EBX]
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  TEMPORAL:=XMMCOMPUTE(BBX,AAX,{DIM,DIMR,DIMC,DIMP,DIMB,6})
  IF LEN(TEMPORAL)==0
     _FUNPUTERROR("POW (^)/COMPUTE ERROR",OP_CODE+1,CP)
     RETURN .F.
  END
  /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  //XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNIDIV1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)   // 249
LOCAL OP_CODE:=2490,AAX,BBX,TEMPORAL,ERX
  AAX:=stk_var_02[EAX]
  BBX:=stk_var_02[EBX]
  ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)

  TEMPORAL:=XMMCOMPUTE(BBX,AAX,{DIM,DIMR,DIMC,DIMP,DIMB,5})
  IF LEN(TEMPORAL)==0
    _FUNPUTERROR("INTEGER DIV/DIVISION BY CERO (WEON-ERROR)",OP_CODE,CP)
    RETURN .F.
  END
  /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:=TEMPORAL   ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNDIV1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)   // 250
LOCAL OP_CODE:=2500,AAX,BBX,TEMPORAL,ERX
  AAX:=stk_var_02[EAX]
  BBX:=stk_var_02[EBX]
  /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  
  TEMPORAL:=XMMCOMPUTE(BBX,AAX,{DIM,DIMR,DIMC,DIMP,DIMB,4})
  IF LEN(TEMPORAL)==0
    _FUNPUTERROR("DIV/DIVISION BY CERO (WEON-ERROR)!!!",OP_CODE,CP)
    RETURN .F.
  END
  /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:=TEMPORAL  //XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNMUL1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)  // 251
LOCAL EHX,AAX,BBX,TEMPORAL,ERX
  AAX:=stk_var_02[EAX]
  BBX:=stk_var_02[EBX]
  /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  TEMPORAL:=XMMCOMPUTE(AAX,BBX,{DIM,DIMR,DIMC,DIMP,DIMB,3})
  ////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL //XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNSUB1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)  // 252
LOCAL AAX,BBX,TEMPORAL,ERX
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  TEMPORAL:=XMMCOMPUTE(BBX,AAX,{DIM,DIMR,DIMC,DIMP,DIMB,2})
  /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  //XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

FUNCTION FUNADD1D(CWM,EAX,EBX,DIM,DIMR,DIMC,DIMP,DIMB)  // 253
LOCAL AAX,BBX,TEMPORAL,ERX
  BBX:=stk_var_02[EBX]
  AAX:=stk_var_02[EAX]
  /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  TEMPORAL:=XMMCOMPUTE(AAX,BBX,{DIM,DIMR,DIMC,DIMP,DIMB,1})
  /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
  stk_var_02[CWM]:= TEMPORAL  ///XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
  RELEASE TEMPORAL
RETURN .T.

/***** HASTA AQUI CALCULOS MTRICIALES ******/

 FUNCTION FUNWRITE()   // 232
LOCAL AX,EAX,CX,DX,FX,OP_CODE:=2320,TYPENUM
   EAX:=STACK[CS]
   AX:=stk_var_02[EAX]
   CWM:=CMPCWM(EAX,CWM,TopCWM)
   --CS
   TYPENUM:={"NAN","INF"}
   CX:=VALTYPE(AX)
   if SW_FHNDLOUT==1 
      if CX=="L"
         DX:=iif(AX, CONTEXT_TRUE, CONTEXT_FALSE)
         fwrite (FHNDLOUT,DX,len(DX))
      elseif CX=="N"
         FX:=XU_TYPENUM(AX)
         if FX==0
            if CONTEXT_NUMBER=="E" .or. ABS(AX)>XINFINITY().or. (ABS(AX)>0.and.ABS(AX)<0.0000000000000001)
               DX:=D2E(AX,XUPRECISION)
            else
               DX:=XFUNNUM2STRING(AX,XUPRECISION) //alltrim(str(AX) ) 
            end
         else
            DX:=TYPENUM[FX]
         end
         fwrite (FHNDLOUT,DX,len(DX))
      elseif CX=="A"
         UTILWRITMAT(EAX,0)
      else
      //   DX:=AX
         fwrite (FHNDLOUT,AX,len(AX))
      end
      //fwrite (FHNDLOUT,DX,len(DX))
   end
   if SW_CONSOLE==0
     
      if CX=="C"
         outstd( AX )
         //fwrite(1, AX )
      elseif CX=="N"
         FX:=XU_TYPENUM(AX)
         if FX==0
            if CONTEXT_NUMBER=="E" .or. ABS(AX)>XINFINITY().or. (ABS(AX)>0.and.ABS(AX)<0.0000000000000001)
               outstd( D2E(AX,XUPRECISION) )
              // fwrite(1, D2E(AX,XUPRECISION) )
            else
               outstd( XFUNNUM2STRING(AX,XUPRECISION) )
              // fwrite(1, XFUNNUM2STRING(AX,XUPRECISION) )
            end
         else
            outstd( TYPENUM[FX])
           // fwrite(1, TYPENUM[FX])
         end
      elseif CX=="L"   // ESTO ES POR EL VARIANT
         outstd( iif(AX, CONTEXT_TRUE, CONTEXT_FALSE) )
         //fwrite(1, iif(AX, CONTEXT_TRUE, CONTEXT_FALSE) )
      else
         UTILWRITMAT(EAX,1)
      end
         
   end
RETURN .T.

  FUNCTION UTILWRITMAT(EBX,SALIDA)     // 84
  LOCAL BX,EDX,EVX,EHX,EIX,EKX,SX,AX,DX,EX,FX,OX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP,FVWITH,TYPENUM
  LOCAL OP_CODE:=840
    BX:=stk_var_02[EBX]        // stack
    
       /* ANALISIS DE FLAG */
       FVWITH := FLAG[1]   // valor
       FTWITH := UPPER(FLAG[2])   // tipo
       if FTWITH!="C"
          FVWITH := ","   // por defecto
       end
       FVWITH:=UPPER(FVWITH)
       /*  */
    IF !FUNGETDIMS(EBX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
       RETURN _FUNPUTERROR("WRITE/MATRIX NOT INITILIZED",OP_CODE,CP)
    END
    TYPENUM:={"NAN","INF"}
    if DIM==1  // es una dimension 
       if DIMR>0
          EVX:=valtype(stk_var_02[EBX][1])
          if EVX=="L"
             if SALIDA==1
               outstd(iif(stk_var_02[EBX][1],CONTEXT_TRUE,CONTEXT_FALSE))
               for EHX:=2 to DIMR
                  outstd(FVWITH+iif(stk_var_02[EBX][EHX],CONTEXT_TRUE,CONTEXT_FALSE))
               end
             else
               OX:=iif(stk_var_02[EBX][1],CONTEXT_TRUE,CONTEXT_FALSE)
               fwrite (FHNDLOUT,OX,len(OX))
               for EHX:=2 to DIMR
                  OX:=FVWITH+iif(stk_var_02[EBX][EHX],CONTEXT_TRUE,CONTEXT_FALSE)
                  fwrite (FHNDLOUT,OX,len(OX))
               end
             end
          elseif EVX=="N"
             DX:=stk_var_02[EBX][1]
             FX:=XU_TYPENUM(DX)
             IF SALIDA==1
                if FX==0
                   if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                      outstd( D2E(DX,XUPRECISION) )
                   else
                      outstd( XFUNNUM2STRING(DX,XUPRECISION) )
                   end
                else
                   outstd( TYPENUM[FX])
                end
             //outstd(iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][1],XUPRECISION),alltrim(str(stk_var_02[EBX][1]))))
                for EHX:=2 to DIMR
                   DX:=stk_var_02[EBX][EHX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         outstd( FVWITH+D2E(DX,XUPRECISION) )
                      else
                         outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      outstd( FVWITH+TYPENUM[FX])
                   end
//                 outstd(FVWITH+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX]))))
                end
             ELSE
                if FX==0
                   if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                      OX:=D2E(DX,XUPRECISION)
                   else
                      OX:=XFUNNUM2STRING(DX,XUPRECISION)
                   end
                else
                   OX:=TYPENUM[FX]
                end
                fwrite (FHNDLOUT,OX,len(OX))

                for EHX:=2 to DIMR
                   DX:=stk_var_02[EBX][EHX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         OX:=FVWITH+D2E(DX,XUPRECISION)
                      else
                         OX:=FVWITH+XFUNNUM2STRING(DX,XUPRECISION)
                      end
                   else
                      OX:=FVWITH+TYPENUM[FX]
                   end
                   fwrite (FHNDLOUT,OX,len(OX))
                end
             
             END
          else
             IF SALIDA==1
                outstd(alltrim(stk_var_02[EBX][1]))
                for EHX:=2 to DIMR
                   outstd(FVWITH+stk_var_02[EBX][EHX])
                end
             ELSE
                OX:=alltrim(stk_var_02[EBX][1])
                fwrite (FHNDLOUT,OX,len(OX))
                for EHX:=2 to DIMR
                   OX:=FVWITH+stk_var_02[EBX][EHX]
                   fwrite (FHNDLOUT,OX,len(OX))
                end
             END
          end
       else
          IF SALIDA==1
             outstd("[]")
          ELSE
             fwrite (FHNDLOUT,"[]",2)
          END
       end
    elseif DIM==2  // es bidimensional
       if DIMR>0 .and. DIMC>0
          EVX:=valtype(stk_var_02[EBX][1][1])
          if EVX=="L"
             IF SALIDA==1
                for EHX:=1 to DIMR
                   outstd(iif(stk_var_02[EBX][EHX][1],CONTEXT_TRUE,CONTEXT_FALSE))
                   for EIX:=2 to DIMC
                      outstd( FVWITH+iif(stk_var_02[EBX][EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE))
                   end
                   outstd(_CR)
                end
             ELSE
                for EHX:=1 to DIMR
                   OX:=iif(stk_var_02[EBX][EHX][1],CONTEXT_TRUE,CONTEXT_FALSE)
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EIX:=2 to DIMC
                      OX:=FVWITH+iif(stk_var_02[EBX][EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE)
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end
             END
          elseif EVX=="N"
             IF SALIDA==1
                for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         outstd( D2E(DX,XUPRECISION) )
                      else
                         outstd( XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      outstd( TYPENUM[FX])
                   end
//                outstd(iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][1],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX][1]))))
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            outstd( FVWITH+D2E(DX,XUPRECISION) )
                         else
                            outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                         end
                      else
                         outstd( FVWITH+TYPENUM[FX])
                      end
//                   outstd( FVWITH+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX][EIX]))))
                   end
                   outstd(_CR)
                end
             ELSE
                for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         OX:=D2E(DX,XUPRECISION) 
                      else
                         OX:=XFUNNUM2STRING(DX,XUPRECISION) 
                      end
                   else
                      OX:=TYPENUM[FX]
                   end
                   fwrite (FHNDLOUT,OX,len(OX))
                   
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            OX:=FVWITH+D2E(DX,XUPRECISION)
                         else
                            OX:=FVWITH+XFUNNUM2STRING(DX,XUPRECISION)
                         end
                      else
                         OX:=FVWITH+TYPENUM[FX]
                      end
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end
             END
          else
             IF SALIDA==1
                for EHX:=1 to DIMR
                   outstd(alltrim(stk_var_02[EBX][EHX][1]))
                   for EIX:=2 to DIMC
                      outstd( FVWITH+stk_var_02[EBX][EHX][EIX])
                   end
                   outstd(_CR)
                end
             ELSE
                for EHX:=1 to DIMR
                   OX:=alltrim(stk_var_02[EBX][EHX][1])
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EIX:=2 to DIMC
                      OX:=FVWITH+stk_var_02[EBX][EHX][EIX]
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end
             END
          end
       else
          IF SALIDA==1
             outstd("[]")
          ELSE
             fwrite (FHNDLOUT,"[]",2)
          END
       end
    elseif DIM==3  // es tridimensional
       if DIMR>0.and.DIMC>0.and.DIMP>0
          EVX:=valtype(stk_var_02[EBX][1][1][1])
          if EVX=="L"
             IF SALIDA==1
                for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   outstd(iif(stk_var_02[EBX][EHX][1][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                   for EIX:=2 to DIMC
                      outstd( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                   end
                   outstd(_CR)
                end; end
             ELSE
                for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   OX:=iif(stk_var_02[EBX][EHX][1][EJX],CONTEXT_TRUE,CONTEXT_FALSE)
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EIX:=2 to DIMC
                      OX:=FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE)
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end; end
             END
          elseif EVX=="N"
             IF SALIDA==1
                for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1][EJX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         outstd( D2E(DX,XUPRECISION) )
                      else
                         outstd( XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      outstd( TYPENUM[FX])
                   end
//                outstd(iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][1][EJX],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX][1][EJX]))))
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX][EJX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            outstd( FVWITH+D2E(DX,XUPRECISION) )
                         else
                            outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                         end
                      else
                         outstd( FVWITH+TYPENUM[FX])
                      end
//                      outstd( FVWITH+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX][EJX],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX][EIX][EJX]))))
                   end
                   outstd(_CR)
                end; end
             ELSE
                for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1][EJX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         OX:=D2E(DX,XUPRECISION) 
                      else
                         OX:=XFUNNUM2STRING(DX,XUPRECISION)
                      end
                   else
                      OX:=TYPENUM[FX]
                   end
                   fwrite (FHNDLOUT,OX,len(OX))
                   
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX][EJX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            OX:=FVWITH+D2E(DX,XUPRECISION)
                         else
                            OX:=FVWITH+XFUNNUM2STRING(DX,XUPRECISION)
                         end
                      else
                         OX:=FVWITH+TYPENUM[FX]
                      end
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end; end
             END
          else
             IF SALIDA==1
                for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   outstd(alltrim(stk_var_02[EBX][EHX][1][EJX]))
                   for EIX:=2 to DIMC
                      outstd( FVWITH+stk_var_02[EBX][EHX][EIX][EJX])
                   end
                   outstd(_CR)
                end; end
             ELSE
                for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   OX:=alltrim(stk_var_02[EBX][EHX][1][EJX])
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EIX:=2 to DIMC
                      OX:=FVWITH+stk_var_02[EBX][EHX][EIX][EJX]
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end; end
             END
          end
       else
          IF SALIDA==1
             outstd("[]")
          ELSE
             fwrite (FHNDLOUT,"[]",2)
          END
       end
    elseif DIM==4  // es cuatridimensional
       if DIMR>0.and.DIMC>0.and.DIMP>0.and.DIMB>0
          EVX:=valtype(stk_var_02[EBX][1][1][1][1])
          if EVX=="L"
             IF SALIDA==1
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   outstd(iif(stk_var_02[EBX][EHX][1][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                   for EIX:=2 to DIMC
                      outstd( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                   end
                   outstd(_CR)
                end; end; end
             ELSE
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   OX:=(iif(stk_var_02[EBX][EHX][1][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EIX:=2 to DIMC
                      OX:=( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end; end; end
             END
          elseif EVX=="N"
             IF SALIDA==1
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1][EJX][EKX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         outstd( D2E(DX,XUPRECISION) )
                      else
                         outstd( XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      outstd( TYPENUM[FX])
                   end
   //                outstd(iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][1][EJX][EKX],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX][1][EJX][EKX]))))
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX][EJX][EKX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            outstd( FVWITH+D2E(DX,XUPRECISION) )
                         else
                            outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                         end
                      else
                         outstd( FVWITH+TYPENUM[FX])
                      end
//                     outstd( FVWITH+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX][EJX][EKX],XUPRECISION),alltrim(str(stk_var_02[EBX][EHX][EIX][EJX][EKX]))))
                   end
                   outstd(_CR)
                end; end; end
             ELSE
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1][EJX][EKX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         OX:=( D2E(DX,XUPRECISION) )
                      else
                         OX:=( XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      OX:=( TYPENUM[FX])
                   end
                   fwrite (FHNDLOUT,OX,len(OX))
                   
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX][EJX][EKX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            OX:=( FVWITH+D2E(DX,XUPRECISION) )
                         else
                            OX:=( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                         end
                      else
                         OX:=( FVWITH+TYPENUM[FX])
                      end
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end; end; end
             END
          else
             IF SALIDA==1
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   outstd(alltrim(stk_var_02[EBX][EHX][1][EJX][EKX]))
                   for EIX:=2 to DIMC
                      outstd( FVWITH+stk_var_02[EBX][EHX][EIX][EJX][EKX])
                   end
                   outstd(_CR)
                end; end; end
             ELSE
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
                   OX:=(alltrim(stk_var_02[EBX][EHX][1][EJX][EKX]))
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EIX:=2 to DIMC
                      OX:=( FVWITH+stk_var_02[EBX][EHX][EIX][EJX][EKX])
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                   fwrite (FHNDLOUT,_CR,len(_CR))
                end; end; end
             END
          end
       else
          IF SALIDA==1
             outstd("[]")
          ELSE
             fwrite (FHNDLOUT,"[]",2)
          END
       end
    end
  RETURN NIL

/******************************************************************
                    OPERADORES BASICOS ESCALARES
*******************************************************************/

  FUNCTION FUNCHARGET()  // 3
  LOCAL EAX,EBX
    EAX:=STACK[CS]    // STRING
    EBX:=STACK[CS-1]  // POSICION
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if valtype(stk_var_02[EBX])=="C"
       stk_var_02[++CWM]:=SUBSTR(stk_var_02[EBX],stk_var_02[EAX],1)
    end
    STACK[--CS] := CWM
  RETURN .T.

  FUNCTION FUNSUBSADDSTR()  //64
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if valtype(stk_var_02[EBX])=="C"
       stk_var_02[++CWM]:=SUBSTR(stk_var_02[EBX],stk_var_02[EAX]+1,LEN(stk_var_02[EBX]))
    else
       stk_var_02[++CWM]:=SUBSTR(stk_var_02[EAX],stk_var_02[EBX]+1,LEN(stk_var_02[EAX]))
    end
    STACK[--CS] := CWM  
  RETURN .T.

  FUNCTION FUNSUBSSUBSTR()  //65
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if valtype(stk_var_02[EBX])=="C"
      // stk_var_02[++CWM]:=LEFT(stk_var_02[EBX],stk_var_02[EAX])
       stk_var_02[++CWM]:=SUBSTR(stk_var_02[EBX],1,LEN(stk_var_02[EBX])-stk_var_02[EAX])
    else
      // stk_var_02[++CWM]:=LEFT(stk_var_02[EAX],stk_var_02[EBX])
       stk_var_02[++CWM]:=SUBSTR(stk_var_02[EAX],1,LEN(stk_var_02[EAX])-stk_var_02[EBX])
    end
    STACK[--CS] := CWM    
  RETURN .T.
  
  FUNCTION FUNADDSTR()  // 253
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    stk_var_02[++CWM]:=stk_var_02[EBX]+stk_var_02[EAX]
    STACK[--CS] := CWM
  RETURN .T.

  FUNCTION FUNADD()  // 43
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    stk_var_02[++CWM]:=stk_var_02[EBX]+stk_var_02[EAX]
    STACK[--CS] := CWM
  RETURN .T.

  FUNCTION FUNSUB()   // 252
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    stk_var_02[++CWM]:=stk_var_02[EBX]-stk_var_02[EAX]
    STACK[--CS] := CWM
  RETURN .T.

  FUNCTION FUNMUL()     // 251
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    stk_var_02[++CWM]:=stk_var_02[EAX]*stk_var_02[EBX]
    STACK[--CS] := CWM
  RETURN .T.

  FUNCTION FUNDIV()      //250
  LOCAL OP_CODE:=2500
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if stk_var_02[EAX]!=0
       stk_var_02[++CWM]:=stk_var_02[EBX]/stk_var_02[EAX]
       STACK[--CS] := CWM
    else
       RETURN _FUNPUTERROR("DIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
    end
  RETURN .T.

  FUNCTION FUNMOD()     // 247
  LOCAL EAX,EBX,OP_CODE:=2470
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if stk_var_02[EAX]!=0
       stk_var_02[++CWM]:=stk_var_02[EBX] % stk_var_02[EAX]   
       STACK[--CS] := CWM
    else
       RETURN _FUNPUTERROR("MOD (%)/NUM % ZERO",OP_CODE,CP)
    end
  RETURN .T.

  FUNCTION FUNPOW()   // 248
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    IF stk_var_02[EBX]>=0 
       stk_var_02[++CWM]:=stk_var_02[EBX]^stk_var_02[EAX]
    ELSEIF stk_var_02[EAX]>=1
       stk_var_02[++CWM]:=stk_var_02[EBX]^stk_var_02[EAX]
    ELSE
       RETURN _FUNPUTERROR("POW/BASE NEGATIVE & EXP DECIMAL, WEON-ERROR",OP_CODE,CP)
    END
    STACK[--CS] := CWM
  RETURN .T.
      
  FUNCTION FUNIDIV()   // 249
  LOCAL OP_CODE:=2490
  LOCAL EAX,EBX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if stk_var_02[EAX]!=0
       stk_var_02[++CWM]:=int(stk_var_02[EBX]/stk_var_02[EAX])
       STACK[--CS] := CWM
    else
       RETURN _FUNPUTERROR("IDIV/DIVISION BY CERO, WEON-ERROR",OP_CODE,CP)
    end
  RETURN .T.

  FUNCTION FUNGETENV()   // 126
  LOCAL EAX
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    stk_var_02[CWM]:=GETENV(stk_var_02[EAX])
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNISNAN()   // 134
  LOCAL EAX,EVX,EDX,OP_CODE:=1340
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    EVX:=VALTYPE(stk_var_02[EAX])
    if EVX=="N"
       stk_var_02[CWM]:=XU_TYPENUM(stk_var_02[EAX])==1
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("ISNAN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       stk_var_02[CWM]:=XMATHNANINF(stk_var_02[EAX],1,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
    end
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNISINF()   // 139
  LOCAL EAX,EVX,EDX,OP_CODE:=1390
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    EVX:=VALTYPE(stk_var_02[EAX])
    if EVX=="N"
       stk_var_02[CWM]:=XU_TYPENUM(stk_var_02[EAX])==2
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("ISNAN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       stk_var_02[CWM]:=XMATHNANINF(stk_var_02[EAX],2,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
    end
    STACK[CS] := CWM
  RETURN .T.
    
  FUNCTION FUNGCD()   // 209
  LOCAL EAX,EBX,AX,BX,EVX,EWX,EDX,EEX,OP_CODE:=2090
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2,TEMPORAL
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM;--CS
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    EVX:=VALTYPE(AX)
    EWX:=VALTYPE(BX)
    IF EVX+EWX=="NN"
       stk_var_02[CWM]:=XGCD(AX,BX)
       STACK[CS]:=CWM
       RETURN .T.
    ELSE
       EEX:=EVX+EWX
       IF EVX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("MTH.GCD/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       END
       IF EWX=="A"          
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("MTH.GCD/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
          IF DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
             RETURN _FUNPUTERROR("MTH.GCD/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
           TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           IF DIM1==1
              FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX] := XGCD(AX[EHX],BX[EHX])
              END
           ELSEif DIM1==2
              IF DIM1R<=DIM1C
                 FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX] := XGCD(AX[EHX][EIX],BX[EHX][EIX])
                 END; END
              ELSE
                 FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX] := XGCD(AX[EHX][EIX],BX[EHX][EIX])
                 END; END
              END
           ELSEif DIM1==3
              IF DIM1R<=DIM1C
                 FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX][EJX] := XGCD(AX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
                 END; END; END
              ELSE
                 FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX][EJX] := XGCD(AX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
                 END; END; END
              END
           ELSE
              IF DIM1R<=DIM1C
                 FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX][EJX][EKX] := XGCD(AX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
                 END; END; END; END
              ELSE
                 FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX][EJX][EKX] := XGCD(AX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
                 END; END; END; END
              END
           END
           ////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
           STACK[CS]:=CWM
           FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
       ELSEIF EEX=="AN"
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           IF DIM1==1
              FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX] := XGCD(AX[EHX],BX)
              END
           ELSEif DIM1==2
              IF DIM1R<=DIM1C
                 FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX] := XGCD(AX[EHX][EIX],BX)
                 END; END
              ELSE
                 FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX] := XGCD(AX[EHX][EIX],BX)
                 END; END
              END
           ELSEif DIM1==3
              IF DIM1R<=DIM1C
                 FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX][EJX] := XGCD(AX[EHX][EIX][EJX],BX)
                 END; END; END
              ELSE
                 FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX][EJX] := XGCD(AX[EHX][EIX][EJX],BX)
                 END; END; END
              END
           ELSE
              IF DIM1R<=DIM1C
                 FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX][EJX][EKX] := XGCD(AX[EHX][EIX][EJX][EKX],BX)
                 END; END; END; END
              ELSE
                 FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX][EJX][EKX] := XGCD(AX[EHX][EIX][EJX][EKX],BX)
                 END; END; END; END
              END
           END
           ////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
           STACK[CS]:=CWM
           FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
       ELSE  // DEBE SER EEX="NA"
          TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
           IF DIM2==1
              FOR EHX:=1 TO DIM2R
                 TEMPORAL[EHX] := XGCD(AX,BX[EHX])
              END
           ELSEif DIM2==2 
              IF DIM2R<=DIM2C
                 FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                    TEMPORAL[EHX][EIX] := XGCD(AX,BX[EHX][EIX])
                 END; END
              ELSE
                 FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                    TEMPORAL[EHX][EIX] := XGCD(AX,BX[EHX][EIX])
                 END; END
              END
           ELSEif DIM2==3
              IF DIM2R<=DIM2C
                 FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                    TEMPORAL[EHX][EIX][EJX] := XGCD(AX,BX[EHX][EIX][EJX])
                 END; END; END
              ELSE
                 FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                    TEMPORAL[EHX][EIX][EJX] := XGCD(AX,BX[EHX][EIX][EJX])
                 END; END; END
              END
           ELSE
              IF DIM2R<=DIM2C
                 FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                    TEMPORAL[EHX][EIX][EJX][EKX] := XGCD(AX,BX[EHX][EIX][EJX][EKX])
                 END; END; END; END
              ELSE
                 FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                    TEMPORAL[EHX][EIX][EJX][EKX] := XGCD(AX,BX[EHX][EIX][EJX][EKX])
                 END; END; END; END
              END
           END
           ////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
           STACK[CS]:=CWM
           FUNPUTDIMS(CWM,DIM2,"N",DIM2R,DIM2C,DIM2P,DIM2B)
       END
    END
    
    RELEASE TEMPORAL
  RETURN .T.

  FUNCTION FUNLCM()   // 210
  LOCAL EAX,EBX,AX,BX,EVX,EWX,EDX,EEX,OP_CODE:=2100
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2,TEMPORAL
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM;--CS
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    EVX:=VALTYPE(AX)
    EWX:=VALTYPE(BX)
    IF EVX+EWX=="NN"
       stk_var_02[CWM]:=XLCM(AX,BX)
       STACK[CS]:=CWM
       RETURN .T.
    ELSE
       EEX:=EVX+EWX
       IF EVX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("MTH.LCM/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       END
       IF EWX=="A"          
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("MTH.LCM/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
          IF DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
             RETURN _FUNPUTERROR("MTH.LCM/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
           TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           IF DIM1==1
              FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX] := XLCM(AX[EHX],BX[EHX])
              END
           ELSEif DIM1==2
              IF DIM1R<=DIM1C
                 FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                    TEMPORAL[EHX][EIX] := XLCM(AX[EHX][EIX],BX[EHX][EIX])
                 END; END
              ELSE
                 FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                    TEMPORAL[EHX][EIX] := XLCM(AX[EHX][EIX],BX[EHX][EIX])
                 END; END
              END
           ELSEif DIM1==3 
              IF DIM1R<=DIM1C
              FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                 TEMPORAL[EHX][EIX][EJX] := XLCM(AX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX][EIX][EJX] := XLCM(AX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
              END; END; END
              END
           ELSE
              IF DIM1R<=DIM1C
              FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                 TEMPORAL[EHX][EIX][EJX][EKX] := XLCM(AX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX][EIX][EJX][EKX] := XLCM(AX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
           END
           /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
           STACK[CS]:=CWM
           FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
       ELSEIF EEX=="AN"
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           IF DIM1==1
              FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX] := XLCM(AX[EHX],BX)
              END
           ELSEif DIM1==2 
              IF DIM1R<=DIM1C
              FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                 TEMPORAL[EHX][EIX] := XLCM(AX[EHX][EIX],BX)
              END; END
              ELSE
              FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX][EIX] := XLCM(AX[EHX][EIX],BX)
              END; END
              END
           ELSEif DIM1==3 
              IF DIM1R<=DIM1C
              FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                 TEMPORAL[EHX][EIX][EJX] := XLCM(AX[EHX][EIX][EJX],BX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX][EIX][EJX] := XLCM(AX[EHX][EIX][EJX],BX)
              END; END; END
              END
           ELSE
              IF DIM1R<=DIM1C
              FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                 TEMPORAL[EHX][EIX][EJX][EKX] := XLCM(AX[EHX][EIX][EJX][EKX],BX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                 TEMPORAL[EHX][EIX][EJX][EKX] := XLCM(AX[EHX][EIX][EJX][EKX],BX)
              END; END; END; END
              END
           END
           //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
           STACK[CS]:=CWM
           FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
       ELSE  // DEBE SER EEX="NA"
          TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
           IF DIM2==1
              FOR EHX:=1 TO DIM2R
                 TEMPORAL[EHX] := XLCM(AX,BX[EHX])
              END
           ELSEif DIM2==2 
              IF DIM2R<=DIM2C
              FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                 TEMPORAL[EHX][EIX] := XLCM(AX,BX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                 TEMPORAL[EHX][EIX] := XLCM(AX,BX[EHX][EIX])
              END; END
              END
           ELSEif DIM2==3 
              IF DIM2R<=DIM2C
              FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                 TEMPORAL[EHX][EIX][EJX] := XLCM(AX,BX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                 TEMPORAL[EHX][EIX][EJX] := XLCM(AX,BX[EHX][EIX][EJX])
              END; END; END
              END
           ELSE
              IF DIM2R<=DIM2C
              FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                 TEMPORAL[EHX][EIX][EJX][EKX] := XLCM(AX,BX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                 TEMPORAL[EHX][EIX][EJX][EKX] := XLCM(AX,BX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
           END
           //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
           STACK[CS]:=CWM
           FUNPUTDIMS(CWM,DIM2,"N",DIM2R,DIM2C,DIM2P,DIM2B)
       END
    END
    
    RELEASE TEMPORAL
  RETURN .T.

/******************************************************************
                     MULTIPLICACION MATRICIAL XMAT
*******************************************************************/

FUNCTION FUNMATMULT()   // 145
LOCAL EAX,EBX,AX,BX,EVX,EWX,EDX,EEX,OP_CODE:=1450
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2,TEMPORAL
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM;--CS
  AX:=stk_var_02[EAX]
  BX:=stk_var_02[EBX]

  IF !FUNGETDIMS(EBX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
     RETURN _FUNPUTERROR("XMAT/MATRIX NOT INITIALIZED",OP_CODE,CP)
  END
  IF !FUNGETDIMS(EAX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
     RETURN _FUNPUTERROR("XMAT/MATRIX NOT INITIALIZED",OP_CODE+1,CP)
  END

  if DIM1==2 .AND. DIM2==2  // son matrices de 2 dimensiones: ver si se trata de una multiplicacion matricial
     if DIM1C==DIM2R
        ////TEMPORAL:=ARRAY(DIM1R,DIM2C)
        TEMPORAL:=XMMATMULT(stk_var_02[EBX],stk_var_02[EAX],DIM1R,DIM1C,DIM2C)
     else
        RETURN _FUNPUTERROR("XMAT/DIMENSION GARRAFAL ERROR",OP_CODE+2,CP)
     end
  else
     RETURN _FUNPUTERROR("XMAT/DIMENSION GARRAFAL ERROR",OP_CODE+3,CP)
  end
  /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM2C)
  stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,2,DIM1R,DIM2C,0,0,0)
  FUNPUTDIMS(CWM,2,"N",DIM1R,DIM2C,0,0)
  STACK[CS] := CWM
  RELEASE TEMPORAL
RETURN .T.

/******************************************************************
                    OPERADORES INCREMENTO Y DECREMENTO
*******************************************************************/
  FUNCTION INCVOID()   // 98
  LOCAL EAX,EDX,AX,OP_CODE:=980
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
     EAX:=STACK[CS]
     --CS
    
     IF VALTYPE(stk_var_02[EAX])=="N"
        ++stk_var_02[EAX]
     ELSE
        IF !FUNGETDIMS(EAX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.F.)
           RETURN _FUNPUTERROR("OPE INC (++)/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
        ELSE
           
           TEMPORAL:=XMATHBASIC(stk_var_02[EAX],1,XDIM,DIMR,DIMC,DIMP,DIMB)
           stk_var_02[EAX]:=TEMPORAL
           
        END
     END
  RETURN .T.

  FUNCTION DECVOID()   // 99
  LOCAL EAX,EDX,AX,OP_CODE:=990
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
     EAX:=STACK[CS]
     --CS

     IF VALTYPE(stk_var_02[EAX])=="N"
        --stk_var_02[EAX]
     ELSE
        IF !FUNGETDIMS(EAX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.F.)
           RETURN _FUNPUTERROR("OPE DEC (--)/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
        ELSE
           TEMPORAL:=XMATHBASIC(stk_var_02[EAX],2,XDIM,DIMR,DIMC,DIMP,DIMB)
           stk_var_02[EAX]:=TEMPORAL
        END
     END
  RETURN .T.

  FUNCTION INC()   // 96
  LOCAL EAX,EDX,AX,OP_CODE:=960
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
     EAX:=STACK[CS]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     ++CWM
     AX:=stk_var_02[EAX]
     IF VALTYPE(AX)=="N"
        stk_var_02[EAX]++
        stk_var_02[CWM]:=stk_var_02[EAX]
     ELSE
        IF !FUNGETDIMS(EAX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
           RETURN _FUNPUTERROR("FUN INC (++)/MATRIX NOT INITIALIZED",OP_CODE,CP)
        ELSE
           /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           /*TEMPORAL:=XMATHBASIC(AX,4,XDIM,DIMR,DIMC,DIMP,DIMB)*/
           TEMPORAL:=XMATHBASIC(AX,1,XDIM,DIMR,DIMC,DIMP,DIMB)
           /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           stk_var_02[EAX]:=TEMPORAL
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
           RELEASE TEMPORAL
        END
        FUNPUTDIMS(CWM,XDIM,"N",DIMR,DIMC,DIMP,DIMB)
     END
     STACK[CS] := CWM
  RETURN .T.

  FUNCTION DEC()   // 97
  LOCAL EAX,EDX,AX,OP_CODE:=970
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
     EAX:=STACK[CS]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     ++CWM
     AX:=stk_var_02[EAX]
     IF VALTYPE(AX)=="N"
        stk_var_02[EAX]--
        stk_var_02[CWM]:=stk_var_02[EAX]
     ELSE
        IF !FUNGETDIMS(EAX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
           RETURN _FUNPUTERROR("FUN DEC (--)/MATRIX NOT INITIALIZED",OP_CODE,CP)
        ELSE
          //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           /*TEMPORAL:=XMATHBASIC(AX,5,XDIM,DIMR,DIMC,DIMP,DIMB)*/
           TEMPORAL:=XMATHBASIC(AX,2,XDIM,DIMR,DIMC,DIMP,DIMB)
           /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           stk_var_02[EAX]:=TEMPORAL
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
           RELEASE TEMPORAL
        END
        FUNPUTDIMS(CWM,XDIM,"N",DIMR,DIMC,DIMP,DIMB)
     END
     STACK[CS] := CWM
  RETURN .T.


  FUNCTION FUNNOT()   // 195
  LOCAL EAX,EDX,AX,OP_CODE:=1950
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
     EAX:=STACK[CS]
     --CS
    /// AX:=stk_var_02[EAX]
     IF VALTYPE(stk_var_02[EAX])=="L"
        stk_var_02[EAX]:=!stk_var_02[EAX]
     ELSE
        IF !FUNGETDIMS(EAX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.F.)
           RETURN _FUNPUTERROR("NEGATION (NOT)/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
        ELSE
           ////TEMPORAL:={}
           stk_var_02[EAX]:=XMATHBASIC(stk_var_02[EAX],3,XDIM,DIMR,DIMC,DIMP,DIMB)
        END
     END
  RETURN .T.

/******************************************************************
                    OPERADORES LOGICOS
*******************************************************************/
  FUNCTION IS_EQ()   // 246
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     stk_var_02[++CWM]:=(stk_var_02[EBX] == stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION IS_LT()   // 245
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     stk_var_02[++CWM]:=(stk_var_02[EBX] < stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION IS_GT()   // 244
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     stk_var_02[++CWM]:=(stk_var_02[EBX] > stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION IS_LE()   // 243
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     stk_var_02[++CWM]:=(stk_var_02[EBX] <= stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION IS_GE()   // 242
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     stk_var_02[++CWM]:=(stk_var_02[EBX] >= stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION IS_NOT_EQUAL()   // 241
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     stk_var_02[++CWM]:=(stk_var_02[EBX] != stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION SUBSETSTR()   // 240
  LOCAL EBX,EAX
     EAX:=STACK[CS]
     EBX:=STACK[CS-1]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     
     stk_var_02[++CWM]:=(stk_var_02[EBX] $ stk_var_02[EAX])
     STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION NEGATION()   // 19
  LOCAL EAX,EDX,AX,OP_CODE:=190
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
     EAX:=STACK[CS]
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     ++CWM
     AX:=stk_var_02[EAX]
     IF VALTYPE(AX)=="L"
        stk_var_02[CWM]:=!AX
     ELSE
        IF !FUNGETDIMS(EAX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
           RETURN _FUNPUTERROR("NEGATION (¬)/MATRIX NOT INITIALIZED",OP_CODE,CP)
        ELSE
           ////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           /*TEMPORAL:=XMATHBASIC(AX,6,XDIM,DIMR,DIMC,DIMP,DIMB)*/
           TEMPORAL:=XMATHBASIC(AX,3,XDIM,DIMR,DIMC,DIMP,DIMB)
           //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
           stk_var_02[EAX]:=TEMPORAL
           stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
           RELEASE TEMPORAL
        END
        FUNPUTDIMS(CWM,XDIM,"L",DIMR,DIMC,DIMP,DIMB)
     END
     STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBETWEEN()  // 30
  LOCAL AX,EBX,BX,ECX,CX,EAX
     EAX:=STACK[CS]
     AX:=stk_var_02[EAX]          // rango superior
     EBX:=STACK[CS-1]
     BX:=stk_var_02[EBX]        // rango inferior
     ECX:=STACK[CS-2]
     CX:=stk_var_02[ECX]        // variable    
     CWM:=CMPCWM(EAX,CWM,TopCWM)
     CWM:=CMPCWM(EBX,CWM,TopCWM)
     CWM:=CMPCWM(ECX,CWM,TopCWM)
     
     CS -= 2
     stk_var_02[++CWM]:=CX>=BX .and. CX<=AX
     STACK[CS] := CWM
  RETURN .T.


/******************************************************************
                       OPERADORES DE STRING 
*******************************************************************/

  FUNCTION FUNSUBSTR()  // 92
  LOCAL EBX,BX,ECX,CX,AX,DX,EAX,ELX,EPX:="",OP_CODE:=920
  LOCAL EHX,EIX,EJX,EKX,EEX,EQX,ERX,ESX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]        // numero de caracteres a cortar
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // desde pos CX
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]        // string
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=2;++CWM
    IF VALTYPE(CX)=="C"  // evaluar si tiene un escalar string y argumentos matriciales
       EQX:=valtype(BX)
       ERX:=valtype(AX)
       ESX:=EQX+ERX
       /* ANALISIS DE FLAG */
       FVWITH := FLAG[1]   // valor
       FTWITH := UPPER(FLAG[2])   // tipo
       if FTWITH!="C"
          FVWITH:=""   // nada!
       end
       FVWITH:=UPPER(FVWITH)
       /*  */
       if ESX=="NN"
          stk_var_02[CWM] := SUBSTR(CX,BX,AX)
       elseif ESX=="NA"   // solo se admite un vector. Matriz es innecesario
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          IF DIM1==1
             TEMPORAL:=ARRAY(DIM1R)
             FOR EHX:=1 TO DIM1R
                TEMPORAL[EHX] := SUBSTR(CX,BX,AX[EHX])
             END
          ELSE
             RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,1,DIM1R,0,0,0,0)
          FUNPUTDIMS(CWM,1,"C",DIM1R,0,0,0)
       elseif ESX=="AN"
          IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          IF DIM1==1
             TEMPORAL:=ARRAY(DIM1R)
             FOR EHX:=1 TO DIM1R
                TEMPORAL[EHX] := SUBSTR(CX,BX[EHX],AX)
             END
          ELSE
             RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,1,DIM1R,0,0,0,0)
          FUNPUTDIMS(CWM,1,"C",DIM1R,0,0,0)
       else   // ambos son matrices
          IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          IF !FUNGETDIMS(EAX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          
          IF DIM1==1.and.DIM2==1
             IF DIM1R==DIM2R
                TEMPORAL:=ARRAY(DIM1R)
                FOR EHX:=1 TO DIM1R
                   TEMPORAL[EHX] := SUBSTR(CX,BX[EHX],AX[EHX])
                END
             ELSE
                RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
          /////stk_var_02[CWM]:=ARRAY(DIM1R)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,1,DIM1R,0,0,0,0)
          FUNPUTDIMS(CWM,1,"C",DIM1R,0,0,0)
       end
    ELSE  // argumento principal es matriz
       if VALTYPE(AX)=="A"
          EPX:="A"
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          EPX:="E"
          TYP1:=valtype(AX)
       end
       if VALTYPE(BX)=="A"
          EPX:=EPX+"A"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       else
          EPX:=EPX+"E" 
          TYP2:=valtype(BX)
       end
       IF !FUNGETDIMS(ECX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRCPY/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       IF EPX=="AA"
          IF XDIM!=DIM1.OR.XDIM!=DIM2
             RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
       ELSEIF EPX=="EA"
          IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
             RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
       ELSEIF EPX=="AE"
          IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
             RETURN _FUNPUTERROR("STRCPY/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END  
       END
       /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       SWITCH EPX
        CASE "AA"
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,3)
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCPY/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
           END
           EXIT
        CASE "EA"
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,2)
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCPY/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
           END
           EXIT
        CASE "AE"
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,4)
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCPY/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
           END
           EXIT
        CASE "EE"    // escalares
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,1)
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCPY/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
           END
           EXIT
       END
       //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:= TEMPORAL  ////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
       RELEASE TEMPORAL
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSSTRCUT()   // 111
  LOCAL EBX,BX,ECX,CX,AX,EAX,ELX,EPX:="",OP_CODE:=1110
  LOCAL EHX,EIX,EJX,EKX,EEX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]        // numero de caracteres a cortar
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // desde pos CX
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]        // string
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=2;++CWM
    IF VALTYPE(CX)=="C"
       ELX:=LEN(CX)
       IF ELX==0
          stk_var_02[CWM] := ""
       ELSEIF ELX<BX
             stk_var_02[CWM] := CX
       ELSE
          stk_var_02[CWM] := SUBSTR(CX,BX,AX)
          stk_var_02[ECX] := STRCUT(CX,BX,AX,ELX)
       END
    ELSE
       if VALTYPE(AX)=="A"
          EPX:="A"
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCUT/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          EPX:="E"
          TYP1:=valtype(AX)
       end
       if VALTYPE(BX)=="A"
          EPX:=EPX+"A"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCUT/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       else
          EPX:=EPX+"E" 
          TYP2:=valtype(BX)
       end
       IF !FUNGETDIMS(ECX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRCUT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       IF EPX=="AA"
          IF XDIM!=DIM1.OR.XDIM!=DIM2
             RETURN _FUNPUTERROR("STRCUT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       ELSEIF EPX=="EA"
          IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
             RETURN _FUNPUTERROR("STRCUT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       ELSEIF EPX=="AE"
          IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
             RETURN _FUNPUTERROR("STRCUT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END  
       END
       /////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       SWITCH EPX
        CASE "AA"
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,3)
           stk_var_02[ECX]:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,13)
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCUT/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "EA"
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,2)
           stk_var_02[ECX]:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,12)
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCUT/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "AE"
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,4)   // obtengo porcion
           stk_var_02[ECX]:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,14)  // la quito
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCUT/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "EE"   // escalares
           TEMPORAL:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,1)   //obtengo porcion
           stk_var_02[ECX]:=XSUBSTR(CX,BX,AX,XDIM,DIMR,DIMC,DIMP,DIMB,11)  // la quito
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCUT/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
       END
       /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:= TEMPORAL    /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
       RELEASE TEMPORAL
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRDIFF()   // 20
  /*
     AN<-STRDIFF(STRING, GRANSTRING,N)
     BUSCAR STRING DENTRO DE GRANSTRING, Y AVANZA N ESPACIOS PARA SEGUIR COMPARANDO.
     DEVUELVE UN ARRAY CON LOS RESULTADOS DE LAS COMPARACIONES
  */
  LOCAL BX,CX,DX,EBX,ECX,EDX,ELX,TEMPORAL
    EBX:=STACK[CS]
    BX:=stk_var_02[EBX]        // desplazamiento
    ECX:=STACK[CS-1]
    CX:=stk_var_02[ECX]        // string gigante
    EDX:=STACK[CS-2]
    DX:=stk_var_02[EDX]        // cadena a comparar
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS -= 2; ++CWM
    ////TEMPORAL:=ARRAY(0)
    TEMPORAL:=XU_STRDIFF(DX,CX,BX)
    ELX:=LEN(TEMPORAL)
    /////stk_var_02[CWM]:=ARRAY(ELX)
    stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,1,ELX,0,0,0,0)
    FUNPUTDIMS(CWM,1,"N",ELX,0,0,0)
    RELEASE TEMPORAL
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNSTRFIND()  // 94
  LOCAL EBX,BX,ECX,CX,EDX,DX,AX,EX,EAX,EFX,EWX,EVX,OP_CODE:=940
  LOCAL EHX,EIX,EJX,EKX,EEX,EYX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM3,DIM3R,DIM3C,DIM3P,DIM3B,TYP3,TEMPORAL
//    EAX:=STACK[CS]
//    AX:=stk_var_02[EAX]
    EBX:=STACK[CS]
    BX:=stk_var_02[EBX]        // ocurrencia a considerar
    ECX:=STACK[CS-1]
    CX:=stk_var_02[ECX]        // cadena a buscar
    EDX:=STACK[CS-2]
    DX:=stk_var_02[EDX]        // cadena principal
//    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS -= 2; ++CWM
    EYX:=valtype(BX)
    EWX:=valtype(CX)
    EVX:=valtype(DX)  
    EXX:=EVX+EWX      // cadena principal + cadena a buscar

    IF EXX=="CC"
       stk_var_02[CWM]:=ATNUM(CX,DX,BX)
    ELSEIF EXX=="CA"
       IF !FUNGETDIMS(ECX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("STRFIND/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       if DIM1==1
          TEMPORAL:=ARRAY(DIM1R)
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX]:=ATNUM(CX[EHX],DX,BX)
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
       else
          RETURN _FUNPUTERROR("STRFIND/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
       end   
    ELSE
       // obtiene EAX array CADENA A BUSCAR
       
       if EWX=="A"
          IF !FUNGETDIMS(ECX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRFIND/SEARCH MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  STRING PRINCIPAL
          IF !FUNGETDIMS(EDX,@EFX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRFIND/MAIN MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("STRFIND/DIMENSION FENOMENAL CTHULU ERROR",OP_CODE+1,CP)
             end
          end
       end
       // Analizar ocurrencias: si es array, debe tener el mismo size de matriz 
       if EYX=="A"
          IF !FUNGETDIMS(EBX,@EFX,@DIM3,@TYP3,@DIM3R,@DIM3C,@DIM3P,@DIM3B,.T.)
             RETURN _FUNPUTERROR("STRFIND/OCCURS MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          if DIM2!=DIM3 .or. DIM2R!=DIM3R .or. DIM2C!=DIM3C .or. DIM2P!=DIM3P .or. DIM2B!=DIM3B
             RETURN _FUNPUTERROR("STRFIND/DIMENSION FENOMENAL ERROR",OP_CODE+1,CP)
          end
          TEMPORAL:=ARRAY(DIM3R,DIM3C,DIM3P,DIM3B)
          IF EXX=="AA"   // AMBOS SON MATRICES
             SWITCH DIM3
             CASE 1
                FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX]:=ATNUM(CX[EHX],DX[EHX],BX[EHX])
                END
                EXIT
             CASE 2
                IF DIM3R<=DIM3C
                FOR EHX:=1 TO DIM3R; FOR EIX:=1 TO DIM3C
                   TEMPORAL[EHX][EIX]:=ATNUM(CX[EHX][EIX],DX[EHX][EIX],BX[EHX][EIX])
                END; END
                ELSE
                FOR EIX:=1 TO DIM3C; FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX][EIX]:=ATNUM(CX[EHX][EIX],DX[EHX][EIX],BX[EHX][EIX])
                END; END
                END
                EXIT
             CASE 3
                IF DIM3R<=DIM3C
                FOR EJX:=1 TO DIM3P; FOR EHX:=1 TO DIM3R; FOR EIX:=1 TO DIM3C
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX[EHX][EIX][EJX],DX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
                END; END; END
                ELSE
                FOR EJX:=1 TO DIM3P; FOR EIX:=1 TO DIM3C; FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX[EHX][EIX][EJX],DX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
                END; END; END
                END
                EXIT
             CASE 4
                IF DIM3R<=DIM3C
                FOR EKX:=1 TO DIM3B; FOR EJX:=1 TO DIM3P; FOR EHX:=1 TO DIM3R; FOR EIX:=1 TO DIM3C
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX[EHX][EIX][EJX][EKX],DX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIM3B; FOR EJX:=1 TO DIM3P; FOR EIX:=1 TO DIM3C; FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX[EHX][EIX][EJX][EKX],DX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
                END; END; END; END
                END
                EXIT
             END
          ELSEIF EXX=="AC"
             SWITCH DIM3
             CASE 1
                FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX]:=ATNUM(CX,DX[EHX],BX[EHX])
                END
                EXIT
             CASE 2
                IF DIM2R<=DIM2C
                FOR EHX:=1 TO DIM3R; FOR EIX:=1 TO DIM3C
                   TEMPORAL[EHX][EIX]:=ATNUM(CX,DX[EHX][EIX],BX[EHX][EIX])
                END; END
                ELSE
                FOR EIX:=1 TO DIM3C; FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX][EIX]:=ATNUM(CX,DX[EHX][EIX],BX[EHX][EIX])
                END; END
                END
                EXIT
             CASE 3
                IF DIM2R<=DIM2C
                FOR EJX:=1 TO DIM3P; FOR EHX:=1 TO DIM3R; FOR EIX:=1 TO DIM3C
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX,DX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
                END; END; END
                ELSE
                FOR EJX:=1 TO DIM3P; FOR EIX:=1 TO DIM3C; FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX,DX[EHX][EIX][EJX],BX[EHX][EIX][EJX])
                END; END; END
                END
                EXIT
             CASE 4
                IF DIM2R<=DIM2C
                FOR EKX:=1 TO DIM3B; FOR EJX:=1 TO DIM3P; FOR EHX:=1 TO DIM3R; FOR EIX:=1 TO DIM3C
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX,DX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIM3B; FOR EJX:=1 TO DIM3P; FOR EIX:=1 TO DIM3C; FOR EHX:=1 TO DIM3R
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX,DX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX])
                END; END; END; END
                END
                EXIT
             END
          END
          /////stk_var_02[CWM]:=ARRAY(DIM3R,DIM3C,DIM3P,DIM3B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM3,DIM3R,DIM3C,DIM3P,DIM3B,0)
          FUNPUTDIMS(CWM,DIM3,"N",DIM3R,DIM3C,DIM3P,DIM3B)
       else
          TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
          IF EXX=="AA"   // AMBOS SON MATRICES
             SWITCH DIM2
             CASE 1
                FOR EHX:=1 TO DIM2R
                  
                   TEMPORAL[EHX]:=ATNUM(CX[EHX],DX[EHX],BX)
                END
                EXIT
             CASE 2
                IF DIM2R<=DIM2C
                FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][EIX]:=ATNUM(CX[EHX][EIX],DX[EHX][EIX],BX)
                END; END
                ELSE
                FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX][EIX]:=ATNUM(CX[EHX][EIX],DX[EHX][EIX],BX)
                END; END
                END
                EXIT
             CASE 3
                IF DIM2R<=DIM2C
                FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX[EHX][EIX][EJX],DX[EHX][EIX][EJX],BX)
                END; END; END
                ELSE
                FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX[EHX][EIX][EJX],DX[EHX][EIX][EJX],BX)
                END; END; END
                END
                EXIT
             CASE 4
                IF DIM2R<=DIM2C
                FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX[EHX][EIX][EJX][EKX],DX[EHX][EIX][EJX][EKX],BX)
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX[EHX][EIX][EJX][EKX],DX[EHX][EIX][EJX][EKX],BX)
                END; END; END; END
                END
                EXIT
             END
          ELSEIF EXX=="AC"
             SWITCH DIM2
             CASE 1
                FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX]:=ATNUM(CX,DX[EHX],BX)
                END
                EXIT
             CASE 2
                IF DIM2R<=DIM2C
                FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][EIX]:=ATNUM(CX,DX[EHX][EIX],BX)
                END; END
                ELSE
                FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX][EIX]:=ATNUM(CX,DX[EHX][EIX],BX)
                END; END
                END
                EXIT
             CASE 3
                IF DIM2R<=DIM2C
                FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX,DX[EHX][EIX][EJX],BX)
                END; END; END
                ELSE
                FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX][EIX][EJX]:=ATNUM(CX,DX[EHX][EIX][EJX],BX)
                END; END; END
                END
                EXIT
             CASE 4
                IF DIM2R<=DIM2C
                FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX,DX[EHX][EIX][EJX][EKX],BX)
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                   TEMPORAL[EHX][EIX][EJX][EKX]:=ATNUM(CX,DX[EHX][EIX][EJX][EKX],BX)
                END; END; END; END
                END
                EXIT
             END
          END
          /////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
          FUNPUTDIMS(CWM,DIM2,"N",DIM2R,DIM2C,DIM2P,DIM2B)
          RELEASE TEMPORAL
       end
    END
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION STRAT()   // 61
  LOCAL EBX,BX,AX,EAX,DX,EPX:="",OP_CODE:=610
  LOCAL EHX,EIX,EJX,EKX,EEX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]          // STRING
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // cadena a buscar
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS; ++CWM
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       RETURN _FUNPUTERROR("STRAT/FUCKING FLAG!",OP_CODE,CP)
    end
    FVWITH:=UPPER(FVWITH)
    IF VALTYPE(AX)=="C"
       if VALTYPE(BX)=="C"
          stk_var_02[CWM]:=IIF(FVWITH=="R",RAT(BX,AX),AT(BX,AX))
       else   // caso especial
          IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRAT/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          if DIM1==1
             TEMPORAL:=ARRAY(DIM1R)
             IF FVWITH=="R"
                FOR EHX:=1 TO DIM1R
                   TEMPORAL[EHX]:=RAT(BX[EHX],AX)
                END
             ELSE
                FOR EHX:=1 TO DIM1R
                   TEMPORAL[EHX]:=AT(BX[EHX],AX)
                END
             END
             //////stk_var_02[CWM]:=ARRAY(DIM1R)
             stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
             FUNPUTDIMS(CWM,DIM1,"N",DIM1R,0,0,0)
          else
             RETURN _FUNPUTERROR("STRAT/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          end
       end
    ELSE
       EPX:="A"
       IF !FUNGETDIMS(EAX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRAT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       if VALTYPE(BX)=="A"  // STRING A BUSCAR
          IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRAT/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          EPX:=EPX+"A"
       ELSE
          EPX:=EPX+"E"
       end          
       IF EPX=="AA"
          IF XDIM!=DIM1 .or. DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
             RETURN _FUNPUTERROR("STRAT/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
       END
       TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       if EPX=="AA"
          SWITCH XDIM
          CASE 1
             IF FVWITH=="R"
                FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX]:=RAT(BX[EHX],AX[EHX])
                END
             ELSE
                FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX]:=AT(BX[EHX],AX[EHX])
                END
             END
             EXIT
          CASE 2 
             IF FVWITH=="R"
                IF DIMR<=DIMC
                FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX]:=RAT(BX[EHX][EIX],AX[EHX][EIX])
                END; END
                ELSE
                FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX]:=RAT(BX[EHX][EIX],AX[EHX][EIX])
                END; END
                END
             ELSE
                IF DIMR<=DIMC
                FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX]:=AT(BX[EHX][EIX],AX[EHX][EIX])
                END; END
                ELSE
                FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX]:=AT(BX[EHX][EIX],AX[EHX][EIX])
                END; END
                END
             END
             EXIT
          CASE 3 
             IF FVWITH=="R"
                IF DIMR<=DIMC
                FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX]:=RAT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
                END; END; END
                ELSE
                FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX]:=RAT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
                END; END; END
                END
             ELSE
                IF DIMR<=DIMC
                FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX]:=AT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
                END; END; END
                ELSE
                FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX]:=AT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
                END; END; END
                END
             END
             EXIT
          CASE 4
             IF FVWITH=="R"
                IF DIMR<=DIMC
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX][EKX]:=RAT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX][EKX]:=RAT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                END
             ELSE
                IF DIMR<=DIMC
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX][EKX]:=AT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX][EKX]:=AT(BX[EHX][EIX][EJX],AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                END
             END
             EXIT
          END
       else
          SWITCH XDIM
          CASE 1
             IF FVWITH=="R"
                FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX]:=RAT(BX,AX[EHX])
                END
             ELSE
                FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX]:=AT(BX,AX[EHX])
                END
             END
             EXIT
          CASE 2 
             IF FVWITH=="R"
                IF DIMR<=DIMC
                FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX]:=RAT(BX,AX[EHX][EIX])
                END; END
                ELSE
                FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX]:=RAT(BX,AX[EHX][EIX])
                END; END
                END
             ELSE
                IF DIMR<=DIMC
                FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX]:=AT(BX,AX[EHX][EIX])
                END; END
                ELSE
                FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX]:=AT(BX,AX[EHX][EIX])
                END; END
                END
             END
             EXIT
          CASE 3 
             IF FVWITH=="R"
                IF DIMR<=DIMC
                FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX]:=RAT(BX,AX[EHX][EIX][EJX])
                END; END; END
                ELSE
                FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX]:=RAT(BX,AX[EHX][EIX][EJX])
                END; END; END
                END
             ELSE
                IF DIMR<=DIMC
                FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX]:=AT(BX,AX[EHX][EIX][EJX])
                END; END; END
                ELSE
                FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX]:=AT(BX,AX[EHX][EIX][EJX])
                END; END; END
                END
             END
             EXIT
          CASE 4
             IF FVWITH=="R"
                IF DIMR<=DIMC
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX][EKX]:=RAT(BX,AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX][EKX]:=RAT(BX,AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                END
             ELSE
                IF DIMR<=DIMC
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                   TEMPORAL[EHX][EIX][EJX][EKX]:=AT(BX,AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                ELSE
                FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                   TEMPORAL[EHX][EIX][EJX][EKX]:=AT(BX,AX[EHX][EIX][EJX][EKX])
                END; END; END; END
                END
             END
             EXIT
          END
       end
       /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"N",DIMR,DIMC,DIMP,DIMB)
    END
    RELEASE TEMPORAL
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION STRINS()  // 86 
  LOCAL EBX,BX,ECX,CX,AX,EAX,DX,EPX:="",OP_CODE:=860
  LOCAL EHX,EIX,EJX,EKX,EEX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]          // STRING A INSERTAR
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // POSICION STRING MAYOR
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]        // variable
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM
    CS -= 2
    IF VALTYPE(CX)=="C"
       stk_var_02[CWM]:=STUFF(CX, BX,0, AX)  
    ELSE
       if VALTYPE(AX)=="A"
          EPX:="A"
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRINS/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          EPX:="E"
          TYP1:=valtype(AX)
       end
       if VALTYPE(BX)=="A"
          EPX:=EPX+"A"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRINS/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       else
          EPX:=EPX+"E" 
          TYP2:=valtype(BX)
       end
       IF !FUNGETDIMS(ECX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRINS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       SWITCH EPX
       CASE "AA"
          IF XDIM!=DIM1.OR.XDIM!=DIM2
             RETURN _FUNPUTERROR("STRINS/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT
       CASE "EA"
          IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
             RETURN _FUNPUTERROR("STRINS/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT
       CASE "AE"
          IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
             RETURN _FUNPUTERROR("STRINS/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT  
       END
       TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       SWITCH EPX
        CASE "AA"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=STUFF(CX[EHX],BX[EHX],0,AX[EHX])
              END
              EXIT
           CASE 2
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX[EHX][EIX],0,AX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX[EHX][EIX],0,AX[EHX][EIX])
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],0,AX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],0,AX[EHX][EIX][EJX])
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX],0,;
                                                 AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX],0,;
                                                 AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "EA"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=STUFF(CX[EHX],BX[EHX],0,AX)
              END
              EXIT
           CASE 2
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX[EHX][EIX],0,AX)
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX[EHX][EIX],0,AX)
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],0,AX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],0,AX)
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX],0,AX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX],0,AX)
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "AE"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=STUFF(CX[EHX],BX,0,AX[EHX])
              END
              EXIT
           CASE 2
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX,0,AX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX,0,AX[EHX][EIX])
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX,0,AX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX,0,AX[EHX][EIX][EJX])
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX,0,AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX,0,AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "EE"   // escalares
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=STUFF(CX[EHX],BX,0,AX)
              END
              EXIT
           CASE 2
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX,0,AX)
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=STUFF(CX[EHX][EIX],BX,0,AX)
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX,0,AX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=STUFF(CX[EHX][EIX][EJX],BX,0,AX)
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX,0,AX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=STUFF(CX[EHX][EIX][EJX][EKX],BX,0,AX)
              END; END; END; END
              END
              EXIT
           END
           EXIT
        end
       //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
    END
    RELEASE TEMPORAL
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION STRCCAR()   // 135
  LOCAL EBX,BX,ECX,CX,AX,EAX,EPX:="",OP_CODE:=1350
  LOCAL EHX,EIX,EJX,EKX,EEX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]        // caracteres de reempalzo
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // caracteres a reempalzar
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]        // cadena principal
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS -= 2; ++CWM
    IF VALTYPE(CX)=="C"
       stk_var_02[CWM]:=CHARREPL(BX, CX, AX)
    ELSE
       if VALTYPE(AX)=="A"
          EPX:="A"
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCCAR/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          EPX:="E"
       end
       if VALTYPE(BX)=="A"
          EPX:=EPX+"A"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCCAR/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       else
          EPX:=EPX+"E" 
       end
       IF !FUNGETDIMS(ECX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRCCAR/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       SWITCH EPX
       CASE "AA"
          IF XDIM!=DIM1.OR.XDIM!=DIM2
             RETURN _FUNPUTERROR("STRCCAR/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT
       CASE "EA"
          IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
             RETURN _FUNPUTERROR("STRCCAR/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT
       CASE "AE"
          IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
             RETURN _FUNPUTERROR("STRCCAR/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT  
       END
       TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       SWITCH EPX
        CASE "AA"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=CHARREPL(BX[EHX],CX[EHX],AX[EHX])
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX[EHX][EIX],CX[EHX][EIX],AX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX[EHX][EIX],CX[EHX][EIX],AX[EHX][EIX])
              END; END
              END
              EXIT
           CASE 3 
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX[EHX][EIX][EJX],CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX[EHX][EIX][EJX],CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX[EHX][EIX][EJX][EKX],CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX[EHX][EIX][EJX][EKX],CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "EA"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=CHARREPL(BX[EHX],CX[EHX],AX)
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX[EHX][EIX],CX[EHX][EIX],AX)
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX[EHX][EIX],CX[EHX][EIX],AX)
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX[EHX][EIX][EJX],CX[EHX][EIX][EJX],AX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX[EHX][EIX][EJX],CX[EHX][EIX][EJX],AX)
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX[EHX][EIX][EJX][EKX],CX[EHX][EIX][EJX][EKX],AX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX[EHX][EIX][EJX][EKX],CX[EHX][EIX][EJX][EKX],AX)
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "AE"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=CHARREPL(BX,CX[EHX],AX[EHX])
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX,CX[EHX][EIX],AX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX,CX[EHX][EIX],AX[EHX][EIX])
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX,CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX,CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX,CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX,CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "EE"    // escalares
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX]:=CHARREPL(BX,CX[EHX],AX)
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX,CX[EHX][EIX],AX)
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX]:=CHARREPL(BX,CX[EHX][EIX],AX)
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX,CX[EHX][EIX][EJX],AX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX]:=CHARREPL(BX,CX[EHX][EIX][EJX],AX)
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX,CX[EHX][EIX][EJX][EKX],AX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREPL(BX,CX[EHX][EIX][EJX][EKX],AX)
              END; END; END; END
              END
              EXIT
           END
           EXIT
       END
       //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
    END
    RELEASE TEMPORAL
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNMEMSTRWRITE()
  LOCAL EBX,EAX,AX,BX,CX,DX,FX,ETX:=.T.
  LOCAL OP_CODE:=820
    EAX:=STACK[CS]    // VARIABLE
    EBX:=STACK[CS-1]  // ARCHIVO
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS-=2
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    // FLAG para saber si añade a archivo. Por defecto añade.
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       ETX:=.F.
    elseif FVWITH!="A"
       ETX:=.F.
    end
    
    if ETX
       if !FILE(BX)
          IF (FX:=FCREATE(BX))<0  // CREATE
             RETURN _FUNPUTERROR("STRSAVE/SAVE CREATE FOR APPEND FAILURE",OP_CODE+2,CP)
          END
       END   
       IF (FX:=FOPEN(BX,2))<0  // APPEND
          RETURN _FUNPUTERROR("STRSAVE/SAVE APPEND FAILURE",OP_CODE+1,CP)
       ELSE
          //CX:=MLCOUNT(AX,2048)
          FSEEK(FX, 0, 2)   // ubica en el final del archivo
          //FOR DX:=1 TO CX
          //   FWRITE(FX,rtrim(hb_STRtoutf8(MEMOLINE(AX,2048,DX)))+_CR) 
          //END
          IF RIGHT(AX,1)==HB_OSNEWLINE()
             AX:=SUBSTR(AX,1,LEN(AX)-1)
          END
          FWRITE(FX,rtrim(hb_STRtoutf8(AX))+_CR)
          FCLOSE(FX)
       end
    ELSE    // WRITE
       IF (FX:=FCREATE(BX))<0  // CREATE
          RETURN _FUNPUTERROR("STRSAVE/SAVE CREATE FAILURE",OP_CODE,CP)
       ELSE
          //CX:=MLCOUNT(AX,2048)
          //FOR DX:=1 TO CX
          //   FWRITE(FX,rtrim(hb_STRtoutf8(MEMOLINE(AX,2048,DX)))+_CR) 
          //END
          IF RIGHT(AX,1)==HB_OSNEWLINE()
             AX:=SUBSTR(AX,1,LEN(AX)-1)
          END
          FWRITE(FX,rtrim(hb_STRtoutf8(AX))+_CR)
          FCLOSE(FX)
       end
    END
  RETURN .T.

  FUNCTION STRCHG()       // 87
  LOCAL EBX,BX,ECX,CX,AX,EAX,DX,EPX:="",OP_CODE:=870
  LOCAL EHX,EIX,EJX,EKX,EEX,EQX,ERX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]          // nuevo string
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // string a reemplazar
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]        // variable
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM
    CS -= 2
    IF VALTYPE(CX)=="C"
       EQX:=VALTYPE(BX)  // string a buscar
       ERX:=VALTYPE(AX)  // string nuevo
       EPX:=EQX+ERX
       if EPX=="CC"
          stk_var_02[CWM]:=STRTRAN(CX, BX, AX)  
       elseif EPX=="AC"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCHG/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          if DIM2==1
             DX:=CX
             FOR EHX:=1 TO DIM2R
                DX:=STRTRAN(DX,BX[EHX],AX)
             END
             stk_var_02[CWM]:=DX
          else
             RETURN _FUNPUTERROR("STRCHG/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          end
       elseif EPX=="AA"   // ambos son matrices
          IF !FUNGETDIMS(EAX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCHG/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCHG/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          if DIM1==DIM2
             if DIM1R==DIM2R
                DX:=CX
                FOR EHX:=1 TO DIM2R
                   DX:=STRTRAN(DX,BX[EHX],AX[EHX])
                END
                stk_var_02[CWM]:=DX
             else
                RETURN _FUNPUTERROR("STRCHG/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
             end
          else
             RETURN _FUNPUTERROR("STRCHG/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          end
       else
          RETURN _FUNPUTERROR("STRCHG/COMBINEICHON VERY VERY HUEVONEICHON",OP_CODE,CP)
       end
    ELSE
       if VALTYPE(AX)=="A"
          EPX:="A"
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRCHG/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          EPX:="E"
          TYP1:=valtype(AX)
       end
       if VALTYPE(BX)=="A"
          EPX:=EPX+"A"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRCHG/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       else
          EPX:=EPX+"E" 
          TYP2:=valtype(BX)
       end
       IF !FUNGETDIMS(ECX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRCHG/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
          
       SWITCH EPX
       CASE "AA"
          IF DIM1!=DIM2 .OR. DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B .or.;
             DIM1!=1 .OR. DIM2!=1
             RETURN _FUNPUTERROR("STRCHG(1)/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
          EXIT
       CASE "EA"
          //IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
          IF DIM2!=1 
             RETURN _FUNPUTERROR("STRCHG(2)/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
          EXIT
       CASE "AE"
          //IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
          IF DIM1!=1
             RETURN _FUNPUTERROR("STRCHG2(3)/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          END
          EXIT  
       END
       //////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       SWITCH EPX
        CASE "AA"
           TEMPORAL:=XSTRTRAN(CX,BX,AX,0,0,{XDIM,DIMR,DIMC,DIMP,DIMB,1})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCHG/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "EA"
           TEMPORAL:=XSTRTRAN(CX,BX,AX,0,0,{XDIM,DIMR,DIMC,DIMP,DIMB,2})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCHG/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "AE"
           TEMPORAL:=XSTRTRAN(CX,BX,AX,0,0,{XDIM,DIMR,DIMC,DIMP,DIMB,3})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCHG/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "EE"   // escalares
           TEMPORAL:=XSTRTRAN(CX,BX,AX,0,0,{XDIM,DIMR,DIMC,DIMP,DIMB,4})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRCHG/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        end
        RELEASE stk_var_02[CWM]
       //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:= TEMPORAL    ////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
       RELEASE TEMPORAL
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION STRREP()   // 83
  LOCAL XDIM,OP_CODE:=830,OCURR,NUMRE,BUSCA,REPLA
  LOCAL AX,EAX,EBX,ECX,EDX,EEX,EHX,ERX,EQX,EPX:="",DX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
  EQX:=STACK[CS]   // CUANTOS REEMPLAZA
  CWM:=CMPCWM(EQX,CWM,TopCWM)
  ERX:=STACK[CS-1]   // QUE OCURRENCIA REEMPLAZA
  CWM:=CMPCWM(ERX,CWM,TopCWM)
  EDX:=STACK[CS-2]   // hasta / caracter nuevo / caracter a ins 
  CWM:=CMPCWM(EDX,CWM,TopCWM)
  ECX:=STACK[CS-3]   // desde  / string a reemplazar / posicion
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  EAX:=STACK[CS-4]     // matriz
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  ++CWM
  CS-=4
  IF VALTYPE(stk_var_02[EAX])=="C"
       EPX:=VALTYPE(stk_var_02[ECX])+VALTYPE(stk_var_02[EDX])
       if EPX=="CC"
          stk_var_02[CWM]:=STRTRAN(stk_var_02[EAX], stk_var_02[ECX], stk_var_02[EDX], stk_var_02[ERX]+1, stk_var_02[EQX])
       elseif EPX=="AC"
          IF !FUNGETDIMS(ECX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          if DIM2==1
             DX:=stk_var_02[EAX]
             FOR EHX:=1 TO DIM2R
                DX:=STRTRAN(DX, stk_var_02[ECX][EHX], stk_var_02[EDX], ;
                                 stk_var_02[ERX]+1, stk_var_02[EQX])
             END
             stk_var_02[CWM]:=DX
          else
             RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          end
       elseIF EPX=="AA"   // ambos son matrices
          IF !FUNGETDIMS(EDX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          IF !FUNGETDIMS(ECX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          if DIM1==DIM2
             if DIM1R==DIM2R
                DX:=stk_var_02[EAX]
                FOR EHX:=1 TO DIM2R
                   DX:=STRTRAN(DX, stk_var_02[ECX][EHX], stk_var_02[EDX][EHX], ;
                                 stk_var_02[ERX]+1, stk_var_02[EQX])
                END
                stk_var_02[CWM]:=DX
             else
                RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
             end
          else
             RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          end
       ELSE
          IF !FUNGETDIMS(EDX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
          if DIM1==1
             DX:=stk_var_02[EAX]
             FOR EHX:=1 TO DIM1R
                DX:=STRTRAN(DX, stk_var_02[ECX], stk_var_02[EDX][EHX], ;
                              stk_var_02[ERX]+1, stk_var_02[EQX])
             END
             stk_var_02[CWM]:=DX
          else
             RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE+1,CP)
          end
       end
  ELSE
     if VALTYPE(stk_var_02[EDX])=="A"
        EPX:="A"
        IF !FUNGETDIMS(EDX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     ELSE
        EPX:="E"
        TYP1:=valtype(stk_var_02[EDX])
     end
     if VALTYPE(stk_var_02[ECX])=="A"
        EPX:=EPX+"A"
        IF !FUNGETDIMS(ECX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     else
        EPX:=EPX+"E" 
        TYP2:=valtype(stk_var_02[ECX])
     end
     IF !FUNGETDIMS(EAX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
        RETURN _FUNPUTERROR("STRREP/MATRIX NOT INITIALIZED",OP_CODE,CP)
     end
     SWITCH EPX
     CASE "AA"
        //IF XDIM!=DIM1.OR.XDIM!=DIM2
        IF DIM1!=DIM2 .OR. DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B .or.;
             DIM1!=1 .OR. DIM2!=1
           RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        END
        EXIT
     CASE "EA"
        //IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
        IF DIM2!=1
           RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        END
        EXIT
     CASE "AE"
        //IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
        IF DIM1!=1
           RETURN _FUNPUTERROR("STRREP/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        END  
        EXIT
     END
    //// TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     FUENTE:=stk_var_02[EAX]
     BUSCA:=stk_var_02[ECX]
     REPLA:=stk_var_02[EDX]
     
     if stk_var_02[ERX]<0
        OCURR:=0
     else
        OCURR:=stk_var_02[ERX]
     end
     if stk_var_02[EQX]<0
        NUMRE:=0
     else
        NUMRE:=stk_var_02[EQX]
     end
     
        SWITCH EPX
        CASE "AA"
           TEMPORAL:=XSTRTRAN(FUENTE,BUSCA,REPLA,OCURR,NUMRE,{XDIM,DIMR,DIMC,DIMP,DIMB,1})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRREP/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "EA"
           TEMPORAL:=XSTRTRAN(FUENTE,BUSCA,REPLA,OCURR,NUMRE,{XDIM,DIMR,DIMC,DIMP,DIMB,2})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRREP/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "AE"
           TEMPORAL:=XSTRTRAN(FUENTE,BUSCA,REPLA,OCURR,NUMRE,{XDIM,DIMR,DIMC,DIMP,DIMB,3})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRREP/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        CASE "EE"    // escalares
           TEMPORAL:=XSTRTRAN(FUENTE,BUSCA,REPLA,OCURR,NUMRE,{XDIM,DIMR,DIMC,DIMP,DIMB,4})
           IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("STRREP/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
           END
           EXIT
        end
     /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:= TEMPORAL    ////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  end
  STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRREPC()     // 79
  LOCAL EBX,BX,ECX,CX,AX,EAX,ELX,EPX:="",OP_CODE:=790
  LOCAL EHX,EIX,EJX,EKX,EEX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL XDIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]        // posicion
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // caracter
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]        // string
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=2;++CWM
    IF VALTYPE(CX)=="C"
       stk_var_02[CWM] := XPOSCHAR(CX,BX,AX)
    ELSE
       if VALTYPE(AX)=="A"
          EPX:="A"
          IF !FUNGETDIMS(EAX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRREPC/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          EPX:="E"
          TYP1:=valtype(AX)
       end
       if VALTYPE(BX)=="A"
          EPX:=EPX+"A"
          IF !FUNGETDIMS(EBX,@EEX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRREPC/MATRIX NOT INITIALIZED",OP_CODE,CP)
          END
       else
          EPX:=EPX+"E" 
          TYP2:=valtype(BX)
       end
       IF !FUNGETDIMS(ECX,@EEX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          RETURN _FUNPUTERROR("STRREPC/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       SWITCH EPX
       CASE "AA"
          IF XDIM!=DIM1.OR.XDIM!=DIM2
             RETURN _FUNPUTERROR("STRREPC/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT
       CASE "EA"
          IF XDIM!=DIM2.OR.DIMR!=DIM2R.OR.DIMC!=DIM2C.OR.DIMP!=DIM2P.OR.DIMB!=DIM2B
             RETURN _FUNPUTERROR("STRREPC/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
          EXIT
       CASE "AE"
          IF XDIM!=DIM1.OR.DIMR!=DIM1R.OR.DIMC!=DIM1C.OR.DIMP!=DIM1P.OR.DIMB!=DIM1B
             RETURN _FUNPUTERROR("STRREPC/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END 
          EXIT 
       END
       TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       SWITCH EPX
        CASE "AA"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX] := XPOSCHAR(CX[EHX],BX[EHX],AX[EHX])
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX[EHX][EIX],AX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX[EHX][EIX],AX[EHX][EIX])
              END; END
              END
              EXIT
           CASE 3 
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "EA"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX] := XPOSCHAR(CX[EHX],BX[EHX],AX)
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX[EHX][EIX],AX)
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX[EHX][EIX],AX)
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],AX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX[EHX][EIX][EJX],AX)
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX],AX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX[EHX][EIX][EJX][EKX],AX)
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "AE"
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX] := XPOSCHAR(CX[EHX],BX,AX[EHX])
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX,AX[EHX][EIX])
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX,AX[EHX][EIX])
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX,AX[EHX][EIX][EJX])
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX,AX[EHX][EIX][EJX])
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX,AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX,AX[EHX][EIX][EJX][EKX])
              END; END; END; END
              END
              EXIT
           END
           EXIT
        CASE "EE"   // escalares
           SWITCH XDIM
           CASE 1
              FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX] := XPOSCHAR(CX[EHX],BX,AX)
              END
              EXIT
           CASE 2 
              IF DIMR<=DIMC
              FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX,AX)
              END; END
              ELSE
              FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX] := XPOSCHAR(CX[EHX][EIX],BX,AX)
              END; END
              END
              EXIT
           CASE 3
              IF DIMR<=DIMC
              FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX,AX)
              END; END; END
              ELSE
              FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX] := XPOSCHAR(CX[EHX][EIX][EJX],BX,AX)
              END; END; END
              END
              EXIT
           CASE 4
              IF DIMR<=DIMC
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX,AX)
              END; END; END; END
              ELSE
              FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                 TEMPORAL[EHX][EIX][EJX][EKX] := XPOSCHAR(CX[EHX][EIX][EJX][EKX],BX,AX)
              END; END; END; END
              END
              EXIT
           END
           EXIT
        end
       /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,XDIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,XDIM,"C",DIMR,DIMC,DIMP,DIMB)
       RELEASE TEMPORAL
    END
    STACK[CS] := CWM
  RETURN .T.

  
  FUNCTION STRLIN()   // 138
  LOCAL AX,CX,EVX,EWX,EXX,DX,EHX,EIX,EJX,EKX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TYP2,TEMPORAL,tSIZE
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,OP_CODE:=1020
    EAX:=STACK[CS]
    ECX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM; --CS
    AX:=stk_var_02[EAX]  // NUMERO DE TOKEN
    CX:=stk_var_02[ECX]  // STRING
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    IF EXX=="CN" 
       tSIZE:=STRCUENTALINEAS(CX)
       IF AX<=tSIZE
          stk_var_02[CWM]:=STRGETLINEAS(CX,{AX},tSIZE)  // devuelve string de lineas
       ELSE
          stk_var_02[CWM]:=""
       END
       ///stk_var_02[CWM]:=ALLTRIM(MEMOLINE(CX,2048,AX))
    ELSEIF EXX=="CA"
       IF FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          IF DIM1==1
             tSIZE:=STRCUENTALINEAS(CX)
             stk_var_02[CWM]:=STRGETLINEAS(CX,AX,tSIZE)  // devuelve string de lineas
          ELSE
             RETURN _FUNPUTERROR("STRLIN/I NEED A VECTOR HERE",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("STRLIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    ELSEIF EXX=="AN"
       IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRLIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       IF DIM2!=1
             RETURN _FUNPUTERROR("STRLIN/I NEED A STRING VECTOR HERE",OP_CODE,CP)
       END
       TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       FOR EHX:=1 TO DIM2R
          tSIZE:=STRCUENTALINEAS(CX[EHX])
          TEMPORAL[EHX]:=STRGETLINEAS(CX[EHX],{AX},tSIZE)
       END
       stk_var_02[CWM]:=TEMPORAL
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    ELSE
       // obtiene EAX array NUMERO DE TOKEN
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRLIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          // puede ser un stack de arrays.
          IF DIM1>2
             RETURN _FUNPUTERROR("STRLIN/I NEED A ARRAYS/BI'MATRIX HERE",OP_CODE,CP)
          END
       end
       if EVX=="A" // correcto  MENSAJE A TOKEAR
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRLIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          IF DIM2!=1
             RETURN _FUNPUTERROR("STRLIN/I NEED A STRING VECTOR HERE",OP_CODE,CP)
          END
       end
       TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       IF DIM2==1
          IF DIM1==2
             FOR EHX:=1 TO DIM2R
                tSIZE:=STRCUENTALINEAS(CX[EHX])
                TEMPORAL[EHX]:=STRGETLINEAS(CX[EHX],AX[EHX],tSIZE)
                 ////TEMPORAL[EHX]:=ALLTRIM(MEMOLINE(CX[EHX],2048,AX[EHX]))
             END
          ELSE
             FOR EHX:=1 TO DIM2R
                tSIZE:=STRCUENTALINEAS(CX[EHX])
                TEMPORAL[EHX]:=STRGETLINEAS(CX[EHX],{AX[EHX]},tSIZE)
                 ////TEMPORAL[EHX]:=ALLTRIM(MEMOLINE(CX[EHX],2048,AX[EHX]))
             END
          END
       ELSE
          RETURN _FUNPUTERROR("STRLIN/DIMENSIONS FUCKING ERROR",OP_CODE,CP)
       END
       /////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    END
    STACK[CS]:=CWM
  RETURN .T.

  
  FUNCTION STRTOK()   // 102
  LOCAL AX,CX,EVX,EWX,EXX,DX,EHX,EIX,EJX,EKX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TYP2,TEMPORAL
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,OP_CODE:=1020
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C" .or. FVWITH==""
       FVWITH:=" "
       FTWITH:="C"
    end
    EAX:=STACK[CS]
    ECX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM; --CS
    AX:=stk_var_02[EAX]  // NUMERO DE TOKEN
    CX:=stk_var_02[ECX]  // STRING
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    IF EXX=="CN"
       stk_var_02[CWM]:=TOKEN(CX,FVWITH,AX)
    ELSE
       // obtiene EAX array NUMERO DE TOKEN
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRTOK/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  MENSAJE A TOKEAR
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRTOK/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("STRTOK/DIMENSION ERROR",OP_CODE,CP)
             end
          end
       end
       TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       IF EXX=="AA"   // AMBOS SON MATRICES
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=TOKEN(CX[EHX],FVWITH,AX[EHX])
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=TOKEN(CX[EHX][EIX],FVWITH,AX[EHX][EIX])
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=TOKEN(CX[EHX][EIX],FVWITH,AX[EHX][EIX])
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=TOKEN(CX[EHX][EIX][EJX],FVWITH,AX[EHX][EIX][EJX])
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=TOKEN(CX[EHX][EIX][EJX],FVWITH,AX[EHX][EIX][EJX])
             END; END; END
             END
             EXIT
          CASE 4
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=TOKEN(CX[EHX][EIX][EJX][EKX],FVWITH,AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=TOKEN(CX[EHX][EIX][EJX][EKX],FVWITH,AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             END
             EXIT
          END
       ELSE   ///IF EXX=="AN"
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=TOKEN(CX[EHX],FVWITH,AX)
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=TOKEN(CX[EHX][EIX],FVWITH,AX)
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=TOKEN(CX[EHX][EIX],FVWITH,AX)
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=TOKEN(CX[EHX][EIX][EJX],FVWITH,AX)
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=TOKEN(CX[EHX][EIX][EJX],FVWITH,AX)
             END; END; END
             END
             EXIT
          CASE 4
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=TOKEN(CX[EHX][EIX][EJX][EKX],FVWITH,AX)
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=TOKEN(CX[EHX][EIX][EJX][EKX],FVWITH,AX)
             END; END; END; END
             END
             EXIT
          END
       END
       //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    END
    STACK[CS]:=CWM
  RETURN .T.


/******************************************************************
            OPERADORES FAM. CSTRING_CODE
*******************************************************************/

  FUNCTION STRLZ()   // 88
  LOCAL OP_CODE:=880,AX,EFX,EAX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=(LEN(AX)==0)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMMLET(stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,9)
          ////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"L",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRLZ/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
  STACK[CS] := CWM 
  RETURN .T.

  
  FUNCTION XGETRANGE()    // 168
  LOCAL EBX,ECX,EDX,EEX,EPX
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
  LOCAL OP_CODE:=1680,FUENTE,POS
    EBX:=STACK[CS]    // arreglo posiciones --> legal o temporal 
    ECX:=STACK[CS-1]    // arreglo fuente --> legal o temporal
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    --CS
    ++CWM
    // arreglo fuente:
    IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
       RETURN _FUNPUTERROR("[< M],GET INDEX/MATRIX NOT INITIALIZED (EH! YOU, NEO: FOLLOW DE WHITE 8=D)",OP_CODE,CP)       
    END
    // arreglo de posiciones:
    IF !FUNGETDIMS(EBX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       RETURN _FUNPUTERROR("[< M],GET INDEX/MATRIX NOT INITIALIZED",OP_CODE,CP)
    END

    FUENTE:=stk_var_02[ECX]  // copio el puntero del vector a FUENTE
    POS:=stk_var_02[EBX]     // copio ptro de vector POSICION
    IF DIM1R+DIM1C+DIM1P+DIM1B == 0 //if LEN(POS)==0 
       RETURN _FUNPUTERROR("[< M],GET INDEX/VECTOR DIMENSION ERROR (EMPTY VECTOR)",OP_CODE+1,CP)
    end

   // como devuelve un vector, el resultado debe tener la dimensiones del array en cuanto a filas
    /////TEMPORAL:=ARRAY(DIM1R)

    /* verifica si es un vector simple */

    EPX:=IIF( TYP2=="C", 1, IIF( TYP2=="N", 2, 3 ))
    TEMPORAL:=XFUNGETRANGE(FUENTE,POS,{DIM2,DIM1R,DIM1C,DIM2R,DIM2C,DIM2P,DIM2B,EPX})
    IF LEN(TEMPORAL)>0
       //////stk_var_02[CWM]:=ARRAY(DIM1R)
       stk_var_02[CWM]:= TEMPORAL    ////XMMLET(TEMPORAL,1,DIM1R,0,0,0,0)
       FUNPUTDIMS(CWM,1,TYP2,DIM1R,0,0,0)
       STACK[CS]:=CWM
    ELSE
       RETURN _FUNPUTERROR("[< M],GET INDEX/DIMENSION ERROR LEVEL PICHULON",OP_CODE+1,CP)
    END
    RELEASE TEMPORAL
  RETURN .T.
  
  FUNCTION XPUTRANGE()    // 167
  LOCAL EAX,ECX,EBX,AX,EDX,EEX,ELX,EHX,ETX,EPX,EVX:=0 // single elemento
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM3,DIM3R,DIM3C,DIM3P,DIM3B,TYP3
  LOCAL DIMS,POS,TEMPORAL
  LOCAL OP_CODE:=1670
    EAX:=STACK[CS]
    ECX:=STACK[CS-1]    // arreglo de posiciones --> legal o temporal
    EBX:=STACK[CS-2]    // arreglo fuente --> legal o temporal 
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CS-=3
    // arreglo fuente:
    IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
       RETURN _FUNPUTERROR("[> M],PUT RANGE/MATRIX NOT INITIALIZED",OP_CODE,CP)       
    END
    AX:=stk_var_02[EAX]  // elemento a rellenar
    if valtype(AX)=="A"   // elemento a asignar es un array y puede ser temporal:
       IF !FUNGETDIMS(EAX,@EDX,@DIM3,@TYP3,@DIM3R,@DIM3C,@DIM3P,@DIM3B,.T.)
          RETURN _FUNPUTERROR("[> M],PUT RANGE/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       EVX:=1   // array elemento
    end   // END VALTYPE
    // arreglo de posiciones:
    IF !FUNGETDIMS(ECX,@EEX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       RETURN _FUNPUTERROR("[> M],PUT INDEX/MATRIX NOT INITIALIZED",OP_CODE,CP)
    END

    POS:=stk_var_02[ECX]     // copio ptro de vector POSICION
    if LEN(POS)==0
       RETURN _FUNPUTERROR("[> M],PUT INDEX/DIMENSION ERROR (EMPTY VECTOR)",OP_CODE+1,CP)
    end

    EPX:=IIF( TYP2=="C", 1, IIF( TYP2=="N", 2, 3 ))
    TEMPORAL:=XFUNPUTRANGE(stk_var_02[EBX],AX,POS,{DIM2,DIM1R,DIM1C,DIM2R,DIM2C,DIM2P,DIM2B,EPX,EVX})
    IF LEN(TEMPORAL)==0
       // no s einicializa FUENTE, porque solo se modificaran algunas posiciones
       RETURN _FUNPUTERROR("[> M],PUT INDEX/DIMENSION ERROR LEVEL PICHULON",OP_CODE+1,CP)
    END
    stk_var_02[EBX]:=TEMPORAL  // nuevo tras modificacion de punteros

  RETURN .T.
  
  FUNCTION FUNSEQSP()    // 95
  LOCAL EAX,EBX,ECX,AX,BX,CX,DX,ETX
  LOCAL OP_CODE:=950
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)

    CS-=2
    ++CWM
    AX:=stk_var_02[EAX]      // numero de elementos
    BX:=stk_var_02[EBX]      // fin
    CX:=stk_var_02[ECX]      // inicio        
    if AX<=0
       RETURN _FUNPUTERROR("[= M...],SEQUENCE SPACED/FUCKING ARGUMENTS",OP_CODE,CP)
    elseif CX>BX
       ETX:=CX
       CX:=BX
       BX:=ETX
    end
    stk_var_02[CWM]:=SEQSP( CX, BX, AX )
    FUNPUTDIMS(CWM,1,"N",AX,0,0,0)
    STACK[CS]:=CWM
  RETURN .T.

  FUNCTION FUNSEQUENCE()    // 70
  LOCAL EAX,EBX,ECX,AX,BX,CX,DX,ETX
  LOCAL OP_CODE:=700
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)

    CS-=2
    ++CWM
    AX:=stk_var_02[EAX]      // numero de elementos
    BX:=stk_var_02[EBX]      // incremento
    CX:=stk_var_02[ECX]      // inicio    
    if AX<=0
       RETURN _FUNPUTERROR("SEQ/SEQUENCE SPACED/FUCKING ARGUMENTS",OP_CODE,CP)
 /*   elseif CX>BX
       ETX:=CX
       CX:=BX
       BX:=ETX */
    end
    stk_var_02[CWM]:=SEQUENCE( CX, BX, AX )
    FUNPUTDIMS(CWM,1,"N",AX,0,0,0)
    STACK[CS]:=CWM
  RETURN .T.
    
  FUNCTION AFINDSTK()    // 123
  LOCAL EAX,EBX,ECX,EDX,EZX,AX,BX,CX,DX,EHX,EIX,EJX,EKX,EPX,OPE,CASESEN,CARACTER
  LOCAL FIL,COL,DIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL,SW_MATCH:=.F.
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,OP_CODE:=1230
  LOCAL CCX,AAX
    ECX:=STACK[CS]       // elemento
    EBX:=STACK[CS-1]     // operador de comparacion
    EAX:=STACK[CS-2]     // array
    BX:=stk_var_02[EBX]      // OP
    CX:=stk_var_02[ECX]      // elem
    AX:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=2
    ++CWM
    
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo

    if FTWITH!="L" 
       FVWITH := .F.   // valor por defecto: case sensitive
       FTWITH := "L"   // tipo
    end
    
    IF VALTYPE(AX)=="C"
       IF BX == "@"
          IF VALTYPE(CX)=="C"
             EPX:=1
             EHX:=0
             TEMPORAL:={}
             IF !FVWITH
                WHILE .T. 
                   EHX:=ATNUM(CX,AX,EPX)
                   IF EHX > 0 ; AADD(TEMPORAL,EHX) ; ++EPX
                   ELSE ; EXIT ; END
                END
             ELSE
                AAX:=UPPER(AX); CCX:=UPPER(CX)
                WHILE .T. 
                   EHX:=ATNUM(CCX,AAX,EPX)
                   IF EHX > 0 ; AADD(TEMPORAL,EHX) ; ++EPX
                   ELSE ; EXIT ; END
                END
             END
             stk_var_02[CWM]:=ARRAY(EPX)  // ENTREGA ARRAY DE CERO SI NO ENCUENTRA NADA
             IF --EPX > 0  // RESTO PORQUE LA ULTIMA ES CERO
                stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,1,EPX,0,0,0,0)
             END
             FUNPUTDIMS(CWM,1,"N",EPX,0,0,0)
             STACK[CS]:=CWM 
          ELSE  //
             RETURN _FUNPUTERROR("FIND STRING/ARGUMENT STRING IS REQUERIED, AWEONATOR",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("FIND STRING/OPERATOR PUSH IN YOUR ANUS",OP_CODE+9,CP)
       END
       RETURN .T.
    END
    
    IF !FUNGETDIMS(EAX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
       RETURN _FUNPUTERROR("FIND MATRIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
    END
    IF VALTYPE(CX)=="A"
       IF !FUNGETDIMS(ECX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("FIND MATRIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       if TYP!=TYP1
          RETURN _FUNPUTERROR("FIND MATRIX/TYPE MISMATCH",OP_CODE+1,CP)
       end
       ///TEMPORAL:={} //ARRAY(0)
       FIL:=0
       COL:=DIM
       
       IF DIMR==DIM1R .AND. DIMC==DIM1C .AND. DIMP==DIM1P .AND. DIMB==DIM1B

          OPE:=IIF(BX=="=",1, IIF(BX==">",2, IIF(BX=="<",3, IIF(BX==">=",4, ;
               IIF(BX=="<=",5, IIF(BX=="<>",6, IIF(BX=="@", 7, IIF(BX=="~@", 8, ;
               IIF(UPPER(BX)=="IS", 9, IIF(UPPER(BX)=="NAN",10, IIF(UPPER(BX)=="INF",11, 0 ) ) ) ) ) ) ) ))))
          IF OPE==0
             RETURN _FUNPUTERROR("FIND MATRIX/OPERATOR NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
          END
          TYP:=IIF(TYP=="C",1, IIF(TYP=="N",2, 3))
          TEMPORAL:=XFINDSTK1(AX,CX,{DIM,DIMR,DIMC,DIMP,DIMB,OPE,IIF(FVWITH,1,0),TYP,1})
          FIL:=LEN(TEMPORAL)
         /* IF FIL == 0   // no va, porque puede devolver vacío
             RETURN _FUNPUTERROR("FIND MATRIX/OPERATION NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
          END */
       ELSE   // hay un vector, o al menos, debe serlo
          IF DIM1C==0 
             CARACTER:=0   // comparacion suave: solo algunos deben cumplir (excepto "~@").
             IF "*" $ BX
               BX:=STRTRAN(BX,"*","")  // quito "*"
               CARACTER:=1 // comparacion fuerte: todos deben cumplir (excepto "~@").
             END
             OPE:=IIF(BX=="=",1, IIF(BX==">",2, IIF(BX=="<",3, IIF(BX==">=",4, ;
               IIF(BX=="<=",5, IIF(BX=="<>",6, IIF(BX=="@", 7, IIF(BX=="~@", 8, 0 ) ) ) ) ) ) ))
             IF OPE==0
                RETURN _FUNPUTERROR("FIND MATRIX/OPERATOR NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
             END
             TYP:=IIF(TYP=="C",1, IIF(TYP=="N",2, 0))
             IF TYP==0
                RETURN _FUNPUTERROR("FIND MATRIX/OPERATOR NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
             END
             TEMPORAL:=X2FINDSTK(AX,CX,{DIM,DIMR,DIMC,DIMP,DIMB,DIM1R,OPE,IIF(FVWITH,1,0),TYP,CARACTER})
             FIL:=LEN(TEMPORAL)
             /*IF FIL < 0
                RETURN _FUNPUTERROR("FIND MATRIX/OPERATION NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
             END*/
          ELSE
             RETURN _FUNPUTERROR("FIND MATRIX/DIMENSION GARRAFAL ERROR",OP_CODE+4,CP)
          END
       END
    ELSE   // es un elemento!
       ///TEMPORAL:={}  //ARRAY(0)
       FIL:=0
       COL:=DIM
       OPE:=IIF(BX=="=",1, IIF(BX==">",2, IIF(BX=="<",3, IIF(BX==">=",4, ;
            IIF(BX=="<=",5, IIF(BX=="<>",6, IIF(BX=="@", 7, IIF(BX=="~@", 8, ;
            IIF(UPPER(BX)=="IS", 9, IIF(UPPER(BX)=="NAN",10, IIF(UPPER(BX)=="INF",11, 0 ) ) ) ) ) ) ) ))))
       IF OPE==0
          RETURN _FUNPUTERROR("FIND MATRIX/OPERATOR NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
       END
       TYP:=IIF(TYP=="C",1, IIF(TYP=="N",2, 3))
       TEMPORAL:=XFINDSTK1(AX,CX,{DIM,DIMR,DIMC,DIMP,DIMB,OPE,IIF(FVWITH,1,0),TYP,2})
       FIL:=LEN(TEMPORAL)
      /* IF FIL == 0
          RETURN _FUNPUTERROR("FIND MATRIX/OPERATION NOT RECOGNIZED FOR THIS COMBINATION",OP_CODE+2,CP)
       END */
      /* for i:=1 to len(TEMPORAL)
          ? "==", TEMPORAL[i]
       end*/
    END // IF
    IF DIM==1
       COL:=0
    ELSE
       DIM:=2
    END
//    FUNPUTDIMS(CWM,IIF(DIM==1,1,2),"N",FIL,COL,0,0)
    /////stk_var_02[CWM]:=ARRAY(FIL,COL)
    stk_var_02[CWM]:=TEMPORAL ///XMMLET(TEMPORAL,DIM,FIL,COL,0,0,0)
    FUNPUTDIMS(CWM,DIM,"N",FIL,COL,0,0)
   /// RELEASE TEMPORAL
    STACK[CS]:=CWM 
  RETURN .T.

  
  FUNCTION FUNSIZE()    // 124
  LOCAL EAX,EDX, OP_CODE:=1240
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP
    EAX:=STACK[CS]       // matrix a procesar
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    IF FUNGETDIMS(EAX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.) 
       switch DIM       
       case 1
          stk_var_02[CWM]:=ARRAY(2)
          stk_var_02[CWM][1]:=DIM; stk_var_02[CWM][2]:=DIMR
          exit
       case 2
          stk_var_02[CWM]:=ARRAY(3)
          stk_var_02[CWM][1]:=DIM; stk_var_02[CWM][2]:=DIMR; stk_var_02[CWM][3]:=DIMC
          exit
       case 3
          stk_var_02[CWM]:=ARRAY(4)
          stk_var_02[CWM][1]:=DIM; stk_var_02[CWM][2]:=DIMR; stk_var_02[CWM][3]:=DIMC; stk_var_02[CWM][4]:=DIMP
          exit
       case 4
          stk_var_02[CWM]:=ARRAY(5)
          stk_var_02[CWM][1]:=DIM; stk_var_02[CWM][2]:=DIMR; stk_var_02[CWM][3]:=DIMC 
          stk_var_02[CWM][4]:=DIMP; stk_var_02[CWM][5]:=DIMB
          exit
       end
    ELSE
       RETURN _FUNPUTERROR("SIZE/MATRIX NOT INITIALIZED",OP_CODE,CP)
    END
    FUNPUTDIMS(CWM,1,"N",LEN(stk_var_02[CWM]),0,0,0)
    STACK[CS]:=CWM 
  RETURN .T.


/******************************************************************
       XVTMATFILE: operaciones de grabacion y carga de matrices
*******************************************************************/
FUNCTION XVTMATFILE()   // 78
LOCAL EAX,EBX,ECX,CX,FX,EDX,EZX,ESX,EWX,EUX,EMX,ETX,ENX
LOCAL EHX,EIX,EJX,EKX
LOCAL DIM,TYP,DIMR,DIMC,DIMP,DIMB,cBUFF
LOCAL OP_CODE:=780,FUENTE,SEP,SW_OK
  EAX:=STACK[CS]    // nombre de archivo
  EBX:=STACK[CS-1]  // matriz
  ECX:=STACK[CS-2]  // codigo de operacion 
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CS -= 3
  CX:=stk_var_02[ECX]  // codigo funcion
  FX:=stk_var_02[EAX]  // file
  FUENTE:=stk_var_02[EBX]  // matrix
  if STK_CWMTOP>0
     EDX := STK_TEMP_DIR[STK_CWMTOP]
     if EDX!=EBX
        EDX := ASCAN(STK_ARRAY_DIR,EBX)
        DIM :=STK_ARRAY_DIM[EDX]
        TYP :=STK_ARRAY_TYP[EDX]
        DIMR:=STK_ARRAY_ROW[EDX]
        DIMC:=STK_ARRAY_COL[EDX]
        DIMP:=STK_ARRAY_PAG[EDX]
        DIMB:=STK_ARRAY_BLK[EDX]
     else
        if CX==2  // lee: error weon!
           RETURN _FUNPUTERROR("LOAD MATRIX/LOAD OVER YOUR CALCULUS? (WEON-ERROR)",OP_CODE,CP)
        else
           DIM:=STK_TEMP_DIM[STK_CWMTOP]
           TYP:=STK_TEMP_TYP[STK_CWMTOP]
           DIMR:=STK_TEMP_ROW[STK_CWMTOP]
           DIMC:=STK_TEMP_COL[STK_CWMTOP]
           DIMP:=STK_TEMP_PAG[STK_CWMTOP]
           DIMB:=STK_TEMP_BLK[STK_CWMTOP]
           STK_TEMP_DIR[STK_CWMTOP]:=0
           STK_CWMTOP--
        end
     end
  else  // es legal
     EDX := ASCAN(STK_ARRAY_DIR,EBX)
     DIM :=STK_ARRAY_DIM[EDX]
     TYP :=STK_ARRAY_TYP[EDX]
     DIMR:=STK_ARRAY_ROW[EDX]
     DIMC:=STK_ARRAY_COL[EDX]
     DIMP:=STK_ARRAY_PAG[EDX]
     DIMB:=STK_ARRAY_BLK[EDX]
  end 
  if DIMR==0  
     if CX==1 .or. CX==3
        RETURN _FUNPUTERROR("SAVE MATRIX/MATRIX NOT INITIALIZED OR INVALID",OP_CODE+1,CP)
     end
  end
  FVWITH := FLAG[1]   // valor
  FTWITH := UPPER(FLAG[2])   // tipo

  SEP := ","  // valor por defecto: matriz separado con comas
  if FTWITH=="C"
     //if FVWITH!=""
        SEP := FVWITH
     //end
  end
/***  FVWITH:=UPPER(FVWITH)
  if len(FVWITH)!=2
     if FVWITH!="V".and.FVWITH!="M"
        if CX==2
           FVWITH:="V"
        else
           SEP:=FVWITH
        end
     end
  else
     SEP:=substr(FVWITH,2,2)
     FVWITH:=substr(FVWITH,1,1)
     if FVWITH!="V".and.FVWITH!="M"
        FVWITH:="V"
     end
  end ****/
  
  if CX==1 .or. CX==3  // SAVE o APPEND
     if CX==1
        if (EFX:=FCREATE(FX))<0
           RETURN _FUNPUTERROR("SAVE MATRIX/FUCKING CREATE FILE",OP_CODE+2,CP)
        end
     else
        if (EFX:=FOPEN(FX, 2))<0
           RETURN _FUNPUTERROR("SAVE MATRIX/FUCKING APPEND FILE",OP_CODE+3,CP)
        end
        FSEEK(EFX, 0, 2)   // ubica en el final del archivo
     end
     SWITCH DIM
     CASE 1   // un vector. Lo guarda hacia el lado.
        SWITCH TYP
        CASE "N"   // number!
           FWRITE (EFX,iif(CONTEXT_NUMBER=="E",D2E(FUENTE[1],XUPRECISION),;
               XFUNNUM2STRING(FUENTE[1],XUPRECISION)/*alltrim(str(FUENTE[1]))*/ ))
           for EHX:=2 to DIMR
              FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX],XUPRECISION),;
                  XFUNNUM2STRING(FUENTE[EHX],XUPRECISION)/*alltrim(str(FUENTE[EHX]))*/ ))
           end

           EXIT
        CASE "L"   // logic!
           FWRITE (EFX,iif(FUENTE[1],CONTEXT_TRUE,CONTEXT_FALSE))
           for EHX:=2 to DIMR
              FWRITE (EFX,SEP+iif(FUENTE[EHX],CONTEXT_TRUE,CONTEXT_FALSE))
           end
           EXIT
        CASE "C"   // string!
           FWRITE (EFX,FUENTE[1])
           for EHX:=2 to DIMR
              FWRITE (EFX,SEP+FUENTE[EHX])
           end
           EXIT
        end
        FWRITE (EFX,_CR)
        FCLOSE (EFX)
        EXIT
     CASE 2   // es una 2D!
        SWITCH TYP
        CASE "N"   // number!
           for EHX:=1 to DIMR
              FWRITE (EFX,iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][1],XUPRECISION),;
                XFUNNUM2STRING(FUENTE[EHX][1],XUPRECISION) /*alltrim(str(FUENTE[EHX][1]))*/ ))
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][EIX],XUPRECISION),;
                   XFUNNUM2STRING(FUENTE[EHX][EIX],XUPRECISION) /*alltrim(str(FUENTE[EHX][EIX]))*/ ))
              end
              FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][DIMC],XUPRECISION),;
                 XFUNNUM2STRING(FUENTE[EHX][DIMC],XUPRECISION) /*alltrim(str(FUENTE[EHX][DIMC]))*/ )+_CR)
           end
           EXIT
        CASE "L"   // logic!
           for EHX:=1 to DIMR
              FWRITE (EFX,iif(FUENTE[EHX][1],CONTEXT_TRUE,CONTEXT_FALSE))
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+iif(FUENTE[EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE))
              end
              FWRITE (EFX,SEP+iif(FUENTE[EHX][DIMC],CONTEXT_TRUE,CONTEXT_FALSE)+_CR)
           end
           EXIT
        CASE "C"   // string!
           for EHX:=1 to DIMR
              FWRITE (EFX,FUENTE[EHX][1])
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+FUENTE[EHX][EIX])
              end
              FWRITE (EFX,SEP+FUENTE[EHX][DIMC]+_CR)
           end
           EXIT
        end
        
        FCLOSE (EFX)
        EXIT
     CASE 3
        SWITCH TYP
        CASE "N"   // number!
           for EJX:=1 to DIMP; for EHX:=1 to DIMR
              FWRITE (EFX,iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][1][EJX],XUPRECISION),;
                 XFUNNUM2STRING(FUENTE[EHX][1][EJX],XUPRECISION) /*alltrim(str(FUENTE[EHX][1][EJX]))*/ ))
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][EIX][EJX],XUPRECISION),;
                   XFUNNUM2STRING(FUENTE[EHX][EIX][EJX],XUPRECISION) /*alltrim(str(FUENTE[EHX][EIX][EJX]))*/ ))
              end
              FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][DIMC][EJX],XUPRECISION),;
                XFUNNUM2STRING(FUENTE[EHX][DIMC][EJX],XUPRECISION) /*alltrim(str(FUENTE[EHX][DIMC][EJX]))*/ )+_CR)
           end; end
           EXIT
        CASE "L"   // logic!
           for EJX:=1 to DIMP; for EHX:=1 to DIMR
              FWRITE (EFX,iif(FUENTE[EHX][1][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+iif(FUENTE[EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
              end
              FWRITE (EFX,SEP+iif(FUENTE[EHX][DIMC][EJX],CONTEXT_TRUE,CONTEXT_FALSE)+_CR)
           end; end
           EXIT
        CASE "C"   // string!
           for EJX:=1 to DIMP; for EHX:=1 to DIMR
              FWRITE (EFX,FUENTE[EHX][1][EJX])
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+FUENTE[EHX][EIX][EJX])
              end
              FWRITE (EFX,SEP+FUENTE[EHX][DIMC][EJX]+_CR)
           end; end
           EXIT
        end
        FCLOSE(EFX)
        EXIT
     CASE 4     // 4D
        SWITCH TYP
        CASE "N"   // number!
           for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
              FWRITE (EFX,iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][1][EJX][EKX],XUPRECISION),;
                 XFUNNUM2STRING(FUENTE[EHX][1][EJX][EKX],XUPRECISION) /*alltrim(str(FUENTE[EHX][1][EJX][EKX]))*/ ))
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][EIX][EJX][EKX],XUPRECISION),;
                   XFUNNUM2STRING(FUENTE[EHX][EIX][EJX][EKX],XUPRECISION) /*alltrim(str(FUENTE[EHX][EIX][EJX][EKX]))*/ ))
              end
              FWRITE (EFX,SEP+iif(CONTEXT_NUMBER=="E",D2E(FUENTE[EHX][DIMC][EJX][EKX],XUPRECISION),;
                XFUNNUM2STRING(FUENTE[EHX][DIMC][EJX][EKX],XUPRECISION) /*alltrim(str(FUENTE[EHX][DIMC][EJX][EKX]))*/ )+_CR)
           end; end; end
           EXIT
        CASE "L"   // logic!
           for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
              FWRITE (EFX,iif(FUENTE[EHX][1][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+iif(FUENTE[EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
              end
              FWRITE (EFX,SEP+iif(FUENTE[EHX][DIMC][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE)+_CR)
           end; end; end
           EXIT
        CASE "C"   // string!
           for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR
              FWRITE (EFX,FUENTE[EHX][1][EJX][EKX])
              for EIX:=2 to DIMC-1
                 FWRITE (EFX,SEP+FUENTE[EHX][EIX][EJX][EKX])
              end
              FWRITE (EFX,SEP+FUENTE[EHX][DIMC][EJX][EKX]+_CR)
           end; end; end
           EXIT
        end
        FCLOSE(EFX)
        EXIT
     END
     
  else       // LOAD    

     ENX:=CUENTALINEAS(FX,SEP)  // ENX=numero de lineas, num tokens 1ra linea, numtokens tottal, caracteres totales, longitud mayor token
    // ? "ANTES DEL AJUSTE: ",ENX[1],ENX[2],ENX[3],ENX[4],ENX[5]
    // quit 
     IF ENX[1]*ENX[2] != ENX[3]
        RETURN _FUNPUTERROR("LOAD MATRIX/UNDEFINED ERROR: CHECK YOUR FILE FOR EOF END LINE",OP_CODE+4,CP)
     ELSEIF ENX[4]==-1
        RETURN _FUNPUTERROR("LOAD MATRIX/DISTINT NUMBER OF TOKENS",OP_CODE+4,CP)
     ELSEIF ENX[4]==-2
        RETURN _FUNPUTERROR("LOAD MATRIX/FILE BAD FORMED, CHECK LAST CHAR",OP_CODE+4,CP)
     END
     
     IF ENX[2]==1
        DIM:=1
     ELSEIF ENX[1]==1
        DIM:=1
        ETX:=ENX[1]
        ENX[1]:=ENX[2]
        ENX[2]:=ETX
     ELSEIF ENX[1]==1 .AND. ENX[2]==1 .AND. ENX[3]==1
        RETURN _FUNPUTERROR("LOAD MATRIX/FILE BAD FORMED, OR FLAG INCORRECT",OP_CODE+4,CP)
     ELSE
        DIM:=2
     END
     
   // ? "DESPUES DEL AJUSTE: ",ENX[1],ENX[2],ENX[3],ENX[4],ENX[5]

     EFX:=FOPEN(FX)
     cBUFF:=HB_UTF8TOSTR(FREADSTR(EFX,ENX[4]))
     FCLOSE(EFX)
     stk_var_02[EBX]:=GETLINEAS(cBUFF,SEP,DIM,ENX[1],ENX[2],ENX[4],;
                                iif(TYP=="C",0,iif(TYP=="N",1,2)),CONTEXT_TRUE,ENX[5])
     IF LEN(stk_var_02[EBX])==0
        RETURN _FUNPUTERROR("(1)LOAD MATRIX/FILE BAD FORMED, OR FLAG INCORRECT",OP_CODE+4,CP)
     END
     ////stk_var_02[EBX]:=MATLOAD(EFX,SEP,DIM,TYP,ENX[1],ENX[2],ENX[4])
     
     RELEASE cBUFF
     
     STK_ARRAY_DIM[EDX]:=DIM
     STK_ARRAY_TYP[EDX]:=TYP
     STK_ARRAY_ROW[EDX]:=ENX[1]  //NUMLIN
     STK_ARRAY_COL[EDX]:=IIF(ENX[2]==1,0,ENX[2])  
     STK_ARRAY_PAG[EDX]:=0
     STK_ARRAY_BLK[EDX]:=0
  end
RETURN .T.


/******************************************************************
                  FAM. OPERACIONES LOGICAS  LOPERA_CODE        
*******************************************************************/
FUNCTION LOPERA_CODE()    // 60
LOCAL EAX,EBX
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  __P[stk_prg[++CP]]:EXEC(EAX,EBX)
  STACK[--CS] := CWM  
RETURN .T.

  FUNCTION FUNOR(EAX,EBX)   // 238
    stk_var_02[CWM]:=stk_var_02[EBX] .OR. stk_var_02[EAX]
  RETURN 

  FUNCTION FUNAND(EAX,EBX)   // 235
    stk_var_02[CWM]:=stk_var_02[EBX] .AND. stk_var_02[EAX]
  RETURN 

  FUNCTION FUNXOR(EAX,EBX)     // 128
  LOCAL ECX,EDX
    ECX:=stk_var_02[EBX]
    EDX:=stk_var_02[EAX]
    stk_var_02[CWM]:=(ECX .AND. !EDX) .OR. (!ECX .AND. EDX)
  RETURN 

/******************************************************************
                FAM. FUNCIONES DE MASCARA DE NUMEROS
*******************************************************************/

  FUNCTION FUNSATURA()   // 171
  LOCAL EAX,AX,DX,BX,EX,EEX,EFX,FX,EDX,TEMPORAL,RTX
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B,OP_CODE:=1710
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
    EEX:=STACK[CS]
    EX:=stk_var_02[EEX]          // LINEA
    EFX:=STACK[CS-1]
    FX:=stk_var_02[EFX]          // TOKEN O ARRAY DE POSICIONES
    EAX:=STACK[CS-2]
    AX:=stk_var_02[EAX]          // FUENTE
    CWM:=CMPCWM(EEX,CWM,TopCWM)
    CWM:=CMPCWM(EFX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM; CS-=2
   /*** 
        V<-SATURA(TOKENS,",",LINEA-A-SATURAR)
        V<-SATURA(TOKENS,ARRAY-POSICIONES, LINEA-A-SATURAR)
        ***/
    BX:=VALTYPE(AX)+VALTYPE(FX)+VALTYPE(EX)
    IF BX=="CCC"
       stk_var_02[CWM]:=XFUNCCCSATURA(AX, FX, EX) // EL CHIQUITO
       IF LEN(stk_var_02[CWM])==0
          RETURN _FUNPUTERROR("SATURA/NOT ENOUGH MEMORY TO ALLOCATE, OR MASK ERROR",OP_CODE,CP)
       END
    ELSEIF BX=="CAC"
       IF FUNGETDIMS(EFX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          IF DIM1==1 .AND. DIM1R>0
             stk_var_02[CWM]:=XFUNCACSATURA(AX, FX, EX, DIM1R) // EL CHIQUITO
             IF LEN(stk_var_02[CWM])==0
                RETURN _FUNPUTERROR("SATURA/NOT ENOUGH MEMORY TO ALLOCATE, OR MASK ERROR",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("SATURA/I NEED A VECTOR POSITION HERE, OR IT IS EMPTY, MERME",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("SATURA/VECTOR POSITION NOT INITIALIZED",OP_CODE,CP)
       END
    ELSEIF BX=="ACC"
       IF FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          IF VALTYPE(FX)=="C"
             ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
             TEMPORAL:=XSATURA(AX, FX, EX, 0, {DIM1,DIM1R,DIM1C,DIM1P,DIM1B})
             IF LEN(TEMPORAL)==0
                RETURN _FUNPUTERROR("SATURA/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
             END
             //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
             stk_var_02[CWM]:=  TEMPORAL  ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
             FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
             RELEASE TEMPORAL
          ELSE
             RETURN _FUNPUTERROR("SATURA/SEPARATOR NOT RECOGNIZED, LONGI",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("SATURA/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    ELSE   // DEBE SER "AAC"
       IF FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          IF FUNGETDIMS(EFX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             IF DIM2==1
                IF DIM2R>0
                   /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
                   TEMPORAL:=XSATURA(AX, FX, EX, DIM2R, {DIM1,DIM1R,DIM1C,DIM1P,DIM1B})
                   IF LEN(TEMPORAL)==0
                      RETURN _FUNPUTERROR("SATURA/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
                   END
                   //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
                   stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
                   FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
                   RELEASE TEMPORAL
                ELSE
                   RETURN _FUNPUTERROR("SATURA/VECTOR POSITION IS EMPTY",OP_CODE,CP)
                END
             ELSE
                RETURN _FUNPUTERROR("SATURA/I NEED A VECTOR POSITION HERE, MERME",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("SATURA/VECTOR POSITION NOT INITIALIZED",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("SATURA/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END     
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNMONEY()    // 172
  LOCAL EAX,AX,EBX,BX,DX,EX,EEX,EFX,FX,EDX,TEMPORAL,RTX
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B,OP_CODE:=1720
    EEX:=STACK[CS]
    EX:=stk_var_02[EEX]          // ancho pad
    EFX:=STACK[CS-1]
    FX:=stk_var_02[EFX]          // decimales
    EAX:=STACK[CS-2]
    AX:=stk_var_02[EAX]          // mascara
    EBX:=STACK[CS-3]
    BX:=stk_var_02[EBX]        // feunte
    CWM:=CMPCWM(EEX,CWM,TopCWM)
    CWM:=CMPCWM(EFX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM; CS-=3
   /*** 
        nvar<-2902323
        money(nvar " US$" 2 18) -> US$   2,902,323.00 :signo, relleno, decimales, ancho 
        nvar<-190789.897
        money(nvar "" 2 18 )  -> 190,789.90 : sin caracter de relleno ni signo.
        ***/

    DX:=substr(AX,1,1)  // relleno
    AX:=substr(AX,2,len(AX))  // tipo moneda
    
    IF VALTYPE(BX)=="N"
       //? "ENTRA: ",BX,AX,DX,FX,EX
       stk_var_02[CWM]:=XFUNMONEY(BX, AX, DX, FX, EX)
       //? "SALE: ",stk_var_02[CWM]
    ELSE
       IF FUNGETDIMS(EBX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMONEY( BX, AX, DX, FX, EX, {DIM1,DIM1R,DIM1C,DIM1P,DIM1B})
          IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("MONEY/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
          END
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MONEY/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNMASK()    // 178
  LOCAL EAX,AX,EBX,BX,DX,EDX,TEMPORAL,RTX
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B,OP_CODE:=1780
    EAX:= STACK[CS]
    AX:=stk_var_02[EAX]          // mascara
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // feunte
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM; --CS
   /*** el caracter de relleno debe ser colocado al principio de mask. ejemplo:
        mask(var " ###-###-###") -> caracter de relleno: espacio.
        mask(var ".######-###")  -> caracter de relleno: punto.
        ***/
    DX:=substr(AX,1,1)
    AX:=substr(AX,2,len(AX))
    IF VALTYPE(BX)=="C"
       stk_var_02[CWM]:=XFUNMASK(BX, AX, DX)
    ELSE
       IF FUNGETDIMS(EBX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMASK(BX, AX, DX, {DIM1,DIM1R,DIM1C,DIM1P,DIM1B})
          IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("MASK/NOT ENOUGHT MEMORY TO ALLOCATE",OP_CODE,CP)
          END
          ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MASK/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
    
/******************************************************************
                  FAM. OPERACIONES XUFUNC (XU_CODE)
*******************************************************************/
  
  FUNCTION FUNFSHELL()    // 148 X<-FCMD
  LOCAL EAX,AX,BX,DX,EX
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX] 
    CWM:=CMPCWM(EAX,CWM,TopCWM)

    EX:=alltrim(str(random(1000000000)))
    // prepara respuesta
    BX:=PATH_LOG+_fileSeparator+"XU_"+EX 
    // amra el .BAT
    AX:=AX+" > "+BX+".tmp"
    DX:=FCREATE (BX+".sh")
     FWRITE (DX,"#!/bin/bash"+_CR)
     FWRITE (DX,AX+_CR)
     FWRITE (DX,"echo 1 > "+PATH_LOG+_fileSeparator+"XUANS_"+EX+".log"+_CR)
    FCLOSE (DX)
    //__RUN("chmod 755 "+BX+".sh")
    RX:=CMDSYSTEM("chmod 755 "+BX+".sh")

    // Ejecuta el Batch
    //__RUN (BX+".sh")
    RX:=CMDSYSTEM(BX+".sh </dev/null >/dev/null 2>&1")
    while !file(PATH_LOG+_fileSeparator+"XUANS_"+EX+".log")
       ;
    end
    CX:=MEMOREAD(BX+".tmp")
    if empty(CX)
       CX:=""
    end
    if SW_CLEAR_LOG
       FERASE (BX+".sh")
       FERASE (BX+".tmp")
       FERASE (PATH_LOG+_fileSeparator+"XUANS_"+EX+".log")
    end
    stk_var_02[++CWM]:=CX
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSHELL()    // 149 CMD
  LOCAL EAX,AX,BX,CX,DX,EX,RX
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX] 
    CWM:=CMPCWM(EAX,CWM,TopCWM)

    --CS

    RX:=CMDSYSTEM(AX)

  RETURN funflush()
  
  FUNCTION FUNJOIN()     // 140
  LOCAL EBX,EDX,CX,EHX,EIX,EJX,EKX,ETX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP
  LOCAL OP_CODE:=1400
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       RETURN _FUNPUTERROR("JOIN/FLAG ERROR OR MISSING",OP_CODE,CP)
    else   // Analiza el flag T|D|N[<token>]. ejemplo: flag "T\n"
       if LEN(FVWITH)>=2
           ETX:=SUBSTR(FVWITH,1,1)
           FVWITH:=SUBSTR(FVWITH,2,LEN(FVWITH))
       else  // va sin token!!
           if FVWITH!="T".and.FVWITH!="D"
               RETURN _FUNPUTERROR("JOIN/FLAG ERROR TOKEN NOT RECOGNIZED",OP_CODE+1,CP)
           end
           ETX:=FVWITH
           FVWITH:=""
       end
    end
    EBX:=STACK[CS]
    CWM:=CMPCWM(EBX,CWM,TopCWM)

    ++CWM
    
    IF FUNGETDIMS(EBX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
       FUENTE := stk_var_02[EBX]
       CX:=""
       if DIM==1  // no importa el tipo de unión: todo va a una linea
          for EHX:=1 to DIMR-1
             CX:=CX+FUENTE[EHX]+FVWITH
          end
          CX:=CX+FUENTE[DIMR]
       else
          if ETX=="T" // une TODO en una sola línea.
             if DIM==2
                   for EHX:=1 to DIMR; for EIX:=1 to DIMC-1
                      CX:=CX+FUENTE[EHX][EIX]+FVWITH
                   end
                   CX:=CX+FUENTE[EHX][DIMC]
                   if EHX<DIMR
                      CX:=CX+FVWITH
                   end
                   end
             elseif DIM==3
                for EJX:=1 to DIMP; for EHX:=1 to DIMR; for EIX:=1 to DIMC-1
                   CX:=CX+FUENTE[EHX][EIX][EJX]+FVWITH
                end
                CX:=CX+FUENTE[EHX][DIMC][EJX]
                if EJX<DIMP
                   CX:=CX+FVWITH
                end
                end; end 
                
             else
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR; for EIX:=1 to DIMC-1
                   CX:=CX+FUENTE[EHX][EIX][EJX][EKX]+FVWITH
                end
                CX:=CX+FUENTE[EHX][DIMC][EJX][EKX] 
                if EKX<DIMB
                   CX:=CX+FVWITH
                end
                end; end; end
                
             end
          elseif ETX=="D"   // Documenta la matriz en un string con saltos de linea.
             if DIM==2
                IF DIMR<=DIMC
                for EHX:=1 to DIMR; for EIX:=1 to DIMC-1
                   CX:=CX+FUENTE[EHX][EIX]+FVWITH
                end; CX:=CX+FUENTE[EHX][DIMC]+_CR; end
                ELSE
                for EIX:=1 to DIMC-1; for EHX:=1 to DIMR
                   CX:=CX+FUENTE[EHX][EIX]+FVWITH
                end; CX:=CX+FUENTE[EHX][DIMC]+_CR; end
                END
             elseif DIM==3
                IF DIMR<=DIMC
                for EJX:=1 to DIMP; for EHX:=1 to DIMR; for EIX:=1 to DIMC-1
                   CX:=CX+FUENTE[EHX][EIX][EJX]+FVWITH
                end; CX:=CX+FUENTE[EHX][DIMC][EJX]+_CR; end; end
                ELSE
                for EJX:=1 to DIMP; for EIX:=1 to DIMC-1; for EHX:=1 to DIMR
                   CX:=CX+FUENTE[EHX][EIX][EJX]+FVWITH
                end; CX:=CX+FUENTE[EHX][DIMC][EJX]+_CR; end; end
                END
             else
                IF DIMR<=DIMC
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EHX:=1 to DIMR; for EIX:=1 to DIMC-1
                   CX:=CX+FUENTE[EHX][EIX][EJX][EKX]+FVWITH
                end; CX:=CX+FUENTE[EHX][DIMC][EJX][EKX]+_CR; end; end; end
                ELSE
                for EKX:=1 to DIMB; for EJX:=1 to DIMP; for EIX:=1 to DIMC-1; for EHX:=1 to DIMR
                   CX:=CX+FUENTE[EHX][EIX][EJX][EKX]+FVWITH
                end; CX:=CX+FUENTE[EHX][DIMC][EJX][EKX]+_CR; end; end; end
                END
             end
          end
       end
    else
       CX:=FVWITH
    end  
    stk_var_02[CWM]:=CX
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNSHOW()     // 84
  LOCAL EAX,AX,EBX,BX,EDX,EVX,EHX,EIX,EJX,EKX,ENX,DX,SX,EX,FX,OX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,FVWITH,TYP,TYPENUM
  LOCAL OP_CODE:=840
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]        // COLUMNAS
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]        // stack
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS -= 2
    FVWITH := ","   // por defecto
    TYPENUM:={"NAN","INF"}
    IF FUNGETDIMS(EBX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)  
    if DIM==1  // es una dimension 
       if DIMR>0
          EVX:=valtype(stk_var_02[EBX][1])
          if EVX=="L"
             
             IF SW_FHNDLOUT==1
                OX:=_CR+padl("1",5)+" : "+iif(stk_var_02[EBX][1],CONTEXT_TRUE,CONTEXT_FALSE)
                fwrite (FHNDLOUT,OX,len(OX))
                for EHX:=2 to DIMR
                   OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+iif(stk_var_02[EBX][EHX],CONTEXT_TRUE,CONTEXT_FALSE)
                   fwrite (FHNDLOUT,OX,len(OX))
                end
             ELSE
                outstd(_CR+padl("1",5)+" : "+iif(stk_var_02[EBX][1],CONTEXT_TRUE,CONTEXT_FALSE))
                for EHX:=2 to DIMR
                   outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+iif(stk_var_02[EBX][EHX],CONTEXT_TRUE,CONTEXT_FALSE))
                end
             END
          elseif EVX=="N"
             DX:=stk_var_02[EBX][1]
             FX:=XU_TYPENUM(DX)
             IF SW_FHNDLOUT==1
                if FX==0
                   if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                      OX:=_CR+padl("1",5)+" : "+D2E(DX,XUPRECISION) 
                   else
                      OX:=_CR+padl("1",5)+" : "+XFUNNUM2STRING(DX,XUPRECISION)
                   end
                else
                   OX:=_CR+padl("1",5)+" : "+TYPENUM[FX]
                end
                fwrite (FHNDLOUT,OX,len(OX))
             
                for EHX:=2 to DIMR
                   DX:=stk_var_02[EBX][EHX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION)
                      else
                         OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION)
                      end
                   else
                      OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX]
                   end
                   fwrite (FHNDLOUT,OX,len(OX))
                end
             ELSE
                if FX==0
                   if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                      outstd( _CR+padl("1",5)+" : "+D2E(DX,XUPRECISION) )
                   else
                      outstd( _CR+padl("1",5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                   end
                else
                   outstd( _CR+padl("1",5)+" : "+TYPENUM[FX])
                end
          //      outstd(_CR+padl("1",5)+" : "+ EX )
             
                for EHX:=2 to DIMR
                   DX:=stk_var_02[EBX][EHX]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION) )
                      else
                         outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX])
                   end
                   //////outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX],XUPRECISION),str(stk_var_02[EBX][EHX])))
                end
             END
          else
             IF SW_FHNDLOUT==1
                OX:=_CR+padl("1",5)+" : "+ stk_var_02[EBX][1]
                fwrite (FHNDLOUT,OX,len(OX))
                for EHX:=2 to DIMR
                   OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX]
                   fwrite (FHNDLOUT,OX,len(OX))
                end
             ELSE
                outstd(_CR+padl("1",5)+" : "+ stk_var_02[EBX][1])
                for EHX:=2 to DIMR
                   outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX])
                end
             END
          end
       else
          IF SW_FHNDLOUT==1
             fwrite (FHNDLOUT,"[]",2)
          ELSE
             outstd("[]")
          END
       end
    elseif DIM==2  // es bidimensional
       if DIMR>0 .and. DIMC>0
          EVX:=valtype(stk_var_02[EBX][1][1])
          if EVX=="L"
             IF SW_FHNDLOUT==1
                for EHX:=1 to DIMR
                   OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+ iif(stk_var_02[EBX][EHX][1],CONTEXT_TRUE,CONTEXT_FALSE)
                   fwrite (FHNDLOUT,OX,len(OX))
                   EJX:=0
                   for EIX:=2 to DIMC
                      if ++EJX==AX
                         OX:=_CR+"        "+ iif(stk_var_02[EBX][EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE)
                         EJX:=0
                      else
                         OX:=FVWITH+iif(stk_var_02[EBX][EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE)
                      end
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                end
             ELSE
                for EHX:=1 to DIMR
                   outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+ iif(stk_var_02[EBX][EHX][1],CONTEXT_TRUE,CONTEXT_FALSE))
                   EJX:=0
                   for EIX:=2 to DIMC
                      if ++EJX==AX
                         outstd(_CR+"        "+ iif(stk_var_02[EBX][EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE))
                         EJX:=0
                      else
                         outstd( FVWITH+iif(stk_var_02[EBX][EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE))
                      end
                   end
                end
             END
          elseif EVX=="N"
             IF SW_FHNDLOUT==1
                for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION)
                      else
                         OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION)   //alltrim(str(DX) )
                      end
                   else
                      OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX]   
                   end
                   fwrite (FHNDLOUT,OX,len(OX))
                   
                   EJX:=0
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX]
                      if ++EJX==AX 
                         FX:=XU_TYPENUM(DX)
                         if FX==0
                            if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                               OX:=_CR+"        "+D2E(DX,XUPRECISION)
                            else
                               OX:=_CR+"        "+XFUNNUM2STRING(DX,XUPRECISION)
                            end
                         else
                            OX:=_CR+"        "+TYPENUM[FX]
                         end
                         fwrite (FHNDLOUT,OX,len(OX))
                         EJX:=0
                      else
                         FX:=XU_TYPENUM(DX)
                         if FX==0
                            if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                               OX:=FVWITH+D2E(DX,XUPRECISION)
                            else
                               OX:=FVWITH+XFUNNUM2STRING(DX,XUPRECISION)
                            end
                         else
                            OX:=FVWITH+TYPENUM[FX]
                         end
                         fwrite (FHNDLOUT,OX,len(OX))
                      end
                   end
                end
             ELSE
                for EHX:=1 to DIMR
                   DX:=stk_var_02[EBX][EHX][1]
                   FX:=XU_TYPENUM(DX)
                   if FX==0
                      if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                         outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION) )
                      else
                         outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                      end
                   else
                      outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX])
                   end
                   //////outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][1],XUPRECISION),str(stk_var_02[EBX][EHX][1])))
                   EJX:=0
                   for EIX:=2 to DIMC
                      DX:=stk_var_02[EBX][EHX][EIX]
                      if ++EJX==AX 
                         FX:=XU_TYPENUM(DX)
                         if FX==0
                            if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                               outstd( _CR+"        "+D2E(DX,XUPRECISION) )
                            else
                               outstd( _CR+"        "+XFUNNUM2STRING(DX,XUPRECISION) )
                            end
                         else
                            outstd( _CR+"        "+TYPENUM[FX])
                         end
                         //////outstd(_CR+"        "+ iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX],XUPRECISION),str(stk_var_02[EBX][EHX][EIX])))
                         EJX:=0
                      else
                         FX:=XU_TYPENUM(DX)
                         if FX==0
                            if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                               outstd( FVWITH+D2E(DX,XUPRECISION) )
                            else
                               outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                            end
                         else
                            outstd( FVWITH+TYPENUM[FX])
                         end
                         //////outstd( FVWITH+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX],XUPRECISION),str(stk_var_02[EBX][EHX][EIX])))
                      end
                   end
                end
             END
          else
             IF SW_FHNDLOUT==1
                for EHX:=1 to DIMR
                   OX:=_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX][1]
                   fwrite (FHNDLOUT,OX,len(OX))
                   EJX:=0
                   for EIX:=2 to DIMC
                      if ++EJX==AX  
                         OX:=_CR+"        "+ stk_var_02[EBX][EHX][EIX]
                         EJX:=0
                      else
                         OX:=FVWITH+stk_var_02[EBX][EHX][EIX]
                      end
                      fwrite (FHNDLOUT,OX,len(OX))
                   end
                end
             ELSE
                for EHX:=1 to DIMR
                   outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX][1])
                   EJX:=0
                   for EIX:=2 to DIMC
                      if ++EJX==AX  
                         outstd(_CR+"        "+ stk_var_02[EBX][EHX][EIX])
                         EJX:=0
                      else
                         outstd( FVWITH+stk_var_02[EBX][EHX][EIX])
                      end
                   end
                end
             END
          end
       else
          IF SW_FHNDLOUT==1
             fwrite (FHNDLOUT,"[]",2)
          ELSE
             outstd("[]")
          END
       end
    elseif DIM==3  // es tridimensional
       if DIMR>0.and.DIMC>0.and.DIMP>0
          EVX:=valtype(stk_var_02[EBX][1][1][1])
          if EVX=="L"
             IF SW_FHNDLOUT==1
                for EJX:=1 to DIMP
                   OX:="PAGE "+padl(alltrim(str(EJX)),3)+":"
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EHX:=1 to DIMR
                      OX:=(_CR+padl(alltrim(str(EHX)),5)+" : "+ iif(stk_var_02[EBX][EHX][1][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                      fwrite (FHNDLOUT,OX,len(OX))
                      ENX:=0
                      for EIX:=2 to DIMC
                         if ++ENX==AX
                            OX:=(_CR+"        "+ iif(stk_var_02[EBX][EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                            ENX:=0
                         else
                            OX:=( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                         end
                         fwrite (FHNDLOUT,OX,len(OX))
                      end
                   end
                   fwrite (FHNDLOUT,_CR+_CR,len(_CR+_CR))
                end
             ELSE
                for EJX:=1 to DIMP
                   outstd("PAGE "+padl(alltrim(str(EJX)),3)+":")
                   for EHX:=1 to DIMR
                      outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+ iif(stk_var_02[EBX][EHX][1][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                      ENX:=0
                      for EIX:=2 to DIMC
                         if ++ENX==AX
                            outstd(_CR+"        "+ iif(stk_var_02[EBX][EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                            ENX:=0
                         else
                            outstd( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE))
                         end
                      end
                   end
                   outstd(_CR+_CR)
                end
             END
          elseif EVX=="N"
             IF SW_FHNDLOUT==1
                for EJX:=1 to DIMP
                   OX:=("PAGE "+padl(alltrim(str(EJX)),3)+":")
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EHX:=1 to DIMR
                      DX:=stk_var_02[EBX][EHX][1][EJX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            OX:=( _CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION) )
                         else
                            OX:=( _CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                         end
                      else
                         OX:=( _CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX])
                      end
                      fwrite (FHNDLOUT,OX,len(OX))
                      ENX:=0
                      for EIX:=2 to DIMC
                         DX:=stk_var_02[EBX][EHX][EIX][EJX]
                         if ++ENX==AX
                            FX:=XU_TYPENUM(DX)
                            if FX==0
                               if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                  OX:=( _CR+"        "+D2E(DX,XUPRECISION) )
                               else
                                  OX:=( _CR+"        "+XFUNNUM2STRING(DX,XUPRECISION) )
                               end
                            else
                               OX:=( _CR+"        "+TYPENUM[FX])
                            end
                            fwrite (FHNDLOUT,OX,len(OX))
                            ENX:=0
                         else
                            FX:=XU_TYPENUM(DX)
                            if FX==0
                               if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                  OX:=( FVWITH+D2E(DX,XUPRECISION) )
                               else
                                  OX:=( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                               end
                            else
                               OX:=( FVWITH+TYPENUM[FX])
                            end
                            fwrite (FHNDLOUT,OX,len(OX))
                         end
                      end
                   end
                   fwrite (FHNDLOUT,_CR+_CR,len(_CR+_CR))
                end
             ELSE
                for EJX:=1 to DIMP
                   outstd("PAGE "+padl(alltrim(str(EJX)),3)+":")
                   for EHX:=1 to DIMR
                      DX:=stk_var_02[EBX][EHX][1][EJX]
                      FX:=XU_TYPENUM(DX)
                      if FX==0
                         if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                            outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION) )
                         else
                            outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                         end
                      else
                         outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX])
                      end
                      //////outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][1][EJX],XUPRECISION),str(stk_var_02[EBX][EHX][1][EJX])))
                      ENX:=0
                      for EIX:=2 to DIMC
                         DX:=stk_var_02[EBX][EHX][EIX][EJX]
                         if ++ENX==AX
                            FX:=XU_TYPENUM(DX)
                            if FX==0
                               if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                  outstd( _CR+"        "+D2E(DX,XUPRECISION) )
                               else
                                  outstd( _CR+"        "+XFUNNUM2STRING(DX,XUPRECISION) )
                               end
                            else
                               outstd( _CR+"        "+TYPENUM[FX])
                            end
                            //////outstd(_CR+"        "+ iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX][EJX],XUPRECISION),str(stk_var_02[EBX][EHX][EIX][EJX])))
                            ENX:=0
                         else
                            FX:=XU_TYPENUM(DX)
                            if FX==0
                               if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                  outstd( FVWITH+D2E(DX,XUPRECISION) )
                               else
                                  outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                               end
                            else
                               outstd( FVWITH+TYPENUM[FX])
                            end
                         end
                      end
                   end
                   outstd(_CR+_CR)
                end
             END
          else
             IF SW_FHNDLOUT==1
                for EJX:=1 to DIMP
                   OX:=("PAGE "+padl(alltrim(str(EJX)),3)+":")
                   fwrite (FHNDLOUT,OX,len(OX))
                   for EHX:=1 to DIMR
                      OX:=(_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX][1][EJX])
                      fwrite (FHNDLOUT,OX,len(OX))
                      ENX:=0
                      for EIX:=2 to DIMC
                         if ++ENX==AX
                            OX:=(_CR+"        "+ stk_var_02[EBX][EHX][EIX][EJX])
                            ENX:=0
                         else
                            OX:=( FVWITH+stk_var_02[EBX][EHX][EIX][EJX])
                         end
                         fwrite (FHNDLOUT,OX,len(OX))
                      end
                   end
                   fwrite (FHNDLOUT,_CR+_CR,len(_CR+_CR))
                end
             ELSE
                for EJX:=1 to DIMP
                   outstd("PAGE "+padl(alltrim(str(EJX)),3)+":")
                   for EHX:=1 to DIMR
                      outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX][1][EJX])
                      ENX:=0
                      for EIX:=2 to DIMC
                         if ++ENX==AX
                            outstd(_CR+"        "+ stk_var_02[EBX][EHX][EIX][EJX])
                            ENX:=0
                         else
                            outstd( FVWITH+stk_var_02[EBX][EHX][EIX][EJX])
                         end
                      end
                   end
                   outstd(_CR+_CR)
                end
             END
          end
       else
          IF SW_FHNDLOUT==1
             fwrite (FHNDLOUT,"[]",2)
          ELSE
             outstd("[]")
          END
       end
    elseif DIM==4  // es cuatridimensional
       if DIMR>0.and.DIMC>0.and.DIMP>0.and.DIMB>0
          EVX:=valtype(stk_var_02[EBX][1][1][1][1])
          if EVX=="L"
             IF SW_FHNDLOUT==1
                for EKX:=1 to DIMB
                   for EJX:=1 to DIMP
                      OX:=("BLOCK "+padl(alltrim(str(EKX)),3)+"; PAGE "+padl(alltrim(str(EJX)),3)+":")
                      fwrite (FHNDLOUT,OX,len(OX))
                      for EHX:=1 to DIMR
                         OX:=(_CR+padl(alltrim(str(EHX)),5)+" : "+ iif(stk_var_02[EBX][EHX][1][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                         fwrite (FHNDLOUT,OX,len(OX))
                         ENX:=0
                         for EIX:=2 to DIMC
                            if ++ENX==AX
                               OX:=(_CR+"        "+ iif(stk_var_02[EBX][EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                               ENX:=0
                            else
                               OX:=( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                            end
                            fwrite (FHNDLOUT,OX,len(OX))
                         end
                      end
                      fwrite (FHNDLOUT,_CR+_CR,len(_CR+_CR))
                   end
                end
             ELSE
                for EKX:=1 to DIMB
                   for EJX:=1 to DIMP
                      outstd("BLOCK "+padl(alltrim(str(EKX)),3)+"; PAGE "+padl(alltrim(str(EJX)),3)+":")
                      for EHX:=1 to DIMR
                         outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+ iif(stk_var_02[EBX][EHX][1][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                         ENX:=0
                         for EIX:=2 to DIMC
                            if ++ENX==AX
                               outstd(_CR+"        "+ iif(stk_var_02[EBX][EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                               ENX:=0
                            else
                               outstd( FVWITH+iif(stk_var_02[EBX][EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE))
                            end
                         end
                      end
                      outstd(_CR+_CR)
                   end
                end
             END
          elseif EVX=="N"
             IF SW_FHNDLOUT==1
                for EKX:=1 to DIMB
                   for EJX:=1 to DIMP
                      OX:=("BLOCK "+padl(alltrim(str(EKX)),3)+"; PAGE "+padl(alltrim(str(EJX)),3)+":")
                      fwrite (FHNDLOUT,OX,len(OX))
                      for EHX:=1 to DIMR
                         DX:=stk_var_02[EBX][EHX][1][EJX][EKX]
                         FX:=XU_TYPENUM(DX)
                         if FX==0
                            if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                               OX:=( _CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION) )
                            else
                               OX:=( _CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                            end
                         else
                            OX:=( _CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX])
                         end
                         fwrite (FHNDLOUT,OX,len(OX))
                         ENX:=0
                         for EIX:=2 to DIMC
                            DX:=stk_var_02[EBX][EHX][EIX][EJX][EKX]
                            if ++ENX==AX
                               FX:=XU_TYPENUM(DX)
                               if FX==0
                                  if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                     OX:=( _CR+"        "+D2E(DX,XUPRECISION) )
                                  else
                                     OX:=( _CR+"        "+XFUNNUM2STRING(DX,XUPRECISION) )
                                  end
                               else
                                  OX:=( _CR+"        "+TYPENUM[FX])
                               end
                               fwrite (FHNDLOUT,OX,len(OX))
                               ENX:=0
                            else
                               FX:=XU_TYPENUM(DX)
                               if FX==0
                                  if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                     OX:=( FVWITH+D2E(DX,XUPRECISION) )
                                  else
                                     OX:=( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                                  end
                               else
                                  OX:=( FVWITH+TYPENUM[FX])
                               end
                               fwrite (FHNDLOUT,OX,len(OX))
                            end
                         end
                      end
                      fwrite (FHNDLOUT,_CR+_CR,len(_CR+_CR))
                   end
                end
             ELSE
                for EKX:=1 to DIMB
                   for EJX:=1 to DIMP
                      outstd("BLOCK "+padl(alltrim(str(EKX)),3)+"; PAGE "+padl(alltrim(str(EJX)),3)+":")
                      for EHX:=1 to DIMR
                         DX:=stk_var_02[EBX][EHX][1][EJX][EKX]
                         FX:=XU_TYPENUM(DX)
                         if FX==0
                            if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                               outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+D2E(DX,XUPRECISION) )
                            else
                               outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+XFUNNUM2STRING(DX,XUPRECISION) )
                            end
                         else
                            outstd( _CR+padl(alltrim(str(EHX)),5)+" : "+TYPENUM[FX])
                         end
                         //////outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][1][EJX][EKX],XUPRECISION),str(stk_var_02[EBX][EHX][1][EJX][EKX])))
                         ENX:=0
                         for EIX:=2 to DIMC
                            DX:=stk_var_02[EBX][EHX][EIX][EJX][EKX]
                            if ++ENX==AX
                               FX:=XU_TYPENUM(DX)
                               if FX==0
                                  if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                     outstd( _CR+"        "+D2E(DX,XUPRECISION) )
                                  else
                                     outstd( _CR+"        "+XFUNNUM2STRING(DX,XUPRECISION) )
                                  end
                               else
                                  outstd( _CR+"        "+TYPENUM[FX])
                               end
                               //////outstd(_CR+"        "+ iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX][EJX][EKX],XUPRECISION),str(stk_var_02[EBX][EHX][EIX][EJX][EKX])))
                               ENX:=0
                            else
                               FX:=XU_TYPENUM(DX)
                               if FX==0
                                  if CONTEXT_NUMBER=="E" .or. ABS(DX)>XINFINITY().or. (ABS(DX)>0.and.ABS(DX)<0.0000000000000001)
                                     outstd( FVWITH+D2E(DX,XUPRECISION) )
                                  else
                                     outstd( FVWITH+XFUNNUM2STRING(DX,XUPRECISION) )
                                  end
                               else
                                  outstd( FVWITH+TYPENUM[FX])
                               end
                               //////outstd( FVWITH+iif(CONTEXT_NUMBER=="E",D2E(stk_var_02[EBX][EHX][EIX][EJX][EKX],XUPRECISION),str(stk_var_02[EBX][EHX][EIX][EJX][EKX])))
                            end
                         end
                      end
                      outstd(_CR+_CR)
                   end
                end
             END
          else
             IF SW_FHNDLOUT==1
                for EKX:=1 to DIMB
                   for EJX:=1 to DIMP
                      OX:=("BLOCK "+padl(alltrim(str(EKX)),3)+"; PAGE "+padl(alltrim(str(EJX)),3)+":")
                      fwrite (FHNDLOUT,OX,len(OX))
                      for EHX:=1 to DIMR
                         OX:=(_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX][1][EJX][EKX])
                         fwrite (FHNDLOUT,OX,len(OX))
                         ENX:=0
                         for EIX:=2 to DIMC
                            if ++ENX==AX
                               OX:=(_CR+"        "+ stk_var_02[EBX][EHX][EIX][EJX][EKX])
                               ENX:=0
                            else
                               OX:=( FVWITH+stk_var_02[EBX][EHX][EIX][EJX][EKX])
                            end
                            fwrite (FHNDLOUT,OX,len(OX))
                         end
                      end
                      fwrite (FHNDLOUT,_CR+_CR,len(_CR+_CR))
                   end
                end
             ELSE
                for EKX:=1 to DIMB
                   for EJX:=1 to DIMP
                      outstd("BLOCK "+padl(alltrim(str(EKX)),3)+"; PAGE "+padl(alltrim(str(EJX)),3)+":")
                      for EHX:=1 to DIMR
                         outstd(_CR+padl(alltrim(str(EHX)),5)+" : "+stk_var_02[EBX][EHX][1][EJX][EKX])
                         ENX:=0
                         for EIX:=2 to DIMC
                            if ++ENX==AX
                               outstd(_CR+"        "+ stk_var_02[EBX][EHX][EIX][EJX][EKX])
                               ENX:=0
                            else
                               outstd( FVWITH+stk_var_02[EBX][EHX][EIX][EJX][EKX])
                            end
                         end
                      end
                      outstd(_CR+_CR)
                   end
                end
             END
          end
       else
          IF SW_FHNDLOUT==1
             fwrite (FHNDLOUT,"[]",2)
          ELSE
             outstd("[]")
          END
       end
    end
    ELSE
       RETURN _FUNPUTERROR("SHOW/MATRIX NOT INITIALIZED",OP_CODE+1,CP)
    END
  RETURN .T.
    
  FUNCTION FUNCONTEXT()   // 85
  LOCAL EAX,AX
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]   // valor contexto 
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
    AX:=UPPER(AX)
    SWITCH AX
    CASE "ROBOT"
       CONTEXT_TRUE:="ON"
       CONTEXT_FALSE:="OFF"
       EXIT
    CASE "BOOL"
       CONTEXT_TRUE:="1"
       CONTEXT_FALSE:="0"
       EXIT 
    CASE "HUMAN"    
       CONTEXT_TRUE:="YES"
       CONTEXT_FALSE:="NO"
       EXIT
    CASE "LOGIC"
       CONTEXT_TRUE:="TRUE"
       CONTEXT_FALSE:="FALSE"
       EXIT
    CASE "NOTATION"
       CONTEXT_NUMBER:="E"
       EXIT
    CASE "NUMBER"
       CONTEXT_NUMBER:="N"   
       EXIT
    end
  RETURN .T.
     

/******************************************************************
                  FUNCIONES INTERNAS DEL LENGUAJE
*******************************************************************/ 
FUNCTION FUNJMP()    // 23
  CP:=STACK[CS]-DIR-1      // -1 por el ajuste del ++CP
  --CS
RETURN .T.

FUNCTION FUNJUDF()   // 42
  CP:=STACK[CS]-DIR-1      // -1 por el ajuste del ++CP
  --CS
RETURN .T.

FUNCTION FUNJNT()   // 13
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

 // ? "EBX=",EBX," BX=",BX
  if !BX      // Si no es verdad?
     CP:=STACK[CS]-DIR-1             // Salta xuxetumadre!!!
  end
  CS-=2 
RETURN .T.


FUNCTION FUNBRKZ()   // 36
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX==0                         // si es CERO
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.

FUNCTION FUNBRKNZ()   // 76
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX!=0                         // si no es CERO
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.


FUNCTION FUNBRKGEZ()   // 189
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX>=0                         // si es mayor o igual que CERO
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.

FUNCTION FUNBRKLEZ()   // 188
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX<=0                         // si es menor o igual que CERO
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.

FUNCTION FUNBRKLZ()   // 187
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX<0                         // si es menor que CERO
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.

FUNCTION FUNBRKGZ()   // 186
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX>0                         // si  es mayor que CERO
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.

FUNCTION FUNJT()   // 10
LOCAL EBX,BX
  EBX:=STACK[CS-1]
  BX:=stk_var_02[EBX]   // variable
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  if BX                         // si es verdad?
     CP:=STACK[CS]-DIR-1              // Salta peo!!!
  end
  CS-=2 
RETURN .T.

FUNCTION FUNEVALUATE()   // 50
LOCAL EAX,EBX
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)

  stk_var_02[EBX]:=stk_var_02[EAX]
  CS-=2
RETURN .T.


/******************************************************************
              OPERACIONES FAMILIA TFILE_CODE
*******************************************************************/
  FUNCTION FUNFSEEK()   // 89
  LOCAL EAX,AX,EBX,BX,ECX,CX,OP_CODE:=890
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]     // posicion relativa
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]   // desplazamiento
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]   // handler
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=3
    if CX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FSEEK/FILE NOT OPEN",OP_CODE,CP)
    else
      // if CS>0 
          stk_var_02[++CWM]:=FSEEK (CX,BX,AX)
          STACK[++CS] := CWM
      // else
      //    FSEEK (CX,BX,AX)
      // end
    end
  RETURN .T.

  
  FUNCTION FUNFWRITEL()    // 165
  LOCAL EAX,AX,EBX,BX
  LOCAL OP_CODE:=1650
    EBX:=STACK[CS]
    BX:=stk_var_02[EBX]     // handler
    EAX:=STACK[CS-1]
    AX:=stk_var_02[EAX]   // lo que graba
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CS-=2
    if AX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FWRITEL/FILE NOT OPEN",OP_CODE,CP)  
    else                 // cerrar el archivo
       // ESCRIBIR EN ARCHIVO A TRAVeS DE HANDLER
       if fwrite (AX,hb_STRtoutf8(BX)+_CR)==0
          RETURN _FUNPUTERROR("FWRITEL/WRITE FAILURE",OP_CODE,CP)  
       end
    end
  RETURN .T.
  
  FUNCTION FUNFREADL()   // 174
  LOCAL EAX,AX,BX,CX,DX,EX,VX,WX
  LOCAL nSavePos,nNumRead,nEol,ascVAL,cBUFF,tBUFF
  LOCAL OP_CODE:=1740,SW_SP:=.F.
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    
 /*   FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH=="C"
       if upper(FVWITH)=="SP"
          SW_SP:=.T.
       end
    end*/
    
    if AX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FREADL/FILE NOT OPEN",OP_CODE,CP)
    else                 // cerrar el archivo
       // MIENTRAS NO SEA C++, DEBO LEER HASTA chr(13)
       CX:=space(4096)
       BX:=""
       nSavePos := FSEEK( AX, 0, 1 )
     //  BX := rtrim(HB_UTF8TOSTR( freadstr (AX,4096) ))
       
       nNumRead := FREAD( AX, @CX, 4096 )       
       
       BX := substr( CX, 1, nNumRead )

       BX := SUBSTR( BX, 1, at(hb_osnewline(),BX))
       
       nEol:=len(BX)  // debe contar los caracteres especiales para el FSEEK
       
      /* normalizacion de caracteres especiales */
/*       if SW_SP
          DX:=""
          FOR EX:=1 to nEol
          CX:=SUBSTR(BX,EX,1)

          cBUFF:=asc(CX)
          ascVAL:=cBUFF
          if ascVAL==194 .or.ascVAL==195.or.ascVAL==207.or.ascVAL==198.or.ascVAL==197;
             .or. ascVAL==234 .or. ascVAL==180
             tBUFF:=CX:=SUBSTR(BX,++EX,1)
             CX:=hb_UTF8tostr(chr(cBUFF)+tBUFF)
          elseif ascVAL==226 .or. ascVAL==239
             tBUFF:=CX:=SUBSTR(BX,++EX,2)
             CX:=hb_UTF8tostr(chr(cBUFF)+tBUFF)
          elseif ascVAL==206
             tBUFF:=CX:=SUBSTR(BX,++EX,3)
             CX:=hb_UTF8tostr(chr(cBUFF)+tBUFF)
          else
             CX:=chr(cBUFF)
          end
          DX:=DX+CX
          NEXT
          BX:=DX
       end */ 
       BX := hb_utf8tostr(strtran(BX, hb_osnewline(),""))
       //BX := strtran(BX,chr(10),"")
       //BX := strtran(BX,chr(13),"") 

       FSEEK( AX, nSavePos + nEol, 0 )  // nEol + 1
       CX=""
       stk_var_02[++CWM]:=BX 
       STACK[CS] := CWM
    END
  RETURN .T.

  FUNCTION FUNFEOF()     // 173
  LOCAL EAX,AX
  LOCAL nSavePos,nFinalPos
  LOCAL OP_CODE:=1730
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    if AX<0 
       RETURN _FUNPUTERROR("FEOF/FILE NOT OPEN",OP_CODE,CP)
    else                 // cerrar el archivo
       nSavePos := FSEEK( AX, 0, 1 )  // pos actual
       nFinalPos := FSEEK( AX, 0, 2 )
       FSEEK( AX, nSavePos, 0)
      // ? nSavePos, nFinalPos ; inkey(0)
       stk_var_02[++CWM]:=iif(nSavePos>=nFinalPos,.T.,.F.)           //HB_FEOF(AX)
       STACK[CS] := CWM
    end
  RETURN .T.
  
  FUNCTION FUNFWRITES()     // 59
  LOCAL EAX,AX,EBX,BX
  LOCAL OP_CODE:=590
    EBX:=STACK[CS] 
    BX:=stk_var_02[EBX]     // handler
    EAX:=STACK[CS-1]
    AX:=stk_var_02[EAX]   // lo que graba
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CS-=2
    
    if AX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FWRITES/FILE NOT OPEN",OP_CODE,CP)
    else                 // LEER
       // ESCRIBIR EN ARCHIVO A TRAVeS DE HANDLER
       if fwrite (AX,hb_STRtoutf8(BX))==0
          RETURN _FUNPUTERROR("FWRITES/WRITE FAILURE",OP_CODE,CP)
       end
    end
  RETURN .T.
  
  FUNCTION FUNFWRITEB()    // 163
  LOCAL EAX,AX,EBX,BX,SWI,SWL
  LOCAL OP_CODE:=1630
    EBX:= STACK[CS]
    BX:=stk_var_02[EBX]     // handler
    EAX:=STACK[CS-1]
    AX:=stk_var_02[EAX]   // lo que graba
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CS-=2
  
  /* AÑADIR FLAG PARA TIPO DE ENTERO */
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    SWL:=.F.
    SWI:=.F.  // por defecto
    if FTWITH=="C"
       if upper(FVWITH)=="I"   // 16 bits con signo
          SWI:=.T.
//       elseif upper(FVWITH)=="W"
//          SWW:=.T.
       elseif upper(FVWITH)=="L"  // 32 bits con signo
          SWL:=.T.
//       elseif upper(FVWITH)=="U"
//          SWU:=.T.
       else
          SWI:=.T.  // por defecto
       end
    else
       SWI:=.T.
    end  
  /* hasta aquí */
    
    if AX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FWRITEB/FILE NOT OPEN",OP_CODE,CP)
    else                 // cerrar el archivo
       // ESCRIBIR EN ARCHIVO A TRAVeS DE HANDLER
       if SWI
          if fwrite (AX,I2BIN(BX),1)==0
          //if fwrite (AX,chr(BX),1)==0
             RETURN _FUNPUTERROR("FWRITEB/WRITE FAILURE",OP_CODE,CP)
          end
/*       elseif SWW
          if fwrite (AX,W2BIN(BX),2)==0
          //if fwrite (AX,chr(BX),1)==0
             RETURN _FUNPUTERROR("FWRITEB/WRITE FAILURE",OP_CODE,CP)
          end*/
       elseif SWL
          if fwrite (AX,L2BIN(BX))==0
          //if fwrite (AX,chr(BX),1)==0
             RETURN _FUNPUTERROR("FWRITEB/WRITE FAILURE",OP_CODE,CP)
          end
/*       elseif SWU
          if fwrite (AX,U2BIN(BX),4)==0
          //if fwrite (AX,chr(BX),1)==0
             RETURN _FUNPUTERROR("FWRITEB/WRITE FAILURE",OP_CODE,CP)
          end*/
       end
    end
  RETURN .T.
  
  FUNCTION FUNFREADB()   // 164
  LOCAL EAX,AX,SWI,SWL
  LOCAL OP_CODE:=1640
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]     // handler
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    
  /* AÑADIR FLAG PARA TIPO DE ENTERO */
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    SWL:=.F.
    SWI:=.F.  
    if FTWITH=="C"
       if upper(FVWITH)=="I"
          SWI:=.T.
//       elseif upper(FVWITH)=="W"
//          SWW:=.T.
       elseif upper(FVWITH)=="L"
          SWL:=.T.
//       elseif upper(FVWITH)=="U"
//          SWU:=.T.
       else
          SWI:=.T.  // por defecto
       end
    else
       SWI:=.T.
    end  
  /* hasta aquí */
  
    if AX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FREADB/FILE NOT OPEN",OP_CODE,CP)
    else                 // cerrar el archivo
       if SWI
          CX:=" "      // me aseguro de que tenga un espacio, porsi...
          fread(AX,@CX,1)
          stk_var_02[++CWM]:=BIN2I(CX)
       elseif SWL
          CX:="    "
          fread(AX,@CX,4)
          stk_var_02[++CWM]:=BIN2L(CX)
       end
       STACK[CS] := CWM
    end
  RETURN .T.
  
  FUNCTION FUNFREADS()   // 24
  LOCAL EAX,EBX,AX,BX,FX,CX,EX,DX,GX,SW_SP:=.F.
  LOCAL OP_CODE:=240,nEol
    EBX:=STACK[CS] 
    EAX:=STACK[CS-1]
    AX:=stk_var_02[EAX]     // handler
    FX:=stk_var_02[EBX]   // num. de caracteres
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CS-=2
    
/*    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH=="C"
       if upper(FVWITH)=="SP"
          SW_SP:=.T.
       end
    end*/

    if AX<0   // no hay archivo abierto
       RETURN _FUNPUTERROR("FREADS/FILE NOT OPEN",OP_CODE,CP)
    else                 // cerrar el archivo
       // MIENTRAS NO SEA C++, DEBO LEER HASTA chr(13)
       BX:=space(FX)
       BX:=hb_utf8tostr( freadstr (AX,FX) )
       
       stk_var_02[++CWM]:=BX 
       STACK[++CS] := CWM
    end
  RETURN .T.
  
  FUNCTION FUNFEXIST()   // 117
  LOCAL EAX
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    stk_var_02[++CWM]:=FILE(stk_var_02[EAX])
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNFLC()   // 201
  LOCAL EAX,AX,BX,CX,EX,DX
  LOCAL OP_CODE:=2010
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       SEP:=HB_OSNEWLINE()
    else
       SEP:=FVWITH
    end
    
    BX:=CUENTALINEAS(AX,SEP)
    
    stk_var_02[++CWM]:=BX
    FUNPUTDIMS(CWM,1,"N",5,0,0,0)
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNFCREATE()   // 37
  LOCAL EAX,AX,EBX,BX,CX,FX
  LOCAL OP_CODE:=370
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]   // la constante
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX] // el archivo
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS -= 2
    FX:=iif(_fileSeparator $ BX, BX,PATH_UTILITY+_fileSeparator+BX) 
    if (CX:=FCREATE(FX,AX)) < 0
       RETURN _FUNPUTERROR("FCREATE/FILE NOT CREATED (SUBCODE="+strzero(CX,4)+")",OP_CODE,CP)
    end
    FCLOSE(CX)
  RETURN .T.
  
  FUNCTION FUNFOPEN()   // 177
  LOCAL EAX,AX,ABX,BX,CX
  LOCAL OP_CODE:=1770
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]       // la constante
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]     // El nombre de archivo
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if _fileSeparator $ BX
       CX:=FOPEN(BX,AX)    // abrir
    else
       CX:=FOPEN(PATH_UTILITY+_fileSeparator+BX,AX)    // abrir
    end
    if FERROR()!=0
       RETURN _FUNPUTERROR("FOPEN("+BX+")/ (SUBCODE="+strzero(FERROR(),5)+")",OP_CODE,CP)
    end
    stk_var_02[++CWM]:=CX
    STACK[--CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNFCLOSE()    // 176
  LOCAL EAX,AX
  LOCAL OP_CODE:=1760
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
    if !FCLOSE(AX)
       RETURN _FUNPUTERROR("FCLOSE/FUCKING CLOSE FILE",OP_CODE,CP)
    end
  RETURN .T.

/******************************************************************
              OPERACIONES FAMILIA tcast_code
*******************************************************************/
  FUNCTION FUNCASTEO()    // 157
  LOCAL AX,EBX,BX,EAX,EFX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    EAX:=STACK[CS] 
    EBX:=STACK[CS-1]  // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM; --CS
    BX:=stk_var_02[EBX]
    AX:=stk_var_02[EAX]

    IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       TEMPORAL:=XCASTEO(AX,{DIM1,DIM1R,DIM1C,DIM1P,DIM1B,BX})
       /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:= TEMPORAL   ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    ELSE
       RETURN _FUNPUTERROR("CAST OPERATOR/MATRIX NOT INITIALIZED",OP_CODE,CP)
    END
    STACK[CS] := CWM
  RETURN .T.

/******************************************************************
              OPERACIONES FAMILIA XMETA_CODE
*******************************************************************/
  FUNCTION FUNMATCOMMON()    // 115
  LOCAL AX,EBX,BX
  LOCAL EAX
    EAX:=STACK[CS] 
    EBX:=STACK[CS-1]  // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM; --CS
  RETURN (__PMATCOM[stk_var_02[EBX]]:EXEC(EAX))
    
    FUNCTION FUNINT(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=INT(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,50,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          ////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.INT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNSQRT(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       IF AX >= 0
          stk_var_02[CWM]:=SQRT(AX)
       ELSE
          stk_var_02[CWM]:=-1  // ERROR OFICIAL DE SQRT EN XU
       END
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,21,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.SQRT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.

    
    FUNCTION FUNEXP(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=EXP(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,20,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.EXP/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


    FUNCTION FUNLOG(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       IF AX>0
          stk_var_02[CWM]:=LOG10(AX)
       ELSE
          RETURN _FUNPUTERROR("MTH.LOG/ARGUMENT COULD BE POSITIVE",OP_CODE,CP)
       END
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,8,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.LOG/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.

    FUNCTION FUNLN(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       IF AX>0
          stk_var_02[CWM]:=LOG(AX)
       ELSE
          RETURN _FUNPUTERROR("MTH.LN/ARGUMENT COULD BE POSITIVE",OP_CODE,CP)
       END
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,18,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.LN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.

    
    FUNCTION FUNABS(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=ABS(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,19,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.ABS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNSGN(EAX)
    LOCAL OP_CODE:=1150,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=SIGN(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ///////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,5,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.SGN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


  FUNCTION FUNTRIGCOMMON()   // 38  
  LOCAL EBX,BX
  LOCAL EAX
    EAX:=STACK[CS] 
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]   // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM
    --CS
  RETURN __PTRGCOM[BX]:EXEC(EAX)
  
    FUNCTION FUNSIN(EAX)    
    LOCAL OP_CODE:=380,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=SIN(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
         ////// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,0,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.SIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


    FUNCTION FUNCOS(EAX)
    LOCAL OP_CODE:=380,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=COS(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,1,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.COS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.

    
    FUNCTION FUNTAN(EAX)
    LOCAL OP_CODE:=380,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=TAN(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,2,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.TAN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


    FUNCTION FUND2R(EAX)
    LOCAL OP_CODE:=380,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XUDTOR(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,4,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.D2R/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


    FUNCTION FUNR2D(EAX)
    LOCAL OP_CODE:=380,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XURTOD(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ///////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,3,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.R2D/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNCOT(EAX)
    LOCAL OP_CODE:=380,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=COT(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,11,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.COT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    

  FUNCTION FUNMINMAX()   // 53
  LOCAL EBX,BX,ECX,CX
  LOCAL EAX
    EAX:=STACK[CS] 
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]   // valor argumento 2
    ECX:=STACK[CS-2]
    CX:=stk_var_02[ECX]   // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM
    if CX==1               // min
       stk_var_02[CWM]:=MIN(stk_var_02[EAX], BX)
    else                  // MAX
       stk_var_02[CWM]:=MAX(stk_var_02[EAX], BX)
    end
    CS -=2
    STACK[CS] := CWM
  RETURN .T.    
     
  FUNCTION FUNTMATHCODE()   // 113
  LOCAL EBX
  LOCAL EAX
    EAX:=STACK[CS] 
    EBX:=STACK[CS-1]  // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM; --CS
  RETURN (__PMATOTHER[stk_var_02[EBX]]:EXEC(EAX))
    
    FUNCTION FUNRND(EAX)
    LOCAL OP_CODE:=1130,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=HB_RANDOM()*AX //FT_RAND1(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMMLET(AX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,1)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          ///
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.RAND/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNCEIL(EAX)
    LOCAL OP_CODE:=1130,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XCEILING(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,7,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.CEIL/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


    FUNCTION FUNFLOOR(EAX)
    LOCAL OP_CODE:=1130,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XFLOOR(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ///////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,6,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.FLOOR/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.

    FUNCTION FUNCELSIUS(EAX)
    LOCAL OP_CODE:=1130,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XCELSIUS(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,9,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.CELS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.


    FUNCTION FUNFAHRENHEIT(EAX)
    LOCAL OP_CODE:=1130,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XFAHRENHEIT(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,10,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("MTH.FAHR/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.

    FUNCTION FUNDELTA(EAX)
      if VALTYPE(stk_var_02[EAX])=="A"
         RETURN _FUNPUTERROR("MTH.SETDELTA/ACCEPT A NUMBER, PLISSS",OP_CODE,CP)
      end
      DFLAG:=stk_var_02[EAX]
      --CWM; --CS
    RETURN .T.
     
  FUNCTION FUNTRIGESPECIAL()   // 33 
  LOCAL EBX,BX
  LOCAL EAX
    EAX:=STACK[CS] 
    EBX:=STACK[CS-1]
    BX:=stk_var_02[EBX]   // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM
    --CS
  RETURN __PTRGESP[BX]:EXEC(EAX)
         
    FUNCTION FUNASIN(EAX)
    LOCAL OP_CODE:=330,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=ASIN(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,12,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.ASIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNACOS(EAX)
    LOCAL OP_CODE:=330,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=ACOS(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,13,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.ACOS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNATAN(EAX)
    LOCAL OP_CODE:=330,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=ATAN(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
         ////// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,14,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.ATAN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
     
    FUNCTION FUNSINH(EAX)    
    LOCAL OP_CODE:=330,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=SINH(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
         /////// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,15,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.SINH/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNCOSH(EAX)
    LOCAL OP_CODE:=330,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=COSH(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,16,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.COSH/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNTANH(EAX)
    LOCAL OP_CODE:=330,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=TANH(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ///////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,17,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("TRG.TANH/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
    RETURN .T.
    

/*************************************************/

  FUNCTION FUNISANY()    // 27
  LOCAL EAX,AX,BX,EBX,EFX,EHX,EIX,EJX,EKX,OP_CODE:=270
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
    EBX:=STACK[CS]    // ESCALAR
    EAX:=STACK[CS-1]  // ARREGLO O MATRIZ
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)    
    ++CWM
    --CS
    BX:=stk_var_02[EBX]
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       if VALTYPE(BX)!="C"
          stk_var_02[CWM]:=(AX==BX)
       else
          stk_var_02[CWM]:=(AX+" "==BX+" ")
       end   
       STACK[CS] := CWM
       RETURN .T.
    else   // es array!
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          
          STACK[CS] := CWM
          SWITCH DIM1
          CASE 1
             if TYP1!="C"
                for EHX:=1 to DIM1R
                   if AX[EHX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end
             else
                for EHX:=1 to DIM1R
                   if AX[EHX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end
             end
             EXIT
          CASE 2
             if TYP1!="C"
                IF DIM1R<=DIM1C
                for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end
                ELSE
                for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end
                END
             else
                IF DIM1R<=DIM1C
                for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end
                ELSE
                for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end
                END
             end
             EXIT
          CASE 3
             if TYP1!="C"
                IF DIM1R<=DIM1C
                for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX][EJX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end
                ELSE
                for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX][EJX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end
                END
             else
                IF DIM1R<=DIM1C
                for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX][EJX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end
                ELSE
                for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX][EJX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end
                END
             end
             EXIT
          CASE 4
             if TYP1!="C"
                IF DIM1R<=DIM1C
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX][EJX][EKX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end; end
                ELSE
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX][EJX][EKX]==BX
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end; end
                END
             else
                IF DIM1R<=DIM1C
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX][EJX][EKX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end; end
                ELSE
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX][EJX][EKX]+" "==BX+" "
                      stk_var_02[CWM]:=.T.
                      RETURN .T.
                   end
                end; end; end; end
                END
             end
             EXIT
          END
       ELSE
          RETURN _FUNPUTERROR("ISANY/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    end
    stk_var_02[CWM]:=.F.
  RETURN .T.
  
  FUNCTION FUNNOTBIT()   // 136
    LOCAL OP_CODE:=1360,AX,EFX,EAX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    EAX:=STACK[CS] 
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="N"
       stk_var_02[CWM]:=XNUMNOT(AX)
    else
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=XNUMNOT(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=XNUMNOT(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=XNUMNOT(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=XNUMNOT(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=XNUMNOT(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMNOT(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMNOT(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("BIT.NOT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END   
    STACK[CS] := CWM 
  RETURN .T.


/******************************************************************
              OPERACIONES FAMILIA BIT_CODE
*******************************************************************/
FUNCTION BIT_CODE()   // 211
LOCAL EAX,EBX,ECX
  EAX:=STACK[CS]
  ECX:=STACK[CS-1]
  EBX:=STACK[CS-2]  // codigo de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CS -= 2
  ++CWM
RETURN __PBIT[stk_var_02[EBX]]:EXEC(EAX,ECX)
    
  FUNCTION FUNBITBIT(EAX,ECX)  // 1
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B,TEMPORAL
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=XGETBIT(CX,AX,1)
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.BIT/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.BIT/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.BIT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        SWITCH DIM
        CASE 1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XGETBIT(CX[EHX],AX[EHX],1)
           END
           EXIT
        CASE 2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XGETBIT(CX[EHX][EIX],AX[EHX][EIX],1)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XGETBIT(CX[EHX][EIX],AX[EHX][EIX],1)
           END; END
           END
           EXIT
        CASE 3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XGETBIT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX],1)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XGETBIT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX],1)
           END; END; END
           END
           EXIT
        CASE 4
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XGETBIT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX],1)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XGETBIT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX],1)
           END; END; END; END
           END
           EXIT
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        SWITCH DIM
        CASE 1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XGETBIT(CX[EHX],AX,1)
           END
           EXIT
        CASE 2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XGETBIT(CX[EHX][EIX],AX,1)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XGETBIT(CX[EHX][EIX],AX,1)
           END; END
           END
           EXIT
        CASE 3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XGETBIT(CX[EHX][EIX][EJX],AX,1)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XGETBIT(CX[EHX][EIX][EJX],AX,1)
           END; END; END
           END
           EXIT
        CASE 4
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XGETBIT(CX[EHX][EIX][EJX][EKX],AX,1)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XGETBIT(CX[EHX][EIX][EJX][EKX],AX,1)
           END; END; END; END
           END
           EXIT
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.BIT/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.


  FUNCTION FUNBITXOR(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=XNUMXOR(CX,AX)
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.XOR/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.XOR/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.XOR/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        SWITCH DIM
        CASE 1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XNUMXOR(CX[EHX],AX[EHX])
           END
           EXIT
        CASE 2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XNUMXOR(CX[EHX][EIX],AX[EHX][EIX])
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XNUMXOR(CX[EHX][EIX],AX[EHX][EIX])
           END; END
           END
           EXIT
        CASE 3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XNUMXOR(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XNUMXOR(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
           END; END; END
           END
           EXIT
        CASE 4
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMXOR(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMXOR(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
           END; END; END; END
           END
           EXIT
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        SWITCH DIM
        CASE 1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XNUMXOR(CX[EHX],AX)
           END
           EXIT
        CASE 2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XNUMXOR(CX[EHX][EIX],AX)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XNUMXOR(CX[EHX][EIX],AX)
           END; END
           END
           EXIT
        CASE 3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XNUMXOR(CX[EHX][EIX][EJX],AX)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XNUMXOR(CX[EHX][EIX][EJX],AX)
           END; END; END
           END
           EXIT
        CASE 4
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMXOR(CX[EHX][EIX][EJX][EKX],AX)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMXOR(CX[EHX][EIX][EJX][EKX],AX)
           END; END; END; END
           END
           EXIT
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.XOR/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBITAND(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=XNUMAND(CX,AX)
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.AND/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.AND/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.AND/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XNUMAND(CX[EHX],AX[EHX])
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XNUMAND(CX[EHX][EIX],AX[EHX][EIX])
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XNUMAND(CX[EHX][EIX],AX[EHX][EIX])
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XNUMAND(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XNUMAND(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMAND(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMAND(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
           END; END; END; END
           END
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XNUMAND(CX[EHX],AX)
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XNUMAND(CX[EHX][EIX],AX)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XNUMAND(CX[EHX][EIX],AX)
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XNUMAND(CX[EHX][EIX][EJX],AX)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XNUMAND(CX[EHX][EIX][EJX],AX)
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMAND(CX[EHX][EIX][EJX][EKX],AX)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMAND(CX[EHX][EIX][EJX][EKX],AX)
           END; END; END; END
           END       
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.AND/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.

  
  FUNCTION FUNBITSHL(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=HB_BITSHIFT(CX,ABS(AX))
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.SHL/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.SHL/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.SHL/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=HB_BITSHIFT(CX[EHX],ABS(AX[EHX]))
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX[EHX][EIX]))
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX[EHX][EIX]))
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX[EHX][EIX][EJX]))
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX[EHX][EIX][EJX]))
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX[EHX][EIX][EJX][EKX]))
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX[EHX][EIX][EJX][EKX]))
           END; END; END; END
           END
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=HB_BITSHIFT(CX[EHX],ABS(AX))
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX))
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX))
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX))
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX))
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX))
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX))
           END; END; END; END
           END
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.SHL/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.

  
  FUNCTION FUNBITSHR(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=HB_BITSHIFT(CX,ABS(AX)*(-1))
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.SHR/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.SHR/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.SHR/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=HB_BITSHIFT(CX[EHX],ABS(AX[EHX])*(-1))
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX[EHX][EIX])*(-1))
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX[EHX][EIX])*(-1))
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX[EHX][EIX][EJX])*(-1))
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX[EHX][EIX][EJX])*(-1))
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX[EHX][EIX][EJX][EKX])*(-1))
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX[EHX][EIX][EJX][EKX])*(-1))
           END; END; END; END
           END
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=HB_BITSHIFT(CX[EHX],ABS(AX)*(-1))
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX)*(-1))
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=HB_BITSHIFT(CX[EHX][EIX],ABS(AX)*(-1))
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX)*(-1))
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=HB_BITSHIFT(CX[EHX][EIX][EJX],ABS(AX)*(-1))
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX)*(-1))
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=HB_BITSHIFT(CX[EHX][EIX][EJX][EKX],ABS(AX)*(-1))
           END; END; END; END
           END  
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.SHR/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBITOFF(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=XCLEARBIT(CX,AX+1)
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.OFF/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.OFF/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.OFF/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XCLEARBIT(CX[EHX],AX[EHX]+1)
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XCLEARBIT(CX[EHX][EIX],AX[EHX][EIX]+1)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XCLEARBIT(CX[EHX][EIX],AX[EHX][EIX]+1)
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XCLEARBIT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX]+1)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XCLEARBIT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX]+1)
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XCLEARBIT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX]+1)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XCLEARBIT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX]+1)
           END; END; END; END
           END
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XCLEARBIT(CX[EHX],AX+1)
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XCLEARBIT(CX[EHX][EIX],AX+1)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XCLEARBIT(CX[EHX][EIX],AX+1)
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XCLEARBIT(CX[EHX][EIX][EJX],AX+1)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XCLEARBIT(CX[EHX][EIX][EJX],AX+1)
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XCLEARBIT(CX[EHX][EIX][EJX][EKX],AX+1)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XCLEARBIT(CX[EHX][EIX][EJX][EKX],AX+1)
           END; END; END; END
           END         
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.OFF/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBITON(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=XSETBIT(CX,AX+1)
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.ON/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.ON/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.ON/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end

        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XSETBIT(CX[EHX],AX[EHX]+1)
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XSETBIT(CX[EHX][EIX],AX[EHX][EIX]+1)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XSETBIT(CX[EHX][EIX],AX[EHX][EIX]+1)
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XSETBIT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX]+1)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XSETBIT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX]+1)
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XSETBIT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX]+1)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XSETBIT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX]+1)
           END; END; END; END
           END
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XSETBIT(CX[EHX],AX+1)
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XSETBIT(CX[EHX][EIX],AX+1)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XSETBIT(CX[EHX][EIX],AX+1)
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XSETBIT(CX[EHX][EIX][EJX],AX+1)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XSETBIT(CX[EHX][EIX][EJX],AX+1)
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XSETBIT(CX[EHX][EIX][EJX][EKX],AX+1)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XSETBIT(CX[EHX][EIX][EJX][EKX],AX+1)
           END; END; END; END
           END    
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.ON/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNBITOR(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EEX,EDX,OP_CODE:=2110
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  AX:=stk_var_02[EAX]
  CX:=stk_var_02[ECX]
  EVX:=VALTYPE(AX)
  EWX:=VALTYPE(CX)
  EEX:=EWX+EVX
  IF EEX=="NN"
     stk_var_02[CWM]:=XNUMOR(CX,AX)
  ELSE
     IF EVX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("BIT.OR/MATRIX NOT INITIALIZED",OP_CODE,CP) 
        END
     END
     IF EWX=="A"
        IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
           RETURN _FUNPUTERROR("BIT.OR/MATRIX NOT INITIALIZED",OP_CODE,CP)
        END
     END
     IF EEX=="AA"
        if DIM1!=DIM2.OR.DIM1R!=DIM2R.OR.DIM1C!=DIM2C.OR.DIM1P!=DIM2P.OR.DIM1B!=DIM2B
           RETURN _FUNPUTERROR("BIT.OR/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
        end
        DIM:=DIM1; DIMR:=DIM1R; DIMC:=DIM1C; DIMP:=DIM1P; DIMB:=DIM1B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XNUMOR(CX[EHX],AX[EHX])
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XNUMOR(CX[EHX][EIX],AX[EHX][EIX])
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XNUMOR(CX[EHX][EIX],AX[EHX][EIX])
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XNUMOR(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XNUMOR(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMOR(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMOR(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
           END; END; END; END
           END
        END
     ELSEIF EEX=="AN"
        DIM:=DIM2; DIMR:=DIM2R; DIMC:=DIM2C; DIMP:=DIM2P; DIMB:=DIM2B
        TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
        IF DIM==1
           FOR EHX:=1 TO DIMR
              TEMPORAL[EHX]:=XNUMOR(CX[EHX],AX)
           END
        ELSEIF DIM==2
           IF DIMR<=DIMC
           FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX]:=XNUMOR(CX[EHX][EIX],AX)
           END; END
           ELSE
           FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX]:=XNUMOR(CX[EHX][EIX],AX)
           END; END
           END
        ELSEIF DIM==3
           IF DIMR<=DIMC
           FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX]:=XNUMOR(CX[EHX][EIX][EJX],AX)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX]:=XNUMOR(CX[EHX][EIX][EJX],AX)
           END; END; END
           END
        ELSE
           IF DIMR<=DIMC
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMOR(CX[EHX][EIX][EJX][EKX],AX)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
              TEMPORAL[EHX][EIX][EJX][EKX]:=XNUMOR(CX[EHX][EIX][EJX][EKX],AX)
           END; END; END; END
           END      
        END        
     ELSE
        RETURN _FUNPUTERROR("BIT.OR/FUCKING ARGUMENTS",OP_CODE,CP)
     END
     //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
     FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
     RELEASE TEMPORAL
  END
  STACK[CS] := CWM
  RETURN .T.


/******************************************************************
                   FUNCIONES BaSICAS LISTAS           
*******************************************************************/
FUNCTION TFSTK_CODE()   // 147
LOCAL EAX,EBX
LOCAL OP_CODE:=1470
  EAX:=STACK[CS]    // posicion en arreglo
  EBX:=STACK[CS-1]  // CODIGO FUNCION
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CS-=2
  if stk_var_02[EAX]<=0
     RETURN _FUNPUTERROR("STACK UNDERFLOW",OP_CODE,CP)
  end 
RETURN (__PLIST[stk_var_02[EBX]]:EXEC(EAX))

  FUNCTION FUNLISTROW(EAX)   // 1     
  LOCAL AX
  LOCAL OP_CODE:=1470
    AX:=stk_var_02[EAX]
    if SFLAGDIR>0   // ha sido seleccionado un array
       if AX>SFLAGROW  // supera el limite del array
          RETURN _FUNPUTERROR("MAT.ROW/STACK OVERFLOW",OP_CODE+1,CP)
       else
          FLOCV:=AX   // guardo en variable de fila
       end
    else
       RETURN _FUNPUTERROR("MAT.ROW/STACK EXPECTED (USE)",OP_CODE+2,CP)
    end
  RETURN .T.

  FUNCTION FUNLISTCOL(EAX)
  LOCAL AX
  LOCAL OP_CODE:=1470
    AX:=stk_var_02[EAX]
    if SFLAGDIR>0   // ha sido seleccionado un array
       if AX>SFLAGCOL  // supera el limite del array
          RETURN _FUNPUTERROR("MAT.COL/STACK OVERFLOW",OP_CODE+1,CP)
       else
          FLOCW:=AX   // guardo en variable de columna
       end
    else
       RETURN _FUNPUTERROR("MAT.COL/STACK EXPECTED (USE)",OP_CODE+2,CP)
    end
  RETURN .T.
  
  FUNCTION FUNLISTPAGE(EAX)
  LOCAL AX
  LOCAL OP_CODE:=1470
    AX:=stk_var_02[EAX]
    if SFLAGDIR>0   // ha sido seleccionado un array
       if AX>SFLAGPAG // supera el limite del array
          RETURN _FUNPUTERROR("MAT.PG/STACK OVERFLOW",OP_CODE+1,CP)
       else
          FLOCX:=AX   // guardo en variable de pagina
       end
    else
       RETURN _FUNPUTERROR("MAT.PG/STACK EXPECTED (USE)",OP_CODE+2,CP)
    end
  RETURN .T.
  
  FUNCTION FUNLISTBLOCK(EAX)
  LOCAL AX
  LOCAL OP_CODE:=1470
    AX:=stk_var_02[EAX]
    if SFLAGDIR>0   // ha sido seleccionado un array
       if AX>SFLAGBLK // supera el limite del array
          RETURN _FUNPUTERROR("MAT.BK/STACK OVERFLOW",OP_CODE+1,CP)
       else
          FLOCY:=AX   // guardo en variable de bloque
       end
    else
       RETURN _FUNPUTERROR("MAT.BK/STACK EXPECTED (USE)",OP_CODE+2,CP)
    end
  RETURN .T.
  
  FUNCTION FUNLISTINS(EAX)
  LOCAL AX
  LOCAL OP_CODE:=1470
    //AX:=stk_var_02[EAX]
    if SFLAGDIR>0   // ha sido seleccionado un array
       if FLOCV>SFLAGROW .or. FLOCV<=0 //supera el limite del array
          RETURN _FUNPUTERROR("STK.INS/DIMENSION OVERFLOW|UNDERFLOW",OP_CODE+3,CP)
       else
          if SFLAGDIM>1
             RETURN _FUNPUTERROR("STK.INS/DIMENSION OVERFLOW",OP_CODE+1,CP)
          else
             ++SFLAGROW
            ///// HB_AINS(stk_var_02[SFLAGDIR],SFLAGROW,.T.)
             ASIZE(stk_var_02[SFLAGDIR],SFLAGROW)
             AINS(stk_var_02[SFLAGDIR],FLOCV)
             stk_var_02[SFLAGDIR][FLOCV] := "<null>"
             ++STK_ARRAY_ROW[SFLAGSTK]
          end   
       end
    else
       RETURN _FUNPUTERROR("STK.INS/STACK EXPECTED (USE)",OP_CODE+2,CP)
    end
  RETURN .T.
  
  FUNCTION FUNLISTDEL(EAX)    // 6
  LOCAL OP_CODE:=1470
   // NO SE USA EAX
    if SFLAGDIR>0   // ha sido seleccionado un array
       if FLOCV>SFLAGROW .or. FLOCV<=0 //supera el limite del array
          RETURN _FUNPUTERROR("STK.DEL/STACK OVERFLOW/UNDERFLOW",OP_CODE+3,CP)
       else
          if SFLAGDIM>1
             RETURN _FUNPUTERROR("STK.DEL/DIMENSION OVERFLOW",OP_CODE+1,CP)
          else
             --SFLAGROW
             HB_ADEL(stk_var_02[SFLAGDIR],FLOCV,.T.)
           //  stk_var_02[SFLAGDIR][FLOCV]:=0
           //  ADEL(stk_var_02[SFLAGDIR],FLOCV)
           //  ASIZE(stk_var_02[SFLAGDIR],SFLAGROW)
             --STK_ARRAY_ROW[SFLAGSTK]
          end   
       end
    else
       RETURN _FUNPUTERROR("STK.DEL/STACK EXPECTED (USE)",OP_CODE+2,CP)
    end
  RETURN .T.
 

/******************************************************************
               OPERACIONES DE ARRAYS FAM. TARR_CODE
*******************************************************************/
  FUNCTION META_SMINMAX()   // 72
  LOCAL EAX,EBX,AX,EDX,EHX,EIX //,EJX,EKX,EPX,EOX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL ETX
  LOCAL OP_CODE:=720,FUENTE
    EAX:=STACK[CS]      // matriz
    EBX:=STACK[CS-1]    // codigo de funcion
    FUENTE:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    
    // llevar todo a un array, ordenarlo, y extraer el min y el max!
    IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       RETURN _FUNPUTERROR("STK.MAX,STK.MIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
    end
    EIX:=IIF(stk_var_02[EBX]==1,1,2)
    EOX:=XSTKMINMAX(FUENTE,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,EIX)
       
    stk_var_02[CWM]:=EOX
    STACK[--CS] := CWM
  RETURN .T.
  
  FUNCTION FUNGV()    //81
  LOCAL EAX,EBX,AX,EDX
  LOCAL DIM,DIMR
  LOCAL OP_CODE:=810
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]    // posicion
    EBX:=STACK[CS-1]       // array
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS 
    ++CWM
    if STK_CWMTOP>0
       EDX := STK_TEMP_DIR[STK_CWMTOP]
       if EDX!=EBX
          EDX := ASCAN(STK_ARRAY_DIR,EBX)
          DIM := STK_ARRAY_DIM[EDX]
    //      DIMR:=STK_ARRAY_ROW[EDX]
       else   
          DIM:=STK_TEMP_DIM[STK_CWMTOP]
    //      DIMR:=STK_TEMP_ROW[STK_CWMTOP]
          STK_TEMP_DIR[STK_CWMTOP]:=0
          STK_CWMTOP--
       end
    else  // es legal
       EDX := ASCAN(STK_ARRAY_DIR,EBX)
       DIM := STK_ARRAY_DIM[EDX]
    //   DIMR:=STK_ARRAY_ROW[EDX]
    end
    
    IF DIM==1
       DIMR:=LEN(stk_var_02[EBX])
       IF DIMR>=AX .AND. AX>0
          stk_var_02[CWM]:=stk_var_02[EBX][AX]
          STACK[CS]:=CWM
       ELSE
          RETURN _FUNPUTERROR("[ v],GET VECTOR/SUBINDEX OUT OF RANGE",OP_CODE+1,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("[ v],GET VECTOR/UNIDIMENSIONAL VECTOR EXPECTED",OP_CODE,CP)
    END
  RETURN .T.
  
  FUNCTION FUNPV()   // 80
  LOCAL EAX,EBX,ECX,AX,BX,EDX
  LOCAL OP_CODE:=800
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]        // vector
    AX:=stk_var_02[EAX]     // dato
    BX:=stk_var_02[EBX]     // posicion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=3
    EDX := ASCAN(STK_ARRAY_DIR,ECX)  // es un array registrado??

    IF EDX>0 
       IF STK_ARRAY_DIM[EDX]==1
          IF LEN(stk_var_02[ECX])>=BX.AND.BX>0
             stk_var_02[ECX][BX]:=AX
          ELSE
             RETURN _FUNPUTERROR("[M ],PUT MAT/EMPTY MATRIX|OVERFLOW",OP_CODE+2,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("[M ],PUT MAT/UNIDIMENSIONAL MATRIX EXPECTED",OP_CODE+1,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("[M ],PUT VECTOR/VECTOR EXPECTED",OP_CODE,CP)
    END
  RETURN .T.
  
  FUNCTION FUNSTRGET()  // 1
  LOCAL EAX,EBX,ECX,AX,BX,EDX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP
    EAX:=STACK[CS]            // POS FINAL
    EBX:=STACK[CS-1]          // POS INICIAL
    ECX:=STACK[CS-2]          // STRING
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=2
    ++CWM
    stk_var_02[CWM]:=SUBSTR(stk_var_02[ECX],stk_var_02[EBX],(stk_var_02[EAX]-stk_var_02[EBX]+1))
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNGM()    // 142
  LOCAL EAX,EBX,ECX,AX,BX,EDX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP
  LOCAL OP_CODE:=1420
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]          // matriz
    AX:=stk_var_02[EAX]       // columna
    BX:=stk_var_02[EBX]       // fila
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CS-=2
    ++CWM

    IF FUNGETDIMS(ECX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
       IF DIM==2
          IF BX > 0 .AND. AX>0 .AND. DIMR>=BX .AND. DIMC >= AX
             stk_var_02[CWM]:=stk_var_02[ECX][BX][AX]
             STACK[CS]:=CWM
          ELSE
             RETURN _FUNPUTERROR("[. M],GET MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)  
          END
       ELSE
          RETURN _FUNPUTERROR("[. M],GET MAT/BIDIMENSIONAL MATRIX EXPECTED",OP_CODE+1,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("[. M],GET MAT/MATRIX NOT INITIALIZED",OP_CODE,CP)  
    END
  RETURN .T.
  
  FUNCTION FUNSTRPUT()  // 2
  LOCAL EAX,EBX,ECX,AX,BX,EDX,OP_CODE:=20
    EAX:=STACK[CS]              // dato
    EBX:=STACK[CS-1]            // POS FINAL
    ECX:=STACK[CS-2]            // POS INICIAL
    EDX:=STACK[CS-3]             // STRING
    if EDX>TopCWM
       RETURN _FUNPUTERROR("PUT STRING/STRING (TEMPORAL) INVALID",OP_CODE,CP)  
    end
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS-=4
    AX:=SUBSTR(stk_var_02[EDX],1,stk_var_02[ECX]-1)
    BX:=SUBSTR(stk_var_02[EDX],stk_var_02[EBX]+1,LEN(stk_var_02[EDX]))
    stk_var_02[EDX]:=AX+stk_var_02[EAX]+BX
  RETURN .T.
  
  FUNCTION FUNPM()   // 141
  LOCAL EAX,EBX,ECX,AX,BX,CX,EDX,EEX,EOX,EPX
  LOCAL OP_CODE:=1410
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2] 
    EDX:=STACK[CS-3]             // matriz
    AX:=stk_var_02[EAX]          // dato
    BX:=stk_var_02[EBX]          // columna
    CX:=stk_var_02[ECX]          // fila
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS-=4
    
    EEX := ASCAN(STK_ARRAY_DIR,EDX)  // es un array registrado?? 
    IF EEX>0 
       IF STK_ARRAY_DIM[EEX]==2
          IF BX > 0 .AND. CX>0 .AND. STK_ARRAY_ROW[EEX]>=CX .AND. STK_ARRAY_COL[EEX] >= BX
             stk_var_02[EDX][CX][BX]:=AX
          ELSE
             RETURN _FUNPUTERROR("[. M],PUT MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP) 
          END
       ELSE
          RETURN _FUNPUTERROR("[. M],PUT MAT/BIDIMENSIONAL MATRIX EXPECTED",OP_CODE+1,CP)
       END 
    ELSE
       RETURN _FUNPUTERROR("[. M],PUT MAT/MATRIX NOT INITIALIZED",OP_CODE+2,CP)
    END
  RETURN .T.
  
  FUNCTION FUNGP()   // 90
  LOCAL EAX,EBX,ECX,AX,BX,CX,EDX,EEX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP
  LOCAL OP_CODE:=900
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]          
    EDX:=STACK[CS-3]          // matriz
    AX:=stk_var_02[EAX]       // pagina
    BX:=stk_var_02[EBX]       // columna
    CX:=stk_var_02[ECX]       // fila
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS-=3
    ++CWM
    IF FUNGETDIMS(EDX,@EEX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
       IF DIM==3
          IF CX<=DIMR .AND. BX<=DIMC .AND. AX<=DIMP
             IF CX>0 .AND. BX>0 .AND. AX > 0
                stk_var_02[CWM]:=stk_var_02[EDX][CX][BX][AX]
                STACK[CS]:=CWM
             ELSE
                RETURN _FUNPUTERROR("[: M],GET MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("[: M],GET MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("[: M],GET MAT/TRIDIMENSIONAL MATRIX EXPECTED",OP_CODE+1,CP)  
       END
    ELSE
       RETURN _FUNPUTERROR("[: M],GET MAT/MATRIX NOT INITIALIZED",OP_CODE,CP)  
    END
  RETURN .T.
  
  FUNCTION FUNPP()   // 91
  LOCAL EAX,EBX,ECX,EDX,EEX,AX,BX,CX,DX,EFX,ERX
  LOCAL OP_CODE:=910
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2] 
    EDX:=STACK[CS-3]
    EEX:=STACK[CS-4]             // matriz
    AX:=stk_var_02[EAX]          // dato
    BX:=stk_var_02[EBX]          // page
    CX:=stk_var_02[ECX]          // columna
    DX:=stk_var_02[EDX]          // fila
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CWM:=CMPCWM(EEX,CWM,TopCWM)

    CS-=5
    EFX := ASCAN(STK_ARRAY_DIR,EEX)  // es un array registrado??
    IF EFX>0
       IF STK_ARRAY_DIM[EFX]==3
          IF BX>0 .AND. CX>0 .AND. DX>0
             IF BX<=STK_ARRAY_PAG[EFX] .AND. CX<=STK_ARRAY_COL[EFX] .AND. DX<=STK_ARRAY_ROW[EFX]
                stk_var_02[EEX][DX][CX][BX]:=AX
             ELSE
                RETURN _FUNPUTERROR("[: M],PUT MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("[: M],PUT MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("[: M],PUT MAT/TRIDIMENSIONAL MATRIX EXPECTED",OP_CODE+1,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("[: M],PUT MAT/MATRIX NOT INITIALIZED",OP_CODE+1,CP)
    END
  RETURN .T.
  
  FUNCTION FUNGB()   // 108
  LOCAL EAX,EBX,ECX,EDX,EEX,AX,BX,CX,DX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP
  LOCAL OP_CODE:=1080
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]          
    EDX:=STACK[CS-3]
    EEX:=STACK[CS-4]          // matriz
    AX:=stk_var_02[EAX]       // bloque
    BX:=stk_var_02[EBX]       // pagina
    CX:=stk_var_02[ECX]       // columna
    DX:=stk_var_02[EDX]       // fila
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CWM:=CMPCWM(EEX,CWM,TopCWM)
    CS-=4
    ++CWM
    IF FUNGETDIMS(EEX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
       IF DIM==4
          IF DX<=DIMR .AND. CX<=DIMC .AND. BX<=DIMP .AND. AX<=DIMB
             IF DX>0 .AND. CX>0 .AND. BX>0 .AND. AX>0
                stk_var_02[CWM]:=stk_var_02[EEX][DX][CX][BX][AX]
                STACK[CS]:=CWM
             ELSE
                RETURN _FUNPUTERROR("[_ M],GET MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("[_ M],GET MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("[_ M],GET MAT/QUATERDIMENSIONAL MATRIX EXPECTED",OP_CODE+1,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("[_ M],GET MAT/MATRIX NOT INITIALIZED",OP_CODE,CP)  
    END
  RETURN .T.
  
  FUNCTION FUNPB()   // 109
  LOCAL EAX,EBX,ECX,EDX,EEX,AX,BX,CX,DX,EKX,KX,EFX,EOX,ERX
  LOCAL OP_CODE:=1090
    EKX:=STACK[CS]
    EAX:=STACK[CS-1]
    EBX:=STACK[CS-2]
    ECX:=STACK[CS-3]
    EDX:=STACK[CS-4]
    EEX:=STACK[CS-5]          // matriz
    KX:=stk_var_02[EKX]       // dato
    AX:=stk_var_02[EAX]       // bloque
    BX:=stk_var_02[EBX]       // pagina
    CX:=stk_var_02[ECX]       // columna
    DX:=stk_var_02[EDX]       // fila
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CWM:=CMPCWM(EEX,CWM,TopCWM)
    CWM:=CMPCWM(EKX,CWM,TopCWM)
    CS-=6
    EFX := ASCAN(STK_ARRAY_DIR,EEX)  // es un array registrado?? 
    IF EFX>0
       IF STK_ARRAY_DIM[EFX]==4
          IF AX>0.AND.BX>0.AND.CX>0.AND.DX>0
             IF DX<=STK_ARRAY_ROW[EFX] .AND. CX<=STK_ARRAY_COL[EFX] .AND. BX<=STK_ARRAY_PAG[EFX];
                .AND. AX<=STK_ARRAY_BLK[EFX]
                stk_var_02[EEX][DX][CX][BX][AX]:=KX
             ELSE
                RETURN _FUNPUTERROR("[_ M],PUT MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("[_ M],PUT MAT/SUBINDEX OUT OF RANGE",OP_CODE+2,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("[_ M],PUT MAT/QUATERDIMENSIONAL MATRIX EXPECTED",OP_CODE+2,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("[_ M],PUT MAT/MATRIX NOT INITIALIZED",OP_CODE+1,CP)
    END
  RETURN .T.
  
  FUNCTION FUNDIM()    // 56   
  LOCAL EAX,EBX,ECX,EDX,AX,BX,CX,DX
  LOCAL OP_CODE:=560
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2] 
    EDX:=STACK[CS-3] 
    AX:=stk_var_02[EAX]     // block
    BX:=stk_var_02[EBX]   // page
    CX:=stk_var_02[ECX]   // col
    DX:=stk_var_02[EDX]   // row
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS-=4
    // seteo un solo numero con bits para minimizar la comparacion
    ECX:=0    // campo de bit
    if DX>0   // row
       ECX:=1
       if CX>0   // col
          ++ECX
          if BX>0   // page
             ++ECX
             if AX>0   // block
                ++ECX
             end
          end
       end
    end
    if ECX>0
       SFLAGROW:=DX
       SFLAGCOL:=CX
       SFLAGPAG:=BX
       SFLAGBLK:=AX
       SFLAGDIM:=ECX
    else
       RETURN _FUNPUTERROR("DIM/FUCKING DIMS",OP_CODE,CP)
    end
  RETURN .T.
  
  FUNCTION FUNCONFIGARRAY()   // 74
  LOCAL EAX,EEX,EFX
  LOCAL OP_CODE:=740
    if SFLAGROW>0
       EEX:=STACK[CS]
       CWM:=CMPCWM(EEX,CWM,TopCWM)
       --CS
       EAX := ASCAN(STK_ARRAY_DIR,EEX)
       STK_ARRAY_DIM[EAX]:=SFLAGDIM
       STK_ARRAY_ROW[EAX]:=SFLAGROW
       STK_ARRAY_COL[EAX]:=SFLAGCOL
       STK_ARRAY_PAG[EAX]:=SFLAGPAG
       STK_ARRAY_BLK[EAX]:=SFLAGBLK
       EFX := STK_ARRAY_TYP[EAX]  // el tipo del array
       if EFX=="C"
          EFX:=""
       elseif EFX=="N" .or. EFX=="F"
          EFX:=0
       elseif EFX=="L"
          EFX:=.F.
       enD
    ELSE
       RETURN _FUNPUTERROR("DIM/MISSING DIMS ARRAY",OP_CODE,CP)
    end
  RETURN (__PCONFARR[SFLAGDIM]:EXEC(EEX,EFX))
       
    FUNCTION CONFARRONE(EEX,EFX)
      stk_var_02[EEX] := ARRAY(SFLAGROW)
      AFILL(stk_var_02[EEX],EFX)
    RETURN .T.
    
    FUNCTION CONFARRTWO(EEX,EFX)
    LOCAL AX
      stk_var_02[EEX] := ARRAY(SFLAGROW,SFLAGCOL)
      
      for AX:=1 to SFLAGROW
         AFILL(stk_var_02[EEX][AX],EFX)
      end
    RETURN .T.

    FUNCTION CONFARRTHREE(EEX,EFX)
    LOCAL AX,BX
      stk_var_02[EEX] := ARRAY(SFLAGROW,SFLAGCOL,SFLAGPAG)
     
      for AX:=1 to SFLAGROW; for BX:=1 to SFLAGCOL
         AFILL(stk_var_02[EEX][AX][BX],EFX)
      end; end 
    RETURN .T.
    
    FUNCTION CONFARRFOUR(EEX,EFX)
    LOCAL AX,BX,CX
      stk_var_02[EEX] := ARRAY(SFLAGROW,SFLAGCOL,SFLAGPAG,SFLAGBLK)
      for CX:=1 to SFLAGPAG; for AX:=1 to SFLAGROW; for BX:=1 to SFLAGCOL
         AFILL(stk_var_02[EEX][AX][BX][CX],EFX)
      end; end; end
    RETURN .T.


/******************************************************************
                      PILAS Y COLAS: ARRAYS
*******************************************************************/
  FUNCTION FUNGET()   // 151
  LOCAL OP_CODE:=1510
    if SFLAGDIR==0   // NO ha sido seleccionado un array 
       RETURN _FUNPUTERROR("MAT.GET/STACK EXPECTED (USE)",OP_CODE,CP)
    end
  RETURN (__PFUNGET[SFLAGDIM]:EXEC())

    FUNCTION FUNGET1()
    LOCAL OP_CODE:=1511,EX,EHX,EIX,EJX,EKX,MATRIZ,TEMPORAL
      if FLOCV<=SFLAGROW .and. FLOCV>0 // supera el limite del array
         EX:=stk_var_02[SFLAGDIR][FLOCV]
         IF VALTYPE(EX)!="A"
            stk_var_02[++CWM]:=EX
         ELSE   // una dim: asume que se trata de un stack.
            ++CWM
            MATRIZ:=EX[1]
            /////stk_var_02[CWM]:=ARRAY(EX[2][4],EX[2][5],EX[2][6],EX[2][7])
            stk_var_02[CWM]:=XMMLET(MATRIZ,EX[2][2],EX[2][4],EX[2][5],EX[2][6],EX[2][7],0) // DEBE IR
            FUNPUTDIMS(CWM,EX[2][2],EX[2][3],EX[2][4],EX[2][5],EX[2][6],EX[2][7])
         END
         STACK[++CS]:=CWM
      else
         RETURN _FUNPUTERROR("MAT.GET/STACK OVERFLOW|UNDERFLOW",OP_CODE,CP)
      end
    RETURN .T.
    
    FUNCTION FUNGET2()
    LOCAL OP_CODE:=1511,EX
      if FLOCV<=SFLAGROW .and. FLOCV>0 .and.;
         FLOCW<=SFLAGCOL .and. FLOCW>0      // supera el limite del array
         stk_var_02[++CWM]:=stk_var_02[SFLAGDIR][FLOCV][FLOCW]
         STACK[++CS]:=CWM
      else
         RETURN _FUNPUTERROR("MAT.GET/STACK OVERFLOW|UNDERFLOW",OP_CODE,CP)
      end
    RETURN .T.
    
    FUNCTION FUNGET3()
    LOCAL OP_CODE:=1511,EX
      if FLOCV<=SFLAGROW .and. FLOCV>0 .and.;
         FLOCW<=SFLAGCOL .and. FLOCW>0 .and.;
         FLOCX<=SFLAGPAG .and. FLOCX>0      // supera el limite del array
         stk_var_02[++CWM]:=stk_var_02[SFLAGDIR][FLOCV][FLOCW][FLOCX]
         STACK[++CS]:=CWM
      else
         RETURN _FUNPUTERROR("MAT.GET/STACK OVERFLOW|UNDERFLOW",OP_CODE,CP)
      end
    RETURN .T.
    
    FUNCTION FUNGET4()
    LOCAL OP_CODE:=1511,EX
      if FLOCV<=SFLAGROW .and. FLOCV>0 .and.;
         FLOCW<=SFLAGCOL .and. FLOCW>0 .and.;
         FLOCX<=SFLAGPAG .and. FLOCX>0 .and.;      // supera el limite del array
         FLOCY<=SFLAGBLK .and. FLOCY>0
         stk_var_02[++CWM]:=stk_var_02[SFLAGDIR][FLOCV][FLOCW][FLOCX][FLOCY]
         STACK[++CS]:=CWM
      else
         RETURN _FUNPUTERROR("MAT.GET/STACK OVERFLOW|UNDERFLOW",OP_CODE,CP)
      end
    RETURN .T.
    
  FUNCTION FUNPUT()   // 152
  LOCAL EFX,OP_CODE:=1520,SW_RECUPERA:=.F.
    EFX:=STACK[CS]
    CWM:=CMPCWM(EFX,CWM,TopCWM)
    --CS
    // flag para saber si guardo con recuperacion o no
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH=="C"
       if upper(FVWITH)=="RECOVER"
          SW_RECUPERA:=.T.
       end
    end
    if SFLAGDIR==0   // ha sido seleccionado un array
       RETURN _FUNPUTERROR("MAT.PUT/STACK EXPECTED (USE)",OP_CODE,CP)
    end
  RETURN (__PFUNPUT[SFLAGDIM]:EXEC(EFX,SW_RECUPERA))
  
    FUNCTION FUNPUT1(EFX,SW_RECUPERA)
    LOCAL OP_CODE:=1520,EX,EHX
    LOCAL EBX,DIM,TYP,DIMR,DIMC,DIMP,DIMB,EPX
      if FLOCV<=SFLAGROW .and. FLOCV>0 // supera el limite del array
         EX:=stk_var_02[EFX]
         IF VALTYPE(EX)!="A"   
            stk_var_02[SFLAGDIR][FLOCV]:=EX
         ELSE          // ES UN ARRAY O STACK: asume que es un stack.
           /* consulta por FLAG, porque puede que se trate de un vector y no de un stack */
           if FTWITH=="C"
              if upper(FVWITH)=="ARRAY"  // es un vector simple
                 IF FUNGETDIMS(EFX,@EBX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
                   if DIM==1
                     if DIMR==STK_ARRAY_ROW[SFLAGSTK]
                        IF FLOCV==1
                           FOR EPX:=1 TO DIMR
                              stk_var_02[SFLAGDIR][EPX]:=EX[EPX]
                           END
                        ELSE
                           RETURN _FUNPUTERROR("MAT.PUT/VECTOR OVERFLOW (MAT.ROW>1)",OP_CODE+6,CP)
                        END
                     elseif DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 // (ELX-FLOCW)<=DIMC
                        EPX:=0; ELX:=FLOCV+DIMR-1
                        FOR EHX:=FLOCV TO ELX
                           stk_var_02[SFLAGDIR][EHX]:=EX[++EPX]
                        END
                     else
                        RETURN _FUNPUTERROR("MAT.PUT/VECTOR OVERFLOW",OP_CODE+3,CP)
                     end
                   else
                     RETURN _FUNPUTERROR("MAT.PUT/VECTOR OVERFLOW",OP_CODE+6,CP)
                   end
                   RETURN .T.
                 ELSE
                   RETURN _FUNPUTERROR("MAT.PUT/DIMENSION OVERFLOW",OP_CODE+3,CP)
                 END
              end
            end
            IF SW_RECUPERA
               IF FUNGETDIMS(EFX,@EBX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.F.)
                  stk_var_02[SFLAGDIR][FLOCV]:={stk_var_02[EFX],{EFX,DIM,TYP,DIMR,DIMC,DIMP,DIMB,SW_RECUPERA}}
               ELSE
                  RETURN _FUNPUTERROR("MAT.PUT/MATRIX USED BY ELEMENT IS NOT INITIALIZED OR INVALID",OP_CODE+1,CP)
               END
            ELSE
               IF FUNGETDIMS(EFX,@EBX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
                  stk_var_02[SFLAGDIR][FLOCV]:={stk_var_02[EFX],{EFX,DIM,TYP,DIMR,DIMC,DIMP,DIMB,SW_RECUPERA}}
               ELSE
                  RETURN _FUNPUTERROR("MAT.PUT/MATRIX USED BY ELEMENT IS NOT INITIALIZED",OP_CODE+1,CP)
               END
            END
         END
      else
         RETURN _FUNPUTERROR("MAT.PUT/STACK OVERFLOW|UNDERFLOW",OP_CODE+2,CP)
      end
    RETURN .T.
    
    FUNCTION FUNPUT2(EFX,SW_RECUPERA)
    LOCAL OP_CODE:=1520,EX,ELX,EHX,EIX,EPX,ERX,EMX,EQX
    LOCAL EBX,DIM,TYP,DIMR,DIMC,DIMP,DIMB
      if FLOCV<=SFLAGROW .and. FLOCV>0 .and.;
         FLOCW<=SFLAGCOL .and. FLOCW>0      // supera el limite del array
         EX:=stk_var_02[EFX]
         IF VALTYPE(EX)!="A"   
            stk_var_02[SFLAGDIR][FLOCV][FLOCW]:=EX
         ELSE    // ES UN ARRAY: asume que es una fila o bloque del array usado
            IF FUNGETDIMS(EFX,@EBX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
               if DIM==1
                  if DIMR==STK_ARRAY_COL[SFLAGSTK]
                     IF FLOCW==1
                        FOR EPX:=1 TO DIMR
                           stk_var_02[SFLAGDIR][FLOCV][EPX]:=EX[EPX]
                        END
                     ELSE
                        RETURN _FUNPUTERROR("MAT.PUT/VECTOR OVERFLOW (MAT.COL>1)",OP_CODE+6,CP)
                     END
                  elseif DIMR<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1 // (ELX-FLOCW)<=DIMC
                     EPX:=0; ELX:=FLOCW+DIMR-1
                     FOR EIX:=FLOCW TO ELX
                        stk_var_02[SFLAGDIR][FLOCV][EIX]:=EX[++EPX]
                     END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               elseif DIM==2  // SFLAGSTK  STK_ARRAY_TYP[SFLAGSTK]
                  if DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 .and. DIMC<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1
                     EPX:=1; EMX:=FLOCV+DIMR-1; EQX:=FLOCW+DIMC-1
                     FOR EHX:=FLOCV TO EMX; ERX:=0; FOR EIX:=FLOCW TO EQX
                        stk_var_02[SFLAGDIR][EHX][EIX]:=EX[EPX][++ERX]
                     END; ++EPX; END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               else
                  RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT IS NOT A VECTOR OR OVER|UNDERFLOW",OP_CODE+3,CP)
               end
            ELSE
               RETURN _FUNPUTERROR("MAT.PUT/MATRIX USED BY ELEMENT IS NOT INITIALIZED",OP_CODE+1,CP)
            END
         END
      else
         RETURN _FUNPUTERROR("MAT.PUT/STACK OVERFLOW|UNDERFLOW",OP_CODE+2,CP)
      end
    RETURN .T.
    
    FUNCTION FUNPUT3(EFX,SW_RECUPERA)
    LOCAL OP_CODE:=1520,EX,ELX,EHX,EIX,EJX,EPX,ERX,EMX,EQX,ESX,ETX
    LOCAL EBX,DIM,TYP,DIMR,DIMC,DIMP,DIMB
      if FLOCV<=SFLAGROW .and. FLOCV>0 .and.;
         FLOCW<=SFLAGCOL .and. FLOCW>0 .and.;
         FLOCX<=SFLAGPAG .and. FLOCX>0      // supera el limite del array
         EX:=stk_var_02[EFX]
         IF VALTYPE(EX)!="A"   // ES UN ARRAY O STACK
            stk_var_02[SFLAGDIR][FLOCV][FLOCW][FLOCX]:=EX
         ELSE
            IF FUNGETDIMS(EFX,@EBX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
                if DIM==1
                  if DIMR<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1 // (ELX-FLOCW)<=DIMC
                     EPX:=0; ELX:=FLOCW+DIMR-1
                     FOR EIX:=FLOCW TO ELX
                        stk_var_02[SFLAGDIR][FLOCV][EIX][FLOCX]:=EX[++EPX]
                     END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               elseif DIM==2  // SFLAGSTK  STK_ARRAY_TYP[SFLAGSTK]
                  if DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 .and. DIMC<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1
                     EPX:=1; EMX:=FLOCV+DIMR-1; EQX:=FLOCW+DIMC-1
                     FOR EHX:=FLOCV TO EMX; ERX:=0; FOR EIX:=FLOCW TO EQX
                        stk_var_02[SFLAGDIR][EHX][EIX][FLOCX]:=EX[EPX][++ERX]
                     END; ++EPX; END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               elseif DIM==3
                  if DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 .and. DIMC<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1 .and.;
                     DIMP<=STK_ARRAY_PAG[SFLAGSTK]-FLOCX+1
                     EMX:=FLOCV+DIMR-1; EQX:=FLOCW+DIMC-1; ESX:=FLOCX+DIMP-1
                     ETX:=1
                     FOR EJX:=FLOCX TO ESX; EPX:=1; FOR EHX:=FLOCV TO EMX; ERX:=0; FOR EIX:=FLOCW TO EQX
                        stk_var_02[SFLAGDIR][EHX][EIX][EJX]:=EX[EPX][++ERX][ETX]
                     END; ++EPX; END; ++ETX; END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               else
                  RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT IS NOT A VECTOR OR OVER|UNDERFLOW",OP_CODE+3,CP)
               end
            ELSE
               RETURN _FUNPUTERROR("MAT.PUT/MATRIX USED BY ELEMENT IS NOT INITIALIZED OR INVALID",OP_CODE+1,CP)
            END
         END
      else
         RETURN _FUNPUTERROR("MAT.PUT/STACK OVERFLOW|UNDERFLOW",OP_CODE+2,CP)
      end
    RETURN .T.
    
    FUNCTION FUNPUT4(EFX,SW_RECUPERA)
    LOCAL OP_CODE:=1520,EX,ELX,EHX,EIX,EJX,EKX,EPX,ERX,EMX,EQX,ESX,ETX,EUX,EVX
    LOCAL EBX,DIM,TYP,DIMR,DIMC,DIMP,DIMB
      if FLOCV<=SFLAGROW .and. FLOCV>0 .and.;
         FLOCW<=SFLAGCOL .and. FLOCW>0 .and.;
         FLOCX<=SFLAGPAG .and. FLOCX>0 .and.;      // supera el limite del array
         FLOCY<=SFLAGBLK .and. FLOCY>0
         EX:=stk_var_02[EFX]
         IF VALTYPE(EX)!="A"   // ES UN ARRAY O STACK
            stk_var_02[SFLAGDIR][FLOCV][FLOCW][FLOCX][FLOCY]:=EX
         ELSE
            IF FUNGETDIMS(EFX,@EBX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
                if DIM==1
                  if DIMR<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1 // (ELX-FLOCW)<=DIMC
                     EPX:=0; ELX:=FLOCW+DIMR-1
                     FOR EIX:=FLOCW TO ELX
                        stk_var_02[SFLAGDIR][FLOCV][EIX][FLOCX][FLOCY]:=EX[++EPX]
                     END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               elseif DIM==2  // SFLAGSTK  STK_ARRAY_TYP[SFLAGSTK]
                  if DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 .and. DIMC<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1
                     EPX:=1; EMX:=FLOCV+DIMR-1; EQX:=FLOCW+DIMC-1
                     FOR EHX:=FLOCV TO EMX; ERX:=0; FOR EIX:=FLOCW TO EQX
                        stk_var_02[SFLAGDIR][EHX][EIX][FLOCX][FLOCY]:=EX[EPX][++ERX]
                     END; ++EPX; END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               elseif DIM==3
                  if DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 .and. DIMC<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1 .and.;
                     DIMP<=STK_ARRAY_PAG[SFLAGSTK]-FLOCX+1
                     EMX:=FLOCV+DIMR-1; EQX:=FLOCW+DIMC-1; ESX:=FLOCX+DIMP-1
                     ETX:=1
                     FOR EJX:=FLOCX TO ESX; EPX:=1; FOR EHX:=FLOCV TO EMX; ERX:=0; FOR EIX:=FLOCW TO EQX
                        stk_var_02[SFLAGDIR][EHX][EIX][EJX][FLOCY]:=EX[EPX][++ERX][ETX]
                     END; ++EPX; END; ++ETX; END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               else    // DEBE SER DE 4
                  if DIMR<=STK_ARRAY_ROW[SFLAGSTK]-FLOCV+1 .and. DIMC<=STK_ARRAY_COL[SFLAGSTK]-FLOCW+1 .and.;
                     DIMP<=STK_ARRAY_PAG[SFLAGSTK]-FLOCX+1 .and. DIMB<=STK_ARRAY_BLK[SFLAGSTK]-FLOCY+1
                     EMX:=FLOCV+DIMR-1; EQX:=FLOCW+DIMC-1; ESX:=FLOCX+DIMP-1; EUX:=FLOCY+DIMB-1
                     EVX:=1; FOR EKX:=FLOCY TO EUX
                     ETX:=1; FOR EJX:=FLOCX TO ESX; EPX:=1; FOR EHX:=FLOCV TO EMX; ERX:=0; FOR EIX:=FLOCW TO EQX
                        stk_var_02[SFLAGDIR][EHX][EIX][EJX][EKX]:=EX[EPX][++ERX][ETX][EVX]
                     END; ++EPX; END; ++ETX; END; ++EVX
                     END
                  else
                     RETURN _FUNPUTERROR("MAT.PUT/NEW ELEMENT OVERFLOW",OP_CODE+3,CP)
                  end
               end
            ELSE
               RETURN _FUNPUTERROR("MAT.PUT/MATRIX USED BY ELEMENT IS NOT INITIALIZED OR INVALID",OP_CODE+1,CP)
            END
         END
      else
         RETURN _FUNPUTERROR("MAT.PUT/STACK OVERFLOW|UNDERFLOW",OP_CODE+2,CP)
      end
    RETURN .T.

  FUNCTION FUNFPOP()   // 184
  LOCAL EX, OP_CODE:=1840,EFX,ELX,ETX,EHX,EIX,EJX,EKX
  LOCAL DIM,TYP,DIMR,DIMC,DIMP,DIMB,AX,EBX,ROW,COL,PAG,BLK
    if SFLAGDIR>0   // ha sido seleccionado un array
       if SFLAGDIM==1
          if SFLAGROW>0
             if PFLAG==1
                EX:=SDC(stk_var_02[SFLAGDIR])
             else
                EX:=STACKPOP(stk_var_02[SFLAGDIR])
             end 
             // MODIFICAR EL LARGO DEL STACK!
             --SFLAGROW
             --STK_ARRAY_ROW[SFLAGSTK]
             IF VALTYPE(EX)!="A" 
                stk_var_02[++CWM]:=EX
             ELSE      // ES UN ARRAY: GUARDO SU INFORMACIÓN"
                IF EX[2][8]   // RECUPERA?
                 // ? "RECUPERA EL STAK"
                   EBX:=EX[2][1]
                   STK_ARRAY_DIM[EBX]:=DIM:=EX[2][2]
                   STK_ARRAY_TYP[EBX]:=TYP:=EX[2][3] 
                   STK_ARRAY_ROW[EBX]:=ROW:=EX[2][4]   // dimension fila
                   STK_ARRAY_COL[EBX]:=COL:=EX[2][5]   // dimension columna
                   STK_ARRAY_PAG[EBX]:=PAG:=EX[2][6]   // dimension pagina
                   STK_ARRAY_BLK[EBX]:=BLK:=EX[2][7]   // dimension bloque
                   stk_var_02[++CWM]:=EX[2][4]*IIF(EX[2][5]>0,EX[2][5],1)*IIF(EX[2][6]>0,EX[2][6],1)*;
                                               IIF(EX[2][7]>0,EX[2][7],1)  // DEVUELVO EL TAMAÑO
                     // lo devuelve a su lugar original
                   ETX:=EX[1]   // guardo el puntero

                   stk_var_02[EBX]:=ETX   ////XMMLET(ETX,DIM,ROW,COL,PAG,BLK,0)

                ELSE  // NO RECUPERA: LO DEJA EN TEMPORAL
                   DIM:=EX[2][2]
                   TYP:=EX[2][3] 
                   ROW:=EX[2][4]   // dimension fila
                   COL:=EX[2][5]   // dimension columna
                   PAG:=EX[2][6]   // dimension pagina
                   BLK:=EX[2][7]   // dimension bloque
                   ++CWM
                   ETX:=EX[1]   // guardo el puntero
                   /////stk_var_02[CWM]:=ARRAY(ROW,COL,PAG,BLK)
                   stk_var_02[CWM]:=ETX   ////XMMLET(ETX,DIM,ROW,COL,PAG,BLK,0)
                   FUNPUTDIMS(CWM,DIM,TYP,ROW,COL,PAG,BLK)
                END
             END
             STACK[++CS]:=CWM
          else
             RETURN _FUNPUTERROR("POP/STACK UNDERFLOW",OP_CODE+1,CP)
          end
       else
          RETURN _FUNPUTERROR("POP/DIMENSION OVERFLOW",OP_CODE+2,CP)
       end   
    else
       RETURN _FUNPUTERROR("POP/STACK EXPECTED (USE)",OP_CODE,CP)
    end    
  RETURN .T.
  
  FUNCTION FUNPUSH()  // 229
  LOCAL EBX,BX,OP_CODE:=2290,EFX,SW_RECUPERA:=.F.
  LOCAL DIM,TYP,DIMR,DIMC,DIMP,DIMB,TEMPORAL
    EBX:=STACK[CS]         // Fantasma
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS
    // flag para saber si guardo con recuperacion o no
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH=="C"
       if upper(FVWITH)=="RECOVER"
          SW_RECUPERA:=.T.
       end
    end
    if SFLAGDIR>0   // ha sido seleccionado un array
       if SFLAGDIM==1
          if valtype(stk_var_02[EBX])=="A"  // busco informacion y guardo
             if SW_RECUPERA
                IF !FUNGETDIMS(EBX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.F.)
                   RETURN _FUNPUTERROR("PUSH/MATRIX USED BY ELEMENT IS NOT INITIALIZED OR INVALID",OP_CODE+1,CP)
                end
             else
                IF !FUNGETDIMS(EBX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)   
                   RETURN _FUNPUTERROR("PUSH/MATRIX USED BY ELEMENT IS NOT INITIALIZED",OP_CODE+1,CP)
                END
             END
             //////TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
             TEMPORAL:=stk_var_02[EBX]   ////XMMLET(stk_var_02[EBX],DIM,DIMR,DIMC,DIMP,DIMB,0)
             
             ///STACKPUSH (stk_var_02[SFLAGDIR],{ACLO(stk_var_02[EBX]),{EBX,DIM,TYP,DIMR,DIMC,DIMP,DIMB,SW_RECUPERA}})
             STACKPUSH (stk_var_02[SFLAGDIR],{TEMPORAL,{EBX,DIM,TYP,DIMR,DIMC,DIMP,DIMB,SW_RECUPERA}})
          else   
             STACKPUSH (stk_var_02[SFLAGDIR],stk_var_02[EBX])
          end
          ++SFLAGROW
          ++STK_ARRAY_ROW[SFLAGSTK]
       else
          RETURN _FUNPUTERROR("PUSH/DIMENSION OVERFLOW",OP_CODE+2,CP)
       end
    else
       RETURN _FUNPUTERROR("PUSH/STACK EXPECTED (USE)",OP_CODE,CP)
    end
  RETURN .T.

  FUNCTION FUNPOP()  // 231
  LOCAL OP_CODE:=1220,EX,EBX,ETX,ERX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB
    if SFLAGDIR>0   // ha sido seleccionado un array
       if SFLAGDIM==1
          if SFLAGROW>0
             if PFLAG==1
                EX:=SDC(stk_var_02[SFLAGDIR])
             else
                EX:=STACKPOP(stk_var_02[SFLAGDIR])
             end 
            // MODIFICAR EL LARGO DEL STACK!
             --SFLAGROW
             --STK_ARRAY_ROW[SFLAGSTK]
             IF VALTYPE(EX)=="A"   // ES UN ARRAY: GUARDO SU INFORMACIÓN"
                IF EX[2][8]   // RECUPERA?
                   EBX:=EX[2][1]
                   STK_ARRAY_DIM[EBX]:=DIM:=EX[2][2]
                   STK_ARRAY_TYP[EBX]:=EX[2][3] 
                   STK_ARRAY_ROW[EBX]:=DIMR:=EX[2][4]   // dimension fila
                   STK_ARRAY_COL[EBX]:=DIMC:=EX[2][5]   // dimension columna
                   STK_ARRAY_PAG[EBX]:=DIMP:=EX[2][6]   // dimension pagina
                   STK_ARRAY_BLK[EBX]:=DIMB:=EX[2][7]   // dimension bloque

                   ////stk_var_02[EBX]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
                   ERX:=EX[1]
                   stk_var_02[EBX]:=ERX   ////XMMLET(ERX,DIM,DIMR,DIMC,DIMP,DIMB,0)
                END
             END
          else   
             RETURN _FUNPUTERROR("POP/STACK OVERFLOW",OP_CODE,CP)
          end
       else
          RETURN _FUNPUTERROR("POP/DIMENSION OVERFLOW",OP_CODE,CP)
       end   
    else
       RETURN _FUNPUTERROR("POP/STACK EXPECTED (USE)",OP_CODE,CP)
    end
  RETURN .T.
  
  FUNCTION FUNUSE()   // 228
  LOCAL EFX,FX,EAX
  LOCAL OP_CODE:=2280
    EFX:=STACK[CS]
    CWM:=CMPCWM(EFX,CWM,TopCWM)
    --CS  
    SFLAGDIR:=EFX      // direccion del stack
    EAX := ASCAN(STK_ARRAY_DIR,SFLAGDIR)  // 
    if EAX==0
       RETURN _FUNPUTERROR("USE/STACK EXPECTED",OP_CODE,CP)
    else
       SFLAGDIM:=STK_ARRAY_DIM[EAX]   // dimension actual del stack
       if SFLAGDIM==0
          SFLAGDIM:=1
          STK_ARRAY_DIM[EAX]:=1
       end   
       SFLAGROW:=STK_ARRAY_ROW[EAX]   // dimension fila
       SFLAGCOL:=STK_ARRAY_COL[EAX]   // dimension columna
       SFLAGPAG:=STK_ARRAY_PAG[EAX]   // dimension pagina
       SFLAGBLK:=STK_ARRAY_BLK[EAX]   // dimension bloque
       SFLAGTYP:=STK_ARRAY_TYP[EAX]   // tipo del stack
       SFLAGSTK:=EAX                  // posicion en STK_ARRAY_DIR que esta en uso
    end
  RETURN .T.


/******************************************************************
             FUNCIONES FAM. TRSTK_CODE
*******************************************************************/
FUNCTION TRSTK_CODE()   // 119
LOCAL EBX 
  EBX:=STACK[CS]
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  --CS        
RETURN (__PTRSTK[stk_var_02[EBX]]:EXEC())

  FUNCTION FUNTOP()   
  LOCAL EX,DIM,DIMR,DIMC,DIMP,DIMB,ETX,ERX
  LOCAL OP_CODE:=1190
    if SFLAGDIR>0   // ha sido seleccionado un array
       if SFLAGDIM==1
          if SFLAGROW>0
             if PFLAG==1
                EX:=stk_var_02[SFLAGDIR][1]
                IF VALTYPE(EX)!="A"  // SOLO SACA UNA COPIA Y LO DEJA EN TEMPORAL
                   stk_var_02[++CWM]:=EX
                ELSE
                   FUNPUTDIMS(++CWM,EX[2][2],EX[2][3],EX[2][4],EX[2][5],EX[2][6],EX[2][7])
                   ////stk_var_02[CWM]:=ACLO(EX[1])
                   DIM:=EX[2][2]
                   DIMR:=EX[2][4]
                   DIMC:=EX[2][5]
                   DIMP:=EX[2][6]
                   DIMB:=EX[2][7]
                   //////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
                   ERX:=EX[1]
                   stk_var_02[CWM]:=ERX   /////XMMLET(ERX,DIM,DIMR,DIMC,DIMP,DIMB,0)
                   
                END
             else
                EX:=stk_var_02[SFLAGDIR][SFLAGROW]
                IF VALTYPE(EX)!="A"
                   stk_var_02[++CWM]:=EX
                ELSE
                   FUNPUTDIMS(++CWM,EX[2][2],EX[2][3],EX[2][4],EX[2][5],EX[2][6],EX[2][7])

                   DIM:=EX[2][2]
                   DIMR:=EX[2][4]
                   DIMC:=EX[2][5]
                   DIMP:=EX[2][6]
                   DIMB:=EX[2][7]
                   /////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
                   ERX:=EX[1]
                   stk_var_02[CWM]:=ERX   /////XMMLET(ERX,DIM,DIMR,DIMC,DIMP,DIMB,0)
                   
                END
             end
          else
             RETURN _FUNPUTERROR("STK.TOP/STACK OVERFLOW",OP_CODE,CP)
          end
       else
          RETURN _FUNPUTERROR("STK.TOP/DIMENSION OVERFLOW",OP_CODE,CP)
       end
    else
       RETURN _FUNPUTERROR("STK.TOP/STACK EXPECTED (USE)",OP_CODE,CP)
    end
    STACK[++CS]:=CWM 
  RETURN .T.
  

FUNCTION FUNISEMPTY()   // 120
LOCAL EX
LOCAL OP_CODE:=1200
  if SFLAGDIR>0   // ha sido seleccionado un array
     if SFLAGROW==0 .and. SFLAGCOL==0 .and. SFLAGPAG==0 .and. SFLAGBLK==0
        EX:=.T.
     else
        EX:=.F.
     end       
  else
     RETURN _FUNPUTERROR("ISEMPTY/STACK EXPECTED (USE)",OP_CODE,CP)
  end
  stk_var_02[++CWM]:=EX
  STACK[++CS]:=CWM
RETURN .T.


/******************************************************************
             FUNCIONES FAM. TSTK_CODE
*******************************************************************/
FUNCTION TSTK_CODE()   // 146
LOCAL EFX,EBX,BX
LOCAL OP_CODE:=1460
  EFX:=STACK[CS]         // Fantasma
  EBX:=STACK[CS-1]       // cod funcion
  BX:=stk_var_02[EBX] 
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(EFX,CWM,TopCWM)
  CS-=2
  if BX==5    // ^DROPLIST.  borra una lista entera, puede ser un array multidimensional
     if SFLAGDIR>0   // ha sido seleccionado un array
        EAX := ASCAN(STK_ARRAY_DIR,SFLAGDIR)  // 
        SFLAGDIM:=1   // dimension actual del stack
        SFLAGROW:=0   // dimension fila
        SFLAGCOL:=0   // dimension columna
        SFLAGPAG:=0   // dimension pagina
        SFLAGBLK:=0   // dimension bloque
        STK_ARRAY_DIM[EAX]:=1   // dimension actual del stack
        STK_ARRAY_ROW[EAX]:=0   // dimension fila
        STK_ARRAY_COL[EAX]:=0   // dimension columna
        STK_ARRAY_PAG[EAX]:=0   // dimension pagina
        STK_ARRAY_BLK[EAX]:=0   // dimension bloque
        //stk_var_02[EAX]:=stacknew()
        stk_var_02[SFLAGDIR]:=stacknew()
     else
        RETURN _FUNPUTERROR("DROPLIST/STACK EXPECTED (USE)",OP_CODE,CP)
     end
  elseif BX==6    // ^QUEUE
     PFLAG:=1
  elseif BX==7    // ^DEQUE
     PFLAG:=0
  end
RETURN .T.

FUNCTION FUNSTRLOAD()   // LEE ARCHIVOS DE TEXTOS COMPLETOS Y LOS AGREGA A UNA VARIABLE
LOCAL OP_CODE:=180,BX,AX,EFX,EAX,ENX,EMX,EHX,EIX,EJX,EKX,XFROM, XTO,EVX,EWX,tSIZE
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B
//  ENX:=STACK[CS]   // line to
//  EMX:=STACK[CS-1]   // line from
//  EAX:=STACK[CS-2]   // file
//  CWM:=CMPCWM(EAX,CWM,TopCWM)
//  CWM:=CMPCWM(EMX,CWM,TopCWM)
//  CWM:=CMPCWM(ENX,CWM,TopCWM)
  ///CS-=2; ++CWM
  
  EAX:=STACK[CS]   // file
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  ++CWM

  AX:=stk_var_02[EAX]
  IF VALTYPE(AX)=="C"
     IF !FILE(AX)
        RETURN _FUNPUTERROR("STRLOAD/BAD FILENAME OR NOT EXIST",OP_CODE+1,CP)
     END
     tSIZE:=CUENTALINEAS(AX,HB_OSNEWLINE())
     EFX:=FOPEN(AX)
     IF FERROR()==0
        stk_var_02[CWM]:=HB_UTF8TOSTR(FREADSTR(EFX,tSIZE[4]))
     ELSE
        RETURN _FUNPUTERROR("STRLOAD/OPEN ERROR: "+AX,OP_CODE+1,CP)
     END
     FCLOSE(EFX)
  ELSE
     IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
        IF DIM1!=1
           RETURN _FUNPUTERROR("STRLOAD/DIMENSION IDIOT ERROR",OP_CODE+3,CP)
        END

        BX:=""
        
        FOR EHX:=1 TO DIM1R
           tSIZE:=CUENTALINEAS(AX[EHX],HB_OSNEWLINE())

           EFX:=FOPEN(AX[EHX])
           IF FERROR()==0
              BX+=HB_UTF8TOSTR(FREADSTR(EFX,tSIZE[4]))
           ELSE
              RETURN _FUNPUTERROR("STRLOAD/OPEN ERROR: "+AX[EHX],OP_CODE+1,CP)
           END
           FCLOSE(EFX)
        END

        stk_var_02[CWM]:=BX
        BX:=NIL
     ELSE
        RETURN _FUNPUTERROR("STRLOAD/MATRIX FILES NOT INITIALIZED",OP_CODE,CP)
     END
  END
  STACK[CS] := CWM
RETURN .T.

/******************************************************************
                       FAMILIAS XCODE_CC 185 "CC"
*******************************************************************/
FUNCTION XCODE_CC()   // 185
LOCAL EAX,EBX
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  --CS
RETURN (__PCODCC[stk_var_02[EBX]]:EXEC(EAX))

  FUNCTION FUNSTRUC(EAX)   // STRUPPER
  LOCAL OP_CODE:=1850,BX,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=UPPER(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMMSTRING(stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,4)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRUPPER/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNSTRLC(EAX)  // STRLOWER
  LOCAL OP_CODE:=1850,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=LOWER(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMMSTRING(stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,3)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRLOWER/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRERAC(EAX)
  LOCAL OP_CODE:=1850,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C" 
       RETURN _FUNPUTERROR("STRERAC/INVALID FLAG",OP_CODE,CP)
    end
    FVWITH:=upper(FVWITH)
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=CHARREM(FVWITH, hb_UTF8tostr(AX))
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX]))
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX][EIX]))
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX][EIX]))
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX][EIX][EJX]))
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX][EIX][EJX]))
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX][EIX][EJX][EKX]))
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=CHARREM(FVWITH, hb_UTF8tostr(AX[EHX][EIX][EJX][EKX]))
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRERAC/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTR2DATE(EAX)   // ANSI2DATE()
  LOCAL OP_CODE:=1850,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=HB_VALTOSTR(STOD(AX))
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=HB_VALTOSTR(STOD(AX[EHX]))
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=HB_VALTOSTR(STOD(AX[EHX][EIX]))
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=HB_VALTOSTR(STOD(AX[EHX][EIX]))
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=HB_VALTOSTR(STOD(AX[EHX][EIX][EJX]))
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=HB_VALTOSTR(STOD(AX[EHX][EIX][EJX]))
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=HB_VALTOSTR(STOD(AX[EHX][EIX][EJX][EKX]))
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=HB_VALTOSTR(STOD(AX[EHX][EIX][EJX][EKX]))
             end; end; end; end
             END
             EXIT
          END
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STR2DATE/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRREV(EAX)
  LOCAL OP_CODE:=1850,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=IIF(LEN(AX)>0,CHARMIRR(AX),AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=IIF(LEN(AX[EHX])>0,CHARMIRR(AX[EHX]),AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=IIF(LEN(AX[EHX][EIX])>0,CHARMIRR(AX[EHX][EIX]),AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=IIF(LEN(AX[EHX][EIX])>0,CHARMIRR(AX[EHX][EIX]),AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=IIF(LEN(AX[EHX][EIX][EJX])>0,CHARMIRR(AX[EHX][EIX][EJX]),AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=IIF(LEN(AX[EHX][EIX][EJX])>0,CHARMIRR(AX[EHX][EIX][EJX]),AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(LEN(AX[EHX][EIX][EJX][EKX])>0,CHARMIRR(AX[EHX][EIX][EJX][EKX]),AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(LEN(AX[EHX][EIX][EJX][EKX])>0,CHARMIRR(AX[EHX][EIX][EJX][EKX]),AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRREV/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRTRIM(EAX)
  LOCAL OP_CODE:=1850,AX,EFX,EHX,EIX,EJX,EKX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       FVWITH:="A"
       FTWITH:="C"
    end
    FVWITH:=upper(FVWITH)
    IF !(FVWITH $ "ALR").OR.LEN(FVWITH)!=1
       FVWITH:="A"
    END
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       SWITCH FVWITH
       CASE "A"
          stk_var_02[CWM]:=ALLTRIM( AX )
          EXIT
       CASE "L"
          stk_var_02[CWM]:=LTRIM( AX )
          EXIT
       CASE "R"       
          stk_var_02[CWM]:=RTRIM( AX )
          EXIT
       END
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)          
          SWITCH FVWITH
          CASE "A"
             TEMPORAL:=XMMSTRING(AX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
             EXIT
          CASE "L"
             TEMPORAL:=XMMSTRING(AX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,1)
             EXIT
          CASE "R"
             TEMPORAL:=XMMSTRING(AX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,2)
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRTRIM/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNREADINPUT(EAX,ECX)  // convertir a array
 // LOCAL AX,BX,CX,EBX,ECX,EHX,cursor:="|"
 // LOCAL _cnt,_swpto
  LOCAL OP_CODE:=1855
  if SW_FHNDLOUT==1 
     outstd( "****** Entrada de datos en OUT activo"+_CR)
     BX:=""
  else  
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    
    AX:=stk_var_02[EAX]
    if VALTYPE(AX)!="C"
       RETURN _FUNPUTERROR("RAWINPUT/ARGUMENT STRING REQUIERED",OP_CODE,CP)
    end
    
       if ":" $ AX
          EAX:=at(":",AX)
          EBX:=alltrim(substr(AX,1,EAX-1))
       else
          RETURN _FUNPUTERROR("RAWINPUT/SPACE VAR REQUIERED",OP_CODE,CP)
       end
       if "N"!=EBX .and. "S"!=EBX .and. "s"!=EBX .and. "D"!=EBX
          RETURN _FUNPUTERROR("RAWINPUT/INVALID FORMAT TYPE",OP_CODE,CP)
       end 
       ECX:=val(substr(AX,EAX+1,len(AX)))  //_largo
       
    BX:=INPUTDATOS(CX,ECX,EBX)
  end
 
    stk_var_02[CWM]:=BX
    STACK[CS] := CWM
  RETURN .T.

FUNCTION INPUTDATOS(ENTRADA,TOPE,TIPO)
LOCAL INICIO,s,p,pt,px,xlen,m,c,i,CX,SW,swPto,swDate:=.F.,cColor
  INICIO:=ROW()
  s:=array(TOPE)
  c:=0
  p:=1
  pt:=COL()
  px:=COL()
  xlen:=pt+1
  swPto:=.F.
  setpos(INICIO,pt)
  nLEN:=LEN(ENTRADA)
  if nLEN>0
     if TIPO=="D"
        setpos(INICIO,pt);outstd(replicate(" ",nLEN))
        ENTRADA:=strtran(ENTRADA,"/","")
        TOPE:=LEN(ENTRADA)
        if TOPE<8
           ENTRADA:=ENTRADA+REPLICATE(" ",8-TOPE)
           TOPE:=8
        elseif TOPE>8
           ENTRADA:=substr(ENTRADA,1,8)
           TOPE:=8
        end
        s:=array(TOPE)
        nLEN:=TOPE
        for i:=1 to nLEN
           hb_keyPut(asc(substr(ENTRADA,i,1)))
        end
        TIPO:="N"
        swDate:=.T.
     else
        for i:=1 to nLEN
           hb_keyPut(asc(substr(ENTRADA,i,1)))
        end
     end
     putkey(19,nLEN)
  else
     if TIPO=="D"
        for i:=1 to 8
           hb_keyPut(32)
        next
        putkey(19,8)
        TIPO:="N"
        TOPE:=8
        s:={"","","","","","","",""}
        swDate:=.T.
     end
  end
  
  hb_gcAll()
  cColor:=setcolor()
  while .T.
     c=inkey(0)
     if c==13
       if swDate  // otra forma de ingreso
          if len(s)==8
             for i:=1 to 8
                if s[i]==NIL
                   s[i]:=" "
                end
             end
             m:=s[1]+s[2]+"/"+s[3]+s[4]+"/"+s[5]+s[6]+s[7]+s[8]
             if HB_VALTOSTR(CTOD(m))=="  /  /    "
                //hb_keyput(27)
                //cColor:=setcolor()
                setcolor("R+/N")
                exit
             else
                exit
             end
          else
             //hb_keyPut(27)
             //cColor:=setcolor()
             setcolor("R+/N")
             exit
          end
       else
          exit
       end
     elseif c==24   // flecha abajo
       if swDate  // otra forma de ingreso
          if len(s)==8
             for i:=1 to 8
                if s[i]==NIL
                   s[i]:=" "
                end
             end
             m:=s[1]+s[2]+"/"+s[3]+s[4]+"/"+s[5]+s[6]+s[7]+s[8]
             if HB_VALTOSTR(CTOD(m))=="  /  /    "
                //hb_keyput(27)
                //cColor:=setcolor()
                setcolor("R+/N")
                exit
             else
                hb_keyput(24)
                exit
             end
          else
             //hb_keyPut(27)
             //cColor:=setcolor()
             setcolor("R+/N")
             exit
          end
       else
          hb_keyput(24)
          exit
       end
       
     elseif c==5    // flecha arriba
       if swDate  // otra forma de ingreso
          if len(s)==8
             for i:=1 to 8
                if s[i]==NIL
                   s[i]:=" "
                end
             end
             m:=s[1]+s[2]+"/"+s[3]+s[4]+"/"+s[5]+s[6]+s[7]+s[8]
             if HB_VALTOSTR(CTOD(m))=="  /  /    "
                //hb_keyput(27)
                //cColor:=setcolor()
                setcolor("R+/N")
                exit
             else
                hb_keyput(5)
                exit
             end
          else
             //hb_keyPut(27)
             //cColor:=setcolor()
             setcolor("R+/N")
             exit
          end
       else
          hb_keyput(5)
          exit
       end
     elseif c==3
       hb_keyput(27)
       hb_keyput(13)
       hb_keyput(27)  // afuera se procesa
     elseif c==27
         for i:=1 to TOPE
           s[i]:=""
         end
       
         setpos(INICIO,pt)
         setcursor(0)
         for i:=1 to xlen-pt-1
           outstd(" ")
         end
         setcursor(1)
         c:=" "
         p:=1
         px:=pt
         xlen:=pt+1
         swPto:=.F.
         setpos(INICIO,px)

     elseif c==1   // CTRL-A  BOL
       if p>1
          setcursor(0)
          putkey(19,p-1)
          setcursor(1)
       end
           
     elseif c==6   //  CTRL-F EOL
        if p<len(s)
          setcursor(0)
          putkey(4,len(s)-p+1)
          setcursor(1)

        end
        
     elseif c==19
       if p>1
          --p; --px
       end
       setpos(INICIO,px)
     elseif c==4
       if px<xlen-1
         ++px; ++p
       end
       setpos(INICIO,px)

     elseif c==7
       if xlen-pt>p
         --xlen
         if s[p]=="."
            swPto:=.F.
         end
         adel(s,p)
         setpos(INICIO,pt)
         for i:=1 to xlen-pt-1
           outstd(s[i])
         end   
         setpos(INICIO,xlen-1);outstd(" ")
         setpos(INICIO,px)
       end
     elseif c==8
       if px>pt
         --p
         if s[p]=="."
            swPto:=.F.
         end
         s[p]:="" 
         --xlen
         adel(s,p)
         //asize(s,len(s)-1)
         setpos(INICIO,pt)
         for i:=1 to xlen-pt-1
           outstd(s[i])
         end   
         setpos(INICIO,xlen-1);outstd(" ")
         setpos(INICIO,--px)
       end

     else
       if xlen<=TOPE+pt
          /*xc:=32
          if c==194 .or. c==195
             xc:=inkey()
          end
          c:=CARTOSTR(c,xc) */
          c:=CARACTESPE(c)

          if c!=0
             SW:=.F.
             if TIPO=="N"
                if chr(c) $ "0123456789"
                   SW:=.T.
                elseif chr(c)=="-".and. !swDate
                   if p==1
                      SW:=.T.
                   end
                elseif chr(c)=="." .and. !swDate
                   if !swPto
                      SW:=.T.
                      swPto:=.T.
                   end
                end

             elseif TIPO=="S"
                SW:=.T.
                CX:=upper(chr(c))
                c:=asc(CX)
             elseif TIPO=="s"
                SW:=.T.
             end
             if SW      
                if px<xlen
                  ains(s,p)
                  ++xlen; ++px
                  s[p]:=chr(c)
                  ++p
                else
                  s[p]:=chr(c) ; ++xlen; ++p; ++px
                end
                setpos(INICIO,pt)
                setcursor(0)
                for i:=1 to xlen-pt-1
                  outstd(s[i])
                end
                setcursor(1)
                setpos(INICIO,px)
             end
          end
       end
     end
  end
  m:=""

  if swDate
     m+=s[1]+s[2]+"/"+s[3]+s[4]+"/"+s[5]+s[6]+s[7]+s[8]
     //setpos(INICIO,pt); outstd(m)
     //setcolor(cColor)
  else
     for i:=1 to xlen-pt-1
        m+=s[i]
     end
     
     if TIPO=="N"
        if "-." $ m
           m:=strtran(m,"-.","-0.")
        end
        if substr(m,len(m),1)=="."
           m:=substr(m,1,len(m)-1)
        end
        if substr(m,1,1)=="."
           m:="0"+m
        end
        if "-" $ m
           setcolor("G+")
        end
     end
  end
  setpos(INICIO,pt); outstd(m)
  setcolor(cColor)
  
  setpos(ROW(),xlen)
RETURN m 

FUNCTION CARACTESPE(cBUFF)


tBUFF:=" "
            ascVAL:=cBUFF
            if ascVAL==194 .or.ascVAL==195.or.ascVAL==207.or.ascVAL==198.or.ascVAL==197;
               .or. ascVAL==234 .or. ascVAL==180
               tBUFF:=chr(inkey())
               CX:=hb_UTF8tostr(chr(cBUFF)+tBUFF)
               CX:=ASC(CX)
            elseif ascVAL==226 .or. ascVAL==239
               ttBUFF:=" "
               tBUFF:=chr(inkey())
               ttBUFF:=chr(inkey())
               CX:=hb_UTF8tostr(chr(cBUFF)+tBUFF+ttBUFF)
               CX:=ASC(CX)
            elseif ascVAL==206
               ttBUFF:=" "
               tttBUFF:=" "
               tBUFF:=chr(inkey())
               ttBUFF:=chr(inkey())
               tttBUFF:=chr(inkey())
               CX:=hb_UTF8tostr(chr(cBUFF)+tBUFF+ttBUFF+tttBUFF)
               CX:=ASC(CX)
            else
               CX:=cBUFF
            end
RETURN CX

/*********** FUNCION DE COPIA DE MATRICES ***********/


FUNCTION XCOPIAMATRIX(EAX,EBX,DIM,ROW,COL,PAG,BLK)

  /////stk_var_02[EAX]:=ARRAY(ROW,COL,PAG,BLK)
  /////AX:=stk_var_02[EAX]

  stk_var_02[EAX]:=XMMLET(stk_var_02[EBX],DIM,ROW,COL,PAG,BLK,0)  // QUIZÁS SOLO BASTA CON ESTA
RETURN

FUNCTION XCOPIAPM(MAT,EAX,DIM,ROW,COL,PAG,BLK)
LOCAL AX
  AX:=stk_var_02[EAX]
  MAT:=XMMLET(AX,DIM,ROW,COL,PAG,BLK,0)
RETURN

FUNCTION XCOPIADURAMP(EAX,MAT,DIM,ROW,COL,PAG,BLK)
LOCAL AX
  ///stk_var_02[EAX]:=ARRAY(ROW,COL,PAG,BLK)
  ///AX:=stk_var_02[EAX]
  stk_var_02[EAX]:=XMMLET(MAT,DIM,ROW,COL,PAG,BLK,0)
RETURN

/****************************************************/

FUNCTION FUNXTOBOOL()   // 4
  LOCAL OP_CODE:=40,AX,EFX,EAX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    EAX:=STACK[CS]    // valor, argumento
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    SWITCH VALTYPE(AX)
    CASE "L"
       stk_var_02[CWM]:=AX 
       EXIT
    CASE "C"
       stk_var_02[CWM]:=IIF(LEN(AX)==0,.F.,.T.)
       EXIT
    CASE "N"
       stk_var_02[CWM]:=IIF(AX==0,.F.,.T.)
       EXIT
    CASE "A"
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          IF TYP=="L"
             FUNPUTDIMS(EAX,DIM1,"L",DIM1R,DIM1C,DIM1P,DIM1B)
             STACK[CS] := EAX
             RETURN .T.
            /* TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
             XMMLET(TEMPORAL,stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
             stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
             XMMLET(stk_var_02[CWM],TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0) */
          ELSE
             TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
             SWITCH DIM1
             CASE 1
                IF TYP=="C"
                   for EHX:=1 to DIM1R
                      TEMPORAL[EHX]:=IIF(LEN(AX[EHX])==0,.F.,.T.)
                   END
                ELSE
                   for EHX:=1 to DIM1R
                      TEMPORAL[EHX]:=IIF(AX[EHX]==0,.F.,.T.)
                   END
                END
                EXIT   
             CASE 2
                IF TYP=="C"
                   IF DIM1R<=DIM1C
                   for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX]:=IIF(LEN(AX[EHX][EIX])==0,.F.,.T.)
                   END; END
                   ELSE
                   for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX]:=IIF(LEN(AX[EHX][EIX])==0,.F.,.T.)
                   END; END
                   END
                ELSE
                   IF DIM1R<=DIM1C
                   for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX]:=IIF(AX[EHX][EIX]==0,.F.,.T.)
                   END; END
                   ELSE
                   for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX]:=IIF(AX[EHX][EIX]==0,.F.,.T.)
                   END; END
                   END
                END
                EXIT
             CASE 3
                IF TYP=="C"
                   IF DIM1R<=DIM1C
                   for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX][EJX]:=IIF(LEN(AX[EHX][EIX][EJX])==0,.F.,.T.)
                   END; END; END
                   ELSE
                   for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX][EJX]:=IIF(LEN(AX[EHX][EIX][EJX])==0,.F.,.T.)
                   END; END; END
                   END
                ELSE
                   IF DIM1R<=DIM1C
                   for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX][EJX]:=IIF(AX[EHX][EIX][EJX]==0,.F.,.T.)
                   END; END; END
                   ELSE
                   for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX][EJX]:=IIF(AX[EHX][EIX][EJX]==0,.F.,.T.)
                   END; END; END
                   END
                END
                EXIT
             CASE 4
                IF TYP=="C"
                   IF DIM1R<=DIM1C
                   for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(LEN(AX[EHX][EIX][EJX][EKX])==0,.F.,.T.)
                   end; end; end; end
                   ELSE
                   for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(LEN(AX[EHX][EIX][EJX][EKX])==0,.F.,.T.)
                   end; end; end; end
                   END
                ELSE
                   IF DIM1R<=DIM1C
                   for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(AX[EHX][EIX][EJX][EKX]==0,.F.,.T.)
                   end; end; end; end
                   ELSE
                   for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(AX[EHX][EIX][EJX][EKX]==0,.F.,.T.)
                   end; end; end; end
                   END
                END
                EXIT
             END
             ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
             stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
             FUNPUTDIMS(CWM,DIM1,"L",DIM1R,DIM1C,DIM1P,DIM1B)
             RELEASE TEMPORAL
          END
       ELSE
          RETURN _FUNPUTERROR("(%...)|XTOBOOL/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       EXIT
    END
    STACK[CS] := CWM
RETURN .T.

FUNCTION FUNTONUMBER()  // 46
LOCAL OP_CODE:=460,AX,EFX,EAX,EVX,TEMPORAL
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
EAX:=STACK[CS]    // valor, argumento
CWM:=CMPCWM(EAX,CWM,TopCWM)
++CWM
AX:=stk_var_02[EAX]
EVX:=VALTYPE(AX)
  IF EVX!="A"
     if EVX=="N"
        stk_var_02[CWM]:=AX
     else
        stk_var_02[CWM]:=IIF(EVX=="L",iif(AX,1,0),VAL(AX))
     end
  ELSE
     IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
        if TYP=="N"
           FUNPUTDIMS(EAX,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
           STACK[CS] := EAX
           RETURN .T.
           
         //  TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
         //  XMMLET(TEMPORAL,stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
         //  stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
         //  XMMLET(stk_var_02[CWM],TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0) 
        else
           TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           SWITCH DIM1
           CASE 1
              SWITCH TYP
              CASE "C"
                 for EHX:=1 to DIM1R
                    TEMPORAL[EHX]:=VAL(AX[EHX])
                 end
                 EXIT
              CASE "L"
                 for EHX:=1 to DIM1R
                    TEMPORAL[EHX]:=IIF(AX[EHX],1,0)
                 end
                 EXIT
              END
              EXIT
           CASE 2
              SWITCH TYP
              CASE "C"
                 IF DIM1R<=DIM1C
                 for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX]:=VAL(AX[EHX][EIX])
                 end; end
                 ELSE
                 for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX]:=VAL(AX[EHX][EIX])
                 end; end
                 END
                 EXIT
              CASE "L"
                 IF DIM1R<=DIM1C
                 for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX]:=IIF(AX[EHX][EIX],1,0)
                 end; end
                 ELSE
                 for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                      TEMPORAL[EHX][EIX]:=IIF(AX[EHX][EIX],1,0)
                 end; end
                 END
                 EXIT
              END
              EXIT
           CASE 3
              SWITCH TYP
              CASE "C"
                 IF DIM1R<=DIM1C
                 for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                    TEMPORAL[EHX][EIX][EJX]:=VAL(AX[EHX][EIX][EJX])
                 end; end; end
                 ELSE
                 for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                    TEMPORAL[EHX][EIX][EJX]:=VAL(AX[EHX][EIX][EJX])
                 end; end; end
                 END
                 EXIT
              CASE "L"
                 IF DIM1R<=DIM1C
                 for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                    TEMPORAL[EHX][EIX][EJX]:=IIF(AX[EHX][EIX][EJX],1,0)
                 end; end; end
                 ELSE
                 for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                    TEMPORAL[EHX][EIX][EJX]:=IIF(AX[EHX][EIX][EJX],1,0)
                 end; end; end
                 END
                 EXIT
              END
              EXIT
           CASE 4
              SWITCH TYP
              CASE "C"
                 IF DIM1R<=DIM1C
                 for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                    TEMPORAL[EHX][EIX][EJX][EKX]:=VAL(AX[EHX][EIX][EJX][EKX])
                 end; end; end; end
                 ELSE
                 for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                    TEMPORAL[EHX][EIX][EJX][EKX]:=VAL(AX[EHX][EIX][EJX][EKX])
                 end; end; end; end
                 END
                 EXIT
              CASE "L"
                 IF DIM1R<=DIM1C
                 for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                    TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(AX[EHX][EIX][EJX][EKX],1,0)
                 end; end; end; end
                 ELSE
                 for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                    TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(AX[EHX][EIX][EJX][EKX],1,0)
                 end; end; end; end
                 END
                 EXIT
              END
              EXIT
           END
           /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
           stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
           FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
           RELEASE TEMPORAL
        end
     ELSE
        RETURN _FUNPUTERROR("(#...),X2NUM/MATRIX NOT INITIALIZED",OP_CODE,CP)
     END
  END
  STACK[CS] := CWM
RETURN .T.

FUNCTION FUNXTOSTACK()   // 205
LOCAL OP_CODE:=2050,AX,EFX,EAX,EVX
LOCAL DIM,DIMR,DIMC,DIMP,DIMB,TYP,TEMPORAL
  EAX:=STACK[CS]    // valor, argumento
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  ++CWM
  AX:=stk_var_02[EAX]
  EVX:=VALTYPE(AX)
  IF VALTYPE(AX)!="A"
     FUNPUTDIMS(++CWM,1,VALTYPE(AX),1,0,0,0)
     stk_var_02[CWM]:={AX}
  ELSE
  //  FUNGETDIMS(EAX,@EFX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
  //  FUNPUTDIMS(EAX,DIM,TYP,DIMR,DIMC,DIMP,DIMB)
    STACK[CS]:=EAX 
    RETURN .T.
     
    // FUNPUTDIMS(++CWM,DIM,TYP,DIMR,DIMC,DIMP,DIMB)
    /* TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     XMMLET(TEMPORAL,AX,DIM,DIMR,DIMC,DIMP,DIMB,0)
     stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     XMMLET(stk_var_02[CWM],TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0) */
  END
STACK[CS] := CWM
RETURN .T.


/******************************************************************
                       FAMILIAS xcode_nc 69 "NC"
*******************************************************************/
FUNCTION XCODE_NC()    // 69
LOCAL EAX,EBX
  EAX:=STACK[CS]    // valor, argumento
  EBX:=STACK[CS-1]  // codigo de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  --CS
RETURN (__PXCODNC[stk_var_02[EBX]]:EXEC(EAX))
  
  FUNCTION FUNSTRLEN(EAX)
  LOCAL OP_CODE:=690,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    FVWITH:=" "  // POR DEFECTO ESPACIO
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=LEN( AX )
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMMLET(AX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,5)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRLEN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRWCOUNT(EAX)
  LOCAL OP_CODE:=690,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    FVWITH:=" "  // POR DEFECTO ESPACIO
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=NUMTOKEN(hb_UTF8tostr( AX ),FVWITH)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX]),FVWITH)
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX]),FVWITH)
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX]),FVWITH)
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX]),FVWITH)
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX]),FVWITH)
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX][EKX]),FVWITH)
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX][EKX]),FVWITH)
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRWCOUNT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRNTOK(EAX)  // STRNTOK  (flag "<token>") entrega la cantidad de tokens
  LOCAL OP_CODE:=690,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C" .or. FVWITH==""
       FVWITH:=" "  // POR DEFECTO ESPACIO
       FTWITH:="C"
    end
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=NUMTOKEN(hb_UTF8tostr( AX ),FVWITH)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX]),FVWITH)
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX]),FVWITH)
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX]),FVWITH)
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX]),FVWITH)
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX]),FVWITH)
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX][EKX]),FVWITH)
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=NUMTOKEN(hb_UTF8tostr(AX[EHX][EIX][EJX][EKX]),FVWITH)
             end; end; end; end
             END
             EXIT
          END
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRNTOK/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNASC(EAX)    // $ car ASC() valor ascii del caracter introducido 
  LOCAL OP_CODE:=690,AX,EFX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=ASC(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=ASC(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=ASC(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=ASC(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=ASC(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=ASC(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=ASC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=ASC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("ASC/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
       

/******************************************************************
                       FAMILIAS xcode2_nc 21 "NC"
*******************************************************************/
FUNCTION XCODE2_NC()   // 21
LOCAL EAX,EBX
  EAX:=STACK[CS]       // valor, argumento
  EBX:=STACK[CS-1]     // codigo de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  --CS
RETURN (__PXCOD2NC[stk_var_02[EBX]]:EXEC(EAX))


  FUNCTION FUNETOD(EAX)     // E2D() notacion cientifica-->numero
  LOCAL OP_CODE:=2110,AX,EFX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=E2D(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=E2D(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=E2D(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=E2D(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=E2D(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=E2D(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=E2D(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=E2D(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("E2D/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM    
  RETURN .T.

  FUNCTION FUNSTRLCOUNT(EAX)     // STRLCOUNT   cuenta lineas de un string con CR
  LOCAL OP_CODE:=2100,AX,EFX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=STRCUENTALINEAS(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=STRCUENTALINEAS(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=STRCUENTALINEAS(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=STRCUENTALINEAS(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=STRCUENTALINEAS(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=STRCUENTALINEAS(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=STRCUENTALINEAS(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=STRCUENTALINEAS(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("STRLCOUNT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM    
  RETURN .T.
  
  FUNCTION FUNBASEBDEC(EAX)   // base.bdec  binario a decimal
  LOCAL OP_CODE:=2100,AX,EFX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=BINTODEC(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=BINTODEC(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=BINTODEC(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=BINTODEC(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=BINTODEC(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=BINTODEC(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C 
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=BINTODEC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=BINTODEC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("BASE.BDEC/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBASEHDEC(EAX)   // base.hdec  hexa a decimal
  LOCAL OP_CODE:=2100,AX,EFX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=HEXATODEC(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=HEXATODEC(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=HEXATODEC(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=HEXATODEC(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=HEXATODEC(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=HEXATODEC(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=HEXATODEC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=HEXATODEC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("BASE.HDEC/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBASEODEC(EAX)   // base.odec  octal a decimal
  LOCAL OP_CODE:=2100,AX,EFX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
    AX:=stk_var_02[EAX]
    IF VALTYPE(AX)=="C"
       stk_var_02[CWM]:=OCTALTODEC(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                TEMPORAL[EHX]:=OCTALTODEC(AX[EHX])
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX]:=OCTALTODEC(AX[EHX][EIX])
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX]:=OCTALTODEC(AX[EHX][EIX])
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=OCTALTODEC(AX[EHX][EIX][EJX])
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX]:=OCTALTODEC(AX[EHX][EIX][EJX])
             end; end; end
             END
             EXIT
          CASE 4
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=HEXATODEC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                TEMPORAL[EHX][EIX][EJX][EKX]:=HEXATODEC(AX[EHX][EIX][EJX][EKX])
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("BASE.ODEC/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSTRCOUNT(EAX)      // STRCOUNT cad (flag)
  LOCAL OP_CODE:=210
  LOCAL AX,EHX,EIX,EJX,EKX,ECX,EDX,TEMPORAL
  LOCAL DIM,TYP,DIMR,DIMC,DIMP,DIMB
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C" 
       RETURN _FUNPUTERROR("STRCOUNT/FLAG NOT DEFINED",OP_CODE,CP)
    end
    FVWITH:=upper(FVWITH)
    IF VALTYPE(stk_var_02[EAX])=="C"
       SWITCH FVWITH
       CASE "L"  
          AX:=CHARONLY(hb_UTF8tostr("abcdefghijklmnñopqrstuvwxyz"),hb_UTF8tostr(stk_var_02[EAX]))
          EXIT
       CASE "LU" 
          AX:=CHARONLY(hb_UTF8tostr("abcdefghijklmnñopqrstuvwxyzABCDEFGHIJKLMNÑOPQRSTUVWXYZ"),;
                           hb_UTF8tostr(stk_var_02[EAX]))
          EXIT
       CASE "U"  
          AX:=CHARONLY(hb_UTF8tostr("ABCDEFGHIJKLMNÑOPQRSTUVWXYZ"),hb_UTF8tostr(stk_var_02[EAX]))
          EXIT
       CASE "N"  
          AX:=CHARONLY("0123456789",stk_var_02[EAX])
          EXIT
       OTHERWISE
          AX:=CHARONLY(FVWITH,stk_var_02[EAX])
       end
       stk_var_02[CWM]:=LEN(AX)
    ELSE
       SWITCH FVWITH
       CASE "L"
          ECX:=hb_UTF8tostr("abcdefghijklmnñopqrstuvwxyz")
          EXIT
       CASE "LU"
          ECX:=hb_UTF8tostr("abcdefghijklmnñopqrstuvwxyzABCDEFGHIJKLMNÑOPQRSTUVWXYZ")
          EXIT
       CASE "U"
          ECX:=hb_UTF8tostr("ABCDEFGHIJKLMNÑOPQRSTUVWXYZ")
          EXIT
       CASE "N"
          ECX:="0123456789"
          EXIT
       OTHERWISE
          ECX:=FVWITH
       end
       IF FUNGETDIMS(EAX,@EDX,@DIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
          TEMPORAL:=ARRAY(DIMR,DIMC,DIMP,DIMB)
          SWITCH DIM
          CASE 1
             FOR EHX:=1 TO DIMR
                TEMPORAL[EHX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX] )))
             END
             EXIT
          CASE 2
             IF DIMR<=DIMC
             FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                TEMPORAL[EHX][EIX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX][EIX] )))
             END; END
             ELSE
             FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                TEMPORAL[EHX][EIX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX][EIX] )))
             END; END
             END
             EXIT
          CASE 3
             IF DIMR<=DIMC
             FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                TEMPORAL[EHX][EIX][EJX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX][EIX][EJX] )))
             END; END; END
             ELSE
             FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                TEMPORAL[EHX][EIX][EJX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX][EIX][EJX] )))
             END; END; END
             END
             EXIT
          CASE 4
             IF DIMR<=DIMC
             FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EHX:=1 TO DIMR; FOR EIX:=1 TO DIMC
                TEMPORAL[EHX][EIX][EJX][EKX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX][EIX][EJX][EKX] )))
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIMB; FOR EJX:=1 TO DIMP; FOR EIX:=1 TO DIMC; FOR EHX:=1 TO DIMR
                TEMPORAL[EHX][EIX][EJX][EKX]:=LEN(CHARONLY(ECX,hb_UTF8tostr( stk_var_02[EAX][EHX][EIX][EJX][EKX] )))
             END; END; END; END
             END
             EXIT
          END
       ELSE
          RETURN _FUNPUTERROR("STRCOUNT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       ///////stk_var_02[CWM]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
       stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM,DIMR,DIMC,DIMP,DIMB,0)
       FUNPUTDIMS(CWM,DIM,"N",DIMR,DIMC,DIMP,DIMB)
       RELEASE TEMPORAL
    END
    STACK[CS] := CWM
  RETURN .T.       


/******************************************************************
                 FAM. OPERACIONES FECHAS TDATE_ALLCODE
*******************************************************************/
  FUNCTION TDATE_CODE()  // 221
  LOCAL EAX,EBX
    EAX:=STACK[CS]    // valor, argumento
    EBX:=STACK[CS-1]  // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM
  RETURN (__PTDAT[stk_var_02[EBX]]:EXEC(EAX))
  
    FUNCTION FUNDATEANSI(EAX)
    LOCAL OP_CODE:=2210,AX,EFX,TEMPORAL
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=DTOS(CTOD(AX))
      ELSE
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,0,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE2ANSI/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END
      STACK[--CS] := CWM
    RETURN .T.
    
    FUNCTION FUNDATEBQUARTER(EAX)  // inicio de cuatrimestre
    LOCAL OP_CODE:=2210,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=DTOC(XBOQ(CTOD(AX)))
      ELSE
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            SWITCH DIM1
            CASE 1
               for EHX:=1 to DIM1R
                  TEMPORAL[EHX]:=DTOC(XBOQ(CTOD(AX[EHX])))
               end
               EXIT
            CASE 2
               IF DIM1R<=DIM1C
               for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX]:=DTOC(XBOQ(CTOD(AX[EHX][EIX])))
               end; end
               ELSE
               for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX]:=DTOC(XBOQ(CTOD(AX[EHX][EIX])))
               end; end
               END
               EXIT
            CASE 3
               IF DIM1R<=DIM1C
               for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX][EJX]:=DTOC(XBOQ(CTOD(AX[EHX][EIX][EJX])))
               end; end; end
               ELSE
               for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX][EJX]:=DTOC(XBOQ(CTOD(AX[EHX][EIX][EJX])))
               end; end; end
               END
               EXIT
            CASE 4
               IF DIM1R<=DIM1C
               for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX][EJX][EKX]:=DTOC(XBOQ(CTOD(AX[EHX][EIX][EJX][EKX])))
               end; end; end; end
               ELSE
               for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX][EJX][EKX]:=DTOC(XBOQ(CTOD(AX[EHX][EIX][EJX][EKX])))
               end; end; end; end
               END
               EXIT
            END 
            ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL  ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.BQUARTER/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END
      STACK[--CS] := CWM
    RETURN .T.
    
    FUNCTION FUNDATEEQUARTER(EAX)  // fin de cuatrimestre
    LOCAL OP_CODE:=2210,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=DTOC(XEOQ(CTOD(AX)))
      ELSE
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            SWITCH DIM1
            CASE 1
               for EHX:=1 to DIM1R
                  TEMPORAL[EHX]:=DTOC(XEOQ(CTOD(AX[EHX])))
               end
               EXIT
            CASE 2
               IF DIM1R<=DIM1C
               for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX]:=DTOC(XEOQ(CTOD(AX[EHX][EIX])))
               end; end
               ELSE
               for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX]:=DTOC(XEOQ(CTOD(AX[EHX][EIX])))
               end; end
               END
               EXIT
            CASE 3
               IF DIM1R<=DIM1C
               for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX][EJX]:=DTOC(XEOQ(CTOD(AX[EHX][EIX][EJX])))
               end; end; end
               ELSE
               for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX][EJX]:=DTOC(XEOQ(CTOD(AX[EHX][EIX][EJX])))
               end; end; end
               END
               EXIT
            OTHERWISE
               IF DIM1R<=DIM1C    
               for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX][EJX][EKX]:=DTOC(XEOQ(CTOD(AX[EHX][EIX][EJX][EKX])))
               end; end; end; end
               ELSE
               for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX][EJX][EKX]:=DTOC(XEOQ(CTOD(AX[EHX][EIX][EJX][EKX])))
               end; end; end; end
               END
               EXIT
            END
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////  XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.EQUARTER/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END
      STACK[--CS] := CWM
    RETURN .T.
    
    FUNCTION FUNDATESDWEEK(EAX)
    LOCAL OP_CODE:=2210,CX,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         CX:=CTOD(AX)
         if DOW(CX)>0
            stk_var_02[CWM]:=_XU_SEMANA[DOW(CX)]
         else
            RETURN _FUNPUTERROR("DATE.SDWEEK/FUCKING ARGUMENTS",OP_CODE,CP)
         end
      ELSE
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,1,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL  ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.SDWEEK/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END
      STACK[--CS] := CWM
    RETURN .T.
    
    FUNCTION FUNDATESMONTH(EAX)
    LOCAL OP_CODE:=2210,CX,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         CX:=MONTH(CTOD(AX))
         if CX>0
            stk_var_02[CWM]:=_XU_ANO[CX]
         else
            RETURN _FUNPUTERROR("DATE.SMONTH/FUCKING ARGUMENTS",OP_CODE,CP)
         end
      ELSE
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            //////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,2,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.SMONTH/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END
      STACK[--CS] := CWM
    RETURN .T.
     
  FUNCTION TDATE2_CODE()   // 190
  LOCAL EAX,EBX
    EAX:=STACK[CS]      // valor, argumento
    EBX:=STACK[CS-1]    // codigo de funcion
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM
  RETURN (__PDAT2COD[stk_var_02[EBX]]:EXEC(EAX))
  
    FUNCTION FUNDATEDAY(EAX)
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=DAY( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,3,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.DAY/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNDATEQUARTER(EAX)   //nº de cuatrimestre
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=QUARTER( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            SWITCH DIM1
            CASE 1
               for EHX:=1 to DIM1R
                  TEMPORAL[EHX]:=QUARTER( CTOD(AX[EHX]) )
               end
               EXIT
            CASE 2
               IF DIM1R<=DIM1C
               for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX]:=QUARTER( CTOD(AX[EHX][EIX]) )
               end; end
               ELSE
               for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX]:=QUARTER( CTOD(AX[EHX][EIX]) )
               end; end
               END
               EXIT
            CASE 3
               IF DIM1R<=DIM1C
               for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX][EJX]:=QUARTER( CTOD(AX[EHX][EIX][EJX]) )
               end; end; end
               ELSE
               for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX][EJX]:=QUARTER( CTOD(AX[EHX][EIX][EJX]) )
               end; end; end
               END
               EXIT
            OTHERWISE
               IF DIM1R<=DIM1C
               for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                  TEMPORAL[EHX][EIX][EJX][EKX]:=QUARTER( CTOD(AX[EHX][EIX][EJX][EKX]) )
               end; end; end; end
               ELSE
               for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                  TEMPORAL[EHX][EIX][EJX][EKX]:=QUARTER( CTOD(AX[EHX][EIX][EJX][EKX]) )
               end; end; end; end
               END
               EXIT
            END
            /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.QUARTER/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.

    FUNCTION FUNDATEMONTH(EAX)
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=MONTH( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,4,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.MONTH/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.
    
    FUNCTION FUNDATEYEAR(EAX)
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=YEAR( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            ////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,5,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.YEAR/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.

    FUNCTION FUNDATEDWEEK(EAX)
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=DOW( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           ///// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,6,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.DWEEK/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.

    FUNCTION FUNDATEDYEAR(EAX)
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=XDOY( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
            /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,7,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.DYEAR/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.

    FUNCTION FUNDATEWEEK(EAX)
    LOCAL OP_CODE:=1900,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         stk_var_02[CWM]:=XWEEK( CTOD(AX) )
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           ///// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,8,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.WEEK/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM 
    RETURN .T.

    FUNCTION FUNDATEDMONTH(EAX)
    LOCAL OP_CODE:=1900,CX,AX,EFX
    LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
      AX:=stk_var_02[EAX]
      IF VALTYPE(AX)=="C"
         CX:=MONTH( CTOD(AX) )
         stk_var_02[CWM]:=XDAYSINMONTH(CX,XISLEAPYEAR(CTOD(AX)))
      else
         IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           ///// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            TEMPORAL:=XGETDATE(AX,10,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
            ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
            stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
            FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
            RELEASE TEMPORAL
         ELSE
            RETURN _FUNPUTERROR("DATE.DMONTH/MATRIX NOT INITIALIZED",OP_CODE,CP)
         END
      END   
      STACK[--CS] := CWM      
    RETURN .T.

  FUNCTION FUNISLEAP()   // 196
  LOCAL EAX,AX,BX,EVX,EFX,OP_CODE:=1960
  LOCAL DIM1, TYP1,DIM1R,DIM1C,DIM1P,DIM1B,TEMPORAL
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    EVX:=VALTYPE(AX)
    IF EVX=="N"
       stk_var_02[CWM]:=XISLEAPYEAR(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
         ///// TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XGETDATE(AX,9,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"L",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("ISLEAP/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNTIMENOW()   // 226
    stk_var_02[++CWM]:=TIME()
    STACK[++CS] := CWM
  RETURN .T.

  FUNCTION FUNDATENOW()   // 224
    stk_var_02[++CWM]:=DTOC(DATE())
    STACK[++CS] := CWM
  RETURN .T.
  
  FUNCTION FUNDATEDIFF()   // 207
  LOCAL AX,CX,EVX,EWX,EXX,DX,EHX,EIX,EJX,EKX,EAX,ECX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP,TEMPORAL
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,XOP_CODE:=2070
    EAX:=STACK[CS]     // fecha string
    ECX:=STACK[CS-1]   // fecha string
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM; --CS
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    if EXX=="CC" 
       stk_var_02[CWM]:=CTOD(CX)-CTOD(AX)
    else
       // obtiene EAX array DE NUMERO DE DIAS
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("DAYSDIFF/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  FECHA STRING
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("DAYSDIFF/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("DAYSDIFF/DIMENSION ERROR",XOP_CODE,CP)
             end
          end
       end
       TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       IF EXX=="AA"   // AMBOS SON MATRICES
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=CTOD(CX[EHX])-CTOD(AX[EHX])
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=CTOD(CX[EHX][EIX])-CTOD(AX[EHX][EIX])
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=CTOD(CX[EHX][EIX])-CTOD(AX[EHX][EIX])
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=CTOD(CX[EHX][EIX][EJX])-CTOD(AX[EHX][EIX][EJX])
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=CTOD(CX[EHX][EIX][EJX])-CTOD(AX[EHX][EIX][EJX])
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=CTOD(CX[EHX][EIX][EJX][EKX])-CTOD(AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=CTOD(CX[EHX][EIX][EJX][EKX])-CTOD(AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             END
             EXIT
          END 
       ELSEIF EXX=="AC"
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=CTOD(CX[EHX])-CTOD(AX)
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=CTOD(CX[EHX][EIX])-CTOD(AX)
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=CTOD(CX[EHX][EIX])-CTOD(AX)
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=CTOD(CX[EHX][EIX][EJX])-CTOD(AX)
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=CTOD(CX[EHX][EIX][EJX])-CTOD(AX)
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=CTOD(CX[EHX][EIX][EJX][EKX])-CTOD(AX)
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=CTOD(CX[EHX][EIX][EJX][EKX])-CTOD(AX)
             END; END; END; END
             END
             EXIT
          END
       END
       //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:= TEMPORAL  ////  XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"N",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    end
    STACK[CS]:=CWM
  RETURN .T.

  FUNCTION FUNDATEADD()   // 199
  LOCAL AX,CX,EVX,EWX,EXX,EHX,EIX,EJX,EKX,EAX,ECX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2,XOP_CODE:=1990
    EAX:=STACK[CS]     // dias
    ECX:=STACK[CS-1]   // fecha string
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    ++CWM
    if EXX=="CN" 
       stk_var_02[CWM]:=dtoc(CTOD(CX)+AX)
    else
       // obtiene EAX array DE NUMERO DE DIAS
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("DATEADD/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  FECHA STRING
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("DATEADD/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("DATEADD/DIMENSION ERROR",XOP_CODE,CP)
             end
          end
       end
       /////TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       IF EXX=="AA"   // AMBOS SON MATRICES
          TEMPORAL:=XGETDATE({CX,AX},12,DIM2,DIM2R,DIM2C,DIM2P,DIM2B) // 12=para AA, 11=AN
       ELSE   ///IF EXX=="AN"
          TEMPORAL:=XGETDATE({CX,AX},11,DIM2,DIM2R,DIM2C,DIM2P,DIM2B) // 12=para AA, 11=AN
       END
       //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:=TEMPORAL  /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    end
    STACK[--CS]:=CWM
  RETURN .T.

  FUNCTION FUNISTIME()   // 166
  LOCAL EAX,AX,EVX,OP_CODE:=1660,EFX,TEMPORAL
  LOCAL DIM1, TYP1,DIM1R,DIM1C,DIM1P,DIM1B
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    EVX:=VALTYPE(AX)
    IF EVX=="C"
       stk_var_02[CWM]:=XTIMEVALID(AX)
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XGETDATE(AX,14,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"L",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("ISTIME/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNMNELAP()   // 100
  LOCAL EAX,AX,EVX,OP_CODE:=1000,EFX,TEMPORAL
  LOCAL DIM1, TYP1,DIM1R,DIM1C,DIM1P,DIM1B
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    EVX:=VALTYPE(AX)
    IF EVX=="C"
       if len(AX)==0
          stk_var_02[CWM]:=SECONDS()
       else
          stk_var_02[CWM]:=SECS(AX)
       end
    ELSE
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                if len(AX[EHX])==0
                   TEMPORAL[EHX]:=SECONDS()
                else
                   TEMPORAL[EHX]:=SECS(AX[EHX])
                end
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if len(AX[EHX][EIX])==0
                   TEMPORAL[EHX][EIX]:=SECONDS()
                else
                   TEMPORAL[EHX][EIX]:=SECS(AX[EHX][EIX])
                end
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if len(AX[EHX][EIX])==0
                   TEMPORAL[EHX][EIX]:=SECONDS()
                else
                   TEMPORAL[EHX][EIX]:=SECS(AX[EHX][EIX])
                end
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if len(AX[EHX][EIX][EJX])==0
                   TEMPORAL[EHX][EIX][EJX]:=SECONDS()
                else
                   TEMPORAL[EHX][EIX][EJX]:=SECS(AX[EHX][EIX][EJX])
                end
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if len(AX[EHX][EIX][EJX])==0
                   TEMPORAL[EHX][EIX][EJX]:=SECONDS()
                else
                   TEMPORAL[EHX][EIX][EJX]:=SECS(AX[EHX][EIX][EJX])
                end
             end; end; end
             END
             EXIT
          OTHERWISE
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if len(AX[EHX][EIX][EJX][EKX])==0
                   TEMPORAL[EHX][EIX][EJX][EKX]:=SECONDS()
                else
                   TEMPORAL[EHX][EIX][EJX][EKX]:=SECS(AX[EHX][EIX][EJX][EKX])
                end
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if len(AX[EHX][EIX][EJX][EKX])==0
                   TEMPORAL[EHX][EIX][EJX][EKX]:=SECONDS()
                else
                   TEMPORAL[EHX][EIX][EJX][EKX]:=SECS(AX[EHX][EIX][EJX][EKX])
                end
             end; end; end; end
             END
             EXIT
          END
          //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL  ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          RELEASE TEMPORAL
       ELSE
          RETURN _FUNPUTERROR("SECONDS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    END
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNROUND()  // 5
  LOCAL AX,CX,EVX,EWX,EXX,EHX,EIX,EJX,EKX,EAX,ECX,EDX,TEMPORAL
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2,OP_CODE:=50
    ECX:=STACK[CS]     // numero
    EAX:=STACK[CS-1]   // precision
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    if EXX=="NN" 
       stk_var_02[CWM]:=FROUND(AX,CX)
    else
       // obtiene EAX array DE NUMERO DE DIAS
       IF !FUNGETDIMS(EAX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
          RETURN _FUNPUTERROR("ROUND/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
       TEMPORAL:=XUFUNROUND(AX,CX,DIM2,DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:=TEMPORAL
       FUNPUTDIMS(CWM,DIM2,"N",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    end
    STACK[--CS]:=CWM
  RETURN .T.
  
/**************************************************************
                 FAM. TTHREAD_CODE MISCELANEOS
**************************************************************/
  FUNCTION YMATALTER()  // 77   ins DE MATRICES
  LOCAL EAX,EBX,ECX,EDX,AX,BX,CX,DX,EX,EFX,EHX,EIX,EJX,EKX,ELX,EPX,EQX
  LOCAL ROW,COL,PAG,BLK,DIM
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B,TEMPORAL
  LOCAL OP_CODE:=770
    ECX:=STACK[CS]    // columna donde insertar
    CX:=stk_var_02[ECX]
    EBX:=STACK[CS-1]  // matriz source a insertar
    BX:=stk_var_02[EBX]
    EAX:=STACK[CS-2]  // matriz target
    AX:=stk_var_02[EAX]
    EDX:=STACK[CS-3]  // cod. funcion 1=filas, 2=cols
    DX:=stk_var_02[EDX]
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS-=3
    CWM++
    // matriz a copiar
    IF !FUNGETDIMS(EBX,@EFX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
       RETURN _FUNPUTERROR("INS MATRIX/MATRIX NOT INITIALIZED",OP_CODE,CP)
    end
   // fuente
    IF !FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.F.)
       RETURN _FUNPUTERROR("INS MATRIX/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
    end
    IF DIM1==1 .AND. DIM2==1   // MISMA DIMENSION VECTOR, DA LO MISMO SI ES FILA O COLUMNA
       IF CX>0 .AND. CX<=DIM1R
          DIM:=1; ROW:=DIM1R+DIM2R; COL:=0; PAG:=0; BLK:=0
          TEMPORAL:=ARRAY(ROW)
       ELSE
          RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
       END
       EPX:=0
       FOR EHX:=1 TO CX-1 ;  TEMPORAL[++EPX]:=AX[EHX]; END  // COPIO PRIMER BLOQUE
       FOR EHX:=1 TO DIM2R ; TEMPORAL[++EPX]:=BX[EHX]; END  // INSERTO VECTOR
       FOR EHX:=CX TO DIM1R; TEMPORAL[++EPX]:=AX[EHX]; END  // COPIO RESTO DEL BLOQUE
    ELSEIF DIM1==4.AND.DIM2==3   // VECTOR TETRA, DA LO MISMO SI ES FILA O COLUMNA
       IF DIM1R==DIM2R.AND.DIM1C==DIM2C.AND.DIM1P==DIM2P
          IF CX>0.AND.CX<=DIM1B
             DIM:=4; ROW:=DIM1R; COL:=DIM1C; PAG:=DIM1P; BLK:=DIM1B+1
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             FOR EKX:=1 TO CX-1; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX]:=AX[EHX][EIX][EJX][EKX]
             END; END; END; END
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][CX]:=BX[EHX][EIX][EJX]
             END; END; END
             FOR EKX:=CX TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                TEMPORAL[EHX][EIX][EJX][EKX+1]:=AX[EHX][EIX][EJX][EKX]
             END; END; END; END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
       END
    ELSEIF DIM1==3.AND.DIM2==2    // UNA MATRIZ 2D EN UN BLOQUE
       IF DX==1    // INSERTO FILAS:
          IF CX>0.AND.CX<=DIM1R
             DIM:=3; ROW:=DIM1R+1; COL:=DIM1C; PAG:=DIM1P; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1C==DIM2R.AND.DIM1P==DIM2C
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO CX-1; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[CX][EIX][EJX]:=BX[EIX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=CX TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX+1][EIX][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       ELSE   // INSERTO COLUMNAS
          IF CX>0.AND.CX<=DIM1C
             DIM:=3; ROW:=DIM1R; COL:=DIM1C+1; PAG:=DIM1P; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1R==DIM2R.AND.DIM1P==DIM2C
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO CX-1
                   TEMPORAL[EHX][EIX][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][CX][EJX]:=BX[EHX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=CX TO DIM1C
                   TEMPORAL[EHX][EIX+1][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       END
    ELSEIF DIM1==2 .AND. DIM2==1
       IF DX==1    // INSERTO FILAS:
          IF CX>0.AND.CX<=DIM1R
             DIM:=2; ROW:=DIM1R+1; COL:=DIM1C; PAG:=0; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1C==DIM2R
                FOR EHX:=1 TO CX-1; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX]:=AX[EHX][EIX]
                END; END
                FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[CX][EIX]:=BX[EIX]
                END; END
                FOR EHX:=CX TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX+1][EIX]:=AX[EHX][EIX]
                END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       ELSE   // INSERTO COLUMNAS
          IF CX>0.AND.CX<=DIM1C
             DIM:=2; ROW:=DIM1R; COL:=DIM1C+1; PAG:=0; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1R==DIM2R
                FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO CX-1
                   TEMPORAL[EHX][EIX]:=AX[EHX][EIX]
                END; END
                FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][CX]:=BX[EHX]
                END; END
                FOR EHX:=1 TO DIM1R; FOR EIX:=CX TO DIM1C
                   TEMPORAL[EHX][EIX+1]:=AX[EHX][EIX]
                END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       END
    ELSEIF DIM1==2 .AND. DIM2==2
       IF DX==1    // INSERTO FILAS:
          IF CX>0.AND.CX<=DIM1R
             DIM:=2; ROW:=DIM1R+DIM2R; COL:=DIM1C; PAG:=0; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1C==DIM2C
                FOR EHX:=1 TO CX-1; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX]:=AX[EHX][EIX]
                END; END
                EPX:=CX
                FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EPX][EIX]:=BX[EHX][EIX]
                END; ++EPX; END
                FOR EHX:=CX TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX+DIM2R][EIX]:=AX[EHX][EIX]
                END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       ELSE   // INSERTO COLUMNAS
          IF CX>0.AND.CX<=DIM1C
             DIM:=2; ROW:=DIM1R; COL:=DIM1C+DIM2C; PAG:=0; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1R==DIM2R
                FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO CX-1
                   TEMPORAL[EHX][EIX]:=AX[EHX][EIX]
                END; END
                FOR EHX:=1 TO DIM2R; EPX:=CX-1; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][++EPX]:=BX[EHX][EIX]
                END; END
                FOR EHX:=1 TO DIM1R; FOR EIX:=CX TO DIM1C
                   TEMPORAL[EHX][EIX+DIM2C]:=AX[EHX][EIX]
                END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       END
    ELSEIF DIM1==3 .AND. DIM2==3
       IF DX==1    // INSERTO FILAS:
          IF CX>0.AND.CX<=DIM1R
             DIM:=3; ROW:=DIM1R+DIM2R; COL:=DIM1C; PAG:=DIM1P; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1C==DIM2C.AND.DIM1P==DIM2P
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO CX-1; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; EPX:=CX
                FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EPX][EIX][EJX]:=BX[EHX][EIX][EJX]
                END; ++EPX; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=CX TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX+DIM2R][EIX][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       ELSE   // INSERTO COLUMNAS
          IF CX>0.AND.CX<=DIM1C
             DIM:=3; ROW:=DIM1R; COL:=DIM1C+DIM2C; PAG:=DIM1P; BLK:=0
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1R==DIM2R.AND.DIM1P==DIM2P
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO CX-1
                   TEMPORAL[EHX][EIX][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM2R; EPX:=CX-1; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][++EPX][EJX]:=BX[EHX][EIX][EJX]
                END; END; END
                FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=CX TO DIM1C
                   TEMPORAL[EHX][EIX+DIM2C][EJX]:=AX[EHX][EIX][EJX]
                END; END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       END
    ELSEIF DIM1==4 .AND. DIM2==4
       IF DX==1    // INSERTO FILAS:
          IF CX>0.AND.CX<=DIM1R
             DIM:=4; ROW:=DIM1R+DIM2R; COL:=DIM1C; PAG:=DIM1P; BLK:=DIM1B
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1C==DIM2C.AND.DIM1P==DIM2P.AND.DIM1B==DIM2B
                FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO CX-1; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX][EJX][EKX]:=AX[EHX][EIX][EJX][EKX]
                END; END; END; END
                FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; EPX:=CX
                FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EPX][EIX][EJX][EKX]:=BX[EHX][EIX][EJX][EKX]
                END; ++EPX; END; END; END
                FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=CX TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX+DIM2R][EIX][EJX][EKX]:=AX[EHX][EIX][EJX][EKX]
                END; END; END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       ELSE   // INSERTO COLUMNAS
          IF CX>0.AND.CX<=DIM1C
             DIM:=4; ROW:=DIM1R; COL:=DIM1C+DIM2C; PAG:=DIM1P; BLK:=DIM1B
             TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
             IF DIM1R==DIM2R.AND.DIM1P==DIM2P.AND.DIM1B==DIM2B
                FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO CX-1
                   TEMPORAL[EHX][EIX][EJX][EKX]:=AX[EHX][EIX][EJX][EKX]
                END; END; END; END
                FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM2R; EPX:=CX-1; FOR EIX:=1 TO DIM2C
                   TEMPORAL[EHX][++EPX][EJX][EKX]:=BX[EHX][EIX][EJX][EKX]
                END; END; END; END
                FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=CX TO DIM1C
                   TEMPORAL[EHX][EIX+DIM2C][EJX][EKX]:=AX[EHX][EIX][EJX][EKX]
                END; END; END; END
             ELSE
                RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
             END
          ELSE
             RETURN _FUNPUTERROR("INS MATRIX/INSERT POSITION UNDER|OVERFLOW",OP_CODE,CP)
          END
       END
    ELSE       
       RETURN _FUNPUTERROR("INS MATRIX/MATRIX DIMENSION INCOMPATIBLES",OP_CODE,CP)
    END
    //////stk_var_02[CWM]:=ARRAY(ROW,COL,PAG,BLK)
    stk_var_02[CWM]:=TEMPORAL   /////XMMLET(TEMPORAL,DIM,ROW,COL,PAG,BLK,0)
/*    STK_ARRAY_DIM[EFX]:=DIM
    STK_ARRAY_TYP[EFX]:=TYP1
    STK_ARRAY_ROW[EFX]:=ROW
    STK_ARRAY_COL[EFX]:=COL
    STK_ARRAY_PAG[EFX]:=PAG
    STK_ARRAY_BLK[EFX]:=BLK */
    RELEASE TEMPORAL
    FUNPUTDIMS(CWM,DIM,TYP1,ROW,COL,PAG,BLK)
    STACK[CS]:=CWM
  RETURN .T.

  FUNCTION XMATALTER()  // 62  XMATALTER CUT y CAT
  LOCAL EAX,EBX,ECX,EDX,CX,DX,EFX,EHX,EIX,EJX,EKX,ELX,EPX,EQX,EMX,ENX,BX
  LOCAL ROW,COL,PAG,BLK,DIM,TEMPORAL
  LOCAL DIM2,TYP2,DIM2R,DIM2C,DIM2P,DIM2B
  LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL OP_CODE:=620,FUENTEA,FUENTEB,POS
    EBX:=STACK[CS]    // matriz B
    EAX:=STACK[CS-1]  // matriz A
    ECX:=STACK[CS-2]  // cod. vertical=2 u horizontal=1
    CX:=stk_var_02[ECX]
    EDX:=STACK[CS-3]  // cod. funcion 1=cat, 2=cut
    DX:=stk_var_02[EDX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CS-=3
    ++CWM
    // analisis de dimensiones
    // posiciones (CUT) o segunda matriz de proceso, en el caso de CAT
    IF !FUNGETDIMS(EBX,@EFX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
       RETURN _FUNPUTERROR("[+/- M]/MATRIX NOT INITIALIZED",OP_CODE,CP)
    end
   // fuente
    IF !FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       RETURN _FUNPUTERROR("[+/- M]/MATRIX NOT INITIALIZED",OP_CODE,CP)
    end
    BLK:=0
    PAG:=0
    if DX==1    // CAT
       // analisis de casos:
       if TYP1!=TYP2
          RETURN _FUNPUTERROR("[+ M],CAT MATRIX/TYPES INCOMPATIBLES",OP_CODE+1,CP)
       end   
       // Evaluo casos particulares donde no importa si une horizontal o verticalmente:
       if DIM1==3 .and. DIM2==2  // Pega una página atrás de la matriz 3D
          if DIM1R==DIM2R .and. DIM1C==DIM2C
             FUENTEA:=stk_var_02[EAX]
             FUENTEB:=stk_var_02[EBX]
             TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P+1)
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=FUENTEA[EHX][EIX][EJX]
             end; end; end
             EJX:=DIM1P+1
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=FUENTEB[EHX][EIX]
             end; end
             DIM:=3; ROW:=DIM1R; COL:=DIM1C; PAG:=DIM1P+1
          else  // error!
             RETURN _FUNPUTERROR("[+ M],CAT (3D OVER 2D) MATRIX/RANGE DIFFERENT",OP_CODE+2,CP)
          end
       elseif DIM1==2 .and. DIM2==3  // pega una matriz 3D detrás de una matriz 2D
          if DIM1R==DIM2R .and. DIM1C==DIM2C
             FUENTEA:=stk_var_02[EAX]
             FUENTEB:=stk_var_02[EBX]
             TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM2P+1)
             EJX:=1
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                TEMPORAL[EHX][EIX][EJX]:=FUENTEA[EHX][EIX]
             end; end
             EPX:=2
             for EJX:=1 to DIM2P; for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                TEMPORAL[EHX][EIX][EPX]:=FUENTEB[EHX][EIX][EJX]
             end; end
             ++EPX
             end
             DIM:=3; ROW:=DIM1R; COL:=DIM1C; PAG:=DIM2P+1
          else  // error!
             RETURN _FUNPUTERROR("[+ M],CAT (2D OVER 3D) MATRIX/RANGE DIFFERENT",OP_CODE+2,CP)
          end
       else
          if CX==1   // horizontal
             if DIM1<=2 .and. DIM2<=2  // solo caso 1D y 2D
                if DIM1R==DIM2R
                   EZX:=iif(DIM1C==0,1,DIM1C)+iif(DIM2C==0,1,DIM2C)
                   TEMPORAL:=array(DIM1R,EZX)
                   FUENTEA:=stk_var_02[EAX]
                   FUENTEB:=stk_var_02[EBX]
                   //? "FUENTE=", DIM1,DIM1R,DIM1C,DIM1P,DIM1B
                   //? "DESTIN=", DIM2,DIM2R,DIM2C,DIM2P,DIM2B
                   //quit
                   if DIM1C==0 .and. DIM2C==0   // concateno 2 vectores=2D
                      for EHX:=1 to DIM1R
                         TEMPORAL[EHX][1]:=FUENTEA[EHX]
                       //  ? "FA=",stk_var_02[CWM][EHX][1]
                      end
                      for EHX:=1 to DIM2R
                         TEMPORAL[EHX][2]:=FUENTEB[EHX]
                       //  ? "FB=",stk_var_02[CWM][EHX][2]
                      end
                   elseif DIM1C==0   // segundo es matriz
                      for EHX:=1 to DIM1R
                         TEMPORAL[EHX][1]:=FUENTEA[EHX]
                      end
                      for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                         TEMPORAL[EHX][EIX+1]:=FUENTEB[EHX][EIX]
                      end; end
                   elseif DIM2C==0    // primero es una matriz
                      for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX]:=FUENTEA[EHX][EIX]
                      end; end
                      EPX:=DIM1C+1 
                      for EHX:=1 to DIM1R
                         TEMPORAL[EHX][EPX]:=FUENTEB[EHX]
                      end
                   else         // ambos son matrices   
                      for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX]:=FUENTEA[EHX][EIX]
                      end; end
                      for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                         TEMPORAL[EHX][DIM1C+EIX]:=FUENTEB[EHX][EIX]
                      end; end
                   end
                   DIM:=2
                   ROW:=DIM1R
                   COL:=EZX
                else   // ERROR! filas diferentes
                  // ? "FUENTE=", DIM1,DIM1R,DIM1C,DIM1P,DIM1B
                  // ? "DESTIN=", DIM2,DIM2R,DIM2C,DIM2P,DIM2B
                   RETURN _FUNPUTERROR("[+| M],HORZ CAT MATRIX/RANGE DIFFERENT",OP_CODE+2,CP)
                end
             elseif DIM1==3 .and. DIM2==3  // pega dos matrices 3D 
                if DIM1R==DIM2R .and. DIM1P==DIM2P  // aqui las columasn pueden variar
                   FUENTEA:=stk_var_02[EAX]
                   FUENTEB:=stk_var_02[EBX]
                   TEMPORAL:=ARRAY(DIM1R,DIM1C+DIM2C,DIM1P)
                   for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX][EJX]:=FUENTEA[EHX][EIX][EJX]
                   end; end; end
                   for EJX:=1 to DIM2P; for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                      TEMPORAL[EHX][DIM1C+EIX][EJX]:=FUENTEB[EHX][EIX][EJX]
                   end; end; end
                   DIM:=3
                   ROW:=DIM1R
                   COL:=DIM1C+DIM2C
                   PAG:=DIM2P
                else  // error!
                   RETURN _FUNPUTERROR("[+| M],HORZ CAT (3D JOIN 3D) MATRIX/RANGE DIFFERENT",OP_CODE+2,CP)
                end
             else  // ERROR! dimensiones incompatibles
                RETURN _FUNPUTERROR("[+| M],HORZ CAT MATRIX/DIMENSIONS INCOMPATIBLES",OP_CODE+3,CP)
             end  
          else  // es vertical! la misma weá del caso horizontal... uf! o es 3D y pega por pag CX==3
             if DIM1R==0 .or. DIM2R==0
                RETURN _FUNPUTERROR("[+- M],VERT CAT MATRIX/EMPTY MATRIX",OP_CODE+4,CP)
             end
             FUENTEA:=stk_var_02[EAX]
             FUENTEB:=stk_var_02[EBX]
             if DIM1<=2 .and. DIM2<=2  // solo caso 1D y 2D
                if DIM1C==0 .and. DIM2C==0  // ambos son vectores: concateno hacia abajo
                   TEMPORAL:=array(DIM1R+DIM2R)
                   for EHX:=1 to DIM1R
                      TEMPORAL[EHX]:=FUENTEA[EHX]
                   end
                   for EHX:=1 to DIM2R
                      TEMPORAL[DIM1R+EHX]:=FUENTEB[EHX]
                   end
                   DIM:=1
                   ROW:=DIM1R+DIM2R
                   COL:=0
                elseif DIM1C==0   // el segundo es una matriz
                   if DIM1R==DIM2C   // porque concatenaré la transp del primero
                      TEMPORAL:=ARRAY(DIM2R+1,DIM2C)  
                      for EHX:=1 to DIM1R
                         TEMPORAL[1][EHX]:=FUENTEA[EHX]
                      end 
                      for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                         TEMPORAL[1+EHX][EIX]:=FUENTEB[EHX][EIX]
                      end; end
                   else  // ERROR!
                      RETURN _FUNPUTERROR("[+- M],VERT CAT (1D OVER 2D) MATRIX/DIMS INCOMPATIBLES",OP_CODE+3,CP)
                   end
                   DIM:=2
                   ROW:=DIM2R+1
                   COL:=DIM2C
                elseif DIM2C==0   // el primero es una matriz
                   if DIM2R==DIM1C   // porque concatenaré la transp del primero
                      TEMPORAL:=ARRAY(DIM1R+1,DIM1C)  
                      for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX]:=FUENTEA[EHX][EIX]
                      end; end
                      for EHX:=1 to DIM2R
                         TEMPORAL[DIM1R+1][EHX]:=FUENTEB[EHX]
                      end 
                   else  // ERROR!
                      RETURN _FUNPUTERROR("[+- M],VERT CAT (2D OVER 1D) MATRIX/DIMS INCOMPATIBLES",OP_CODE+3,CP)
                   end
                   DIM:=2
                   ROW:=DIM1R+1
                   COL:=DIM1C
                else      // a,bos son matrices!
                   if DIM1C==DIM2C
                      TEMPORAL:=ARRAY(DIM1R+DIM2R,DIM1C)
                      for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX]:=FUENTEA[EHX][EIX]
                      end; end
                      for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                         TEMPORAL[DIM1R+EHX][EIX]:=FUENTEB[EHX][EIX]
                      end; end
                   else  // error!
                      RETURN _FUNPUTERROR("[+- M],VERT CAT (2D OVER 2D) MATRIX/DIMS INCOMPATIBLES",OP_CODE+3,CP)
                   end
                   DIM:=2
                   ROW:=DIM1R+DIM2R
                   COL:=DIM1C
                end
             elseif DIM1==3 .and. DIM2==3  // pega dos matrices 3D 
                if DIM1C==DIM2C .and. DIM1P==DIM2P  // aqui las columasn pueden variar
                   FUENTEA:=stk_var_02[EAX]
                   FUENTEB:=stk_var_02[EBX]
                   TEMPORAL:=ARRAY(DIM1R+DIM2R,DIM1C,DIM1P)
                   for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                      TEMPORAL[EHX][EIX][EJX]:=FUENTEA[EHX][EIX][EJX]
                   end; end; end
                   for EJX:=1 to DIM2P; for EHX:=1 to DIM2R; for EIX:=1 to DIM2C
                      TEMPORAL[DIM1R+EHX][EIX][EJX]:=FUENTEB[EHX][EIX][EJX]
                   end; end; end
                   DIM:=3
                   ROW:=DIM1R+DIM2R
                   COL:=DIM1C
                   PAG:=DIM2P
                else  // error!
                   RETURN _FUNPUTERROR("[+- M],VERT CAT (3D OVER 3D) MATRIX/RANGE DIFFERENT",OP_CODE+2,CP)
                end
             else  // ERROR! dimensiones incompatibles
                RETURN _FUNPUTERROR("[+- M],VERT CAT MATRIX/DIMS INCOMPATIBLES",OP_CODE+3,CP)
             end 
          end
       end                 
    else  // CUT   Copia filas o columnas. No hace CUT? Quizá...veamos la copia primero
       FVWITH := FLAG[1]   // valor
       FTWITH := UPPER(FLAG[2])   // tipo
       if FTWITH=="C"
          FVWITH:=upper(FVWITH)
       else
          FVWITH:=""
       end
       
       ////EMX:=ARRAY(DIM2R)
       EMX:=stk_var_02[EBX]    ///XMMLET(stk_var_02[EBX],DIM2,DIM2R,0,0,0,0)
       
       ENX:=LEN(EMX)
       if DIM2==1   // debe ser un vector de filas o columnas
          FUENTE:=stk_var_02[EAX]
          IF LEN(FUENTE)==0
             RETURN _FUNPUTERROR("[- M],CUT/EMPTY POS VECTOR",OP_CODE+5,CP)
          END
          /////stk_var_02[EBX]:=ASORT(stk_var_02[EBX])
          POS:=UNIQUE(ASORT(stk_var_02[EBX]),LEN(stk_var_02[EBX]),;
                  IIF(VALTYPE(stk_var_02[EBX][1])=="N",1,0)) // lo usaré para eliminar posiciones
          // con ambos, me aseguro de copiar todo lo que quiera y como quiera, pero eliminaré lo
          // necesario (EMX y ENX).
          ELX:=LEN(POS)
          if ELX==0
             RETURN _FUNPUTERROR("[- M],CUT/EMPTY POS VECTOR",OP_CODE+5,CP)
          else
             if CX==1
                if POS[ELX]>DIM1R .or. POS[1]<=0
                   RETURN _FUNPUTERROR("[-- M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+6,CP)
                end
             else
                if DIM1>=2
                   if POS[ELX]>DIM1C .or. POS[1]<=0
                      RETURN _FUNPUTERROR("[-| M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+6,CP)
                   end
                else
                   if POS[ELX]>DIM1R .or. POS[1]<=0
                      RETURN _FUNPUTERROR("[-| M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+6,CP)
                   end
                end
             end
          end
          // evaluar operación estandar sobre vectores
          if DIM1==1  // no importa que sea horiz o vert: es un vector
             TEMPORAL:=ARRAY(ENX)   // longitud del vector posicion original
             for EHX:=1 to ENX
                ////? EMX[EHX],",",FUENTE[EMX[EHX]]
                TEMPORAL[EHX]:=FUENTE[EMX[EHX]]
             end
             if FVWITH!="COPY"  // elimino las posiciones ordenadas y unicas
                BX:=ARRAY(ABS(DIM1R-ELX))
                if ELX==DIM1R   // queda vacío
                   stk_var_02[EAX]:=ARRAY(0)
                   //RELEASE BX
                   STK_ARRAY_DIM[EFX]:=1
                   STK_ARRAY_ROW[EFX]:=0
                   STK_ARRAY_COL[EFX]:=0
                   STK_ARRAY_PAG[EFX]:=0
                   STK_ARRAY_BLK[EFX]:=0
                else
                   EPX:=0
                   EQX:=1
                   for EHX:=1 to DIM1R
                       if EQX<=ELX
                          if EHX==POS[EQX] 
                             ++EQX 
                          else
                             BX[++EPX]:=FUENTE[EHX]
                          end
                       else
                          BX[++EPX]:=FUENTE[EHX] 
                       end
                   end

                   XCOPIADURAMP(EAX,BX,1,ABS(DIM1R-ELX),0,0,0)
                   
                   STK_ARRAY_ROW[EFX]:=ABS(DIM1R-ELX)
                   STK_ARRAY_COL[EFX]:=0
                   STK_ARRAY_PAG[EFX]:=0
                   STK_ARRAY_BLK[EFX]:=0
                end
             end
             DIM:=1; ROW:=ENX; COL:=0; PAG:=0; BLK:=0  // ROW:=ELX
          else
             if CX==1   // horizontal: filas
                if DIM1==2  // es una matriz
                   if POS[ELX]<=DIM1R .and. POS[1]>0
                      TEMPORAL:=ARRAY(ENX,DIM1C)
                      for EHX:=1 to ENX; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX]:=FUENTE[EMX[EHX]][EIX] 
                      end; end
                      if FVWITH!="COPY"
                         BX:=ARRAY(ABS(DIM1R-ELX),DIM1C)
                         if DIM1R==ELX  // queda vacía
                            stk_var_02[EAX]:=ARRAY(0)
                            //RELEASE BX
                            STK_ARRAY_DIM[EFX]:=1
                            STK_ARRAY_ROW[EFX]:=0
                            STK_ARRAY_COL[EFX]:=0
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0                          
                         else
                            EPX:=0
                            EQX:=1
                            for EHX:=1 to DIM1R
                               if EQX<=ELX
                                  if EHX==POS[EQX] 
                                     ++EQX 
                                  else
                                     ++EPX
                                     for EIX:=1 to DIM1C
                                        BX[EPX][EIX]:=FUENTE[EHX][EIX]
                                     end
                                  end
                               else
                                  ++EPX
                                  for EIX:=1 to DIM1C
                                     BX[EPX][EIX]:=FUENTE[EHX][EIX]
                                  end
                               end
                            end
                           
                            XCOPIADURAMP(EAX,BX,2,ABS(DIM1R-ELX),DIM1C,0,0)
                            
                            STK_ARRAY_ROW[EFX]:=ABS(DIM1R-ELX)
                            STK_ARRAY_COL[EFX]:=DIM1C
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                         end
                      end
                      //DIM:=2; ROW:=ELX; COL:=DIM1C; PAG:=0; BLK:=0
                      DIM:=2; ROW:=ENX; COL:=DIM1C; PAG:=0; BLK:=0
                   else // error
                      RETURN _FUNPUTERROR("[-- M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+6,CP)
                   end
                elseif DIM1==3  // es una matrix
                   if POS[ELX]<=DIM1R .and. POS[1]>0
                      TEMPORAL:=ARRAY(ENX,DIM1C,DIM1P)
                      for EJX:=1 to DIM1P; for EHX:=1 to ENX; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX][EJX]:=FUENTE[EMX[EHX]][EIX][EJX] 
                      end; end; end
                      if FVWITH!="COPY"
                         BX:=ARRAY(ABS(DIM1R-ELX),DIM1C,DIM1P)
                         if ELX==DIM1R
                            STK_ARRAY_DIM[EFX]:=1
                            STK_ARRAY_ROW[EFX]:=0
                            STK_ARRAY_COL[EFX]:=0
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                            stk_var_02[EAX]:=ARRAY(0)
                            //RELEASE BX
                         else                          
                            for EJX:=1 to DIM1P
                               EPX:=0
                               EQX:=1
                               for EHX:=1 to DIM1R
                                  if EQX<=ELX
                                     if EHX==POS[EQX]    
                                        ++EQX 
                                     else
                                        ++EPX
                                        for EIX:=1 to DIM1C
                                           BX[EPX][EIX][EJX]:=FUENTE[EHX][EIX][EJX]
                                        end
                                     end
                                  else
                                     ++EPX
                                     for EIX:=1 to DIM1C
                                        BX[EPX][EIX][EJX]:=FUENTE[EHX][EIX][EJX]
                                     end
                                  end   
                               end
                            end

                            XCOPIADURAMP(EAX,BX,3,ABS(DIM1R-ELX),DIM1C,DIM1P,0)
                            
                            STK_ARRAY_ROW[EFX]:=ABS(DIM1R-ELX)
                            STK_ARRAY_COL[EFX]:=DIM1C
                            STK_ARRAY_PAG[EFX]:=DIM1P
                            STK_ARRAY_BLK[EFX]:=0
                         end
                      end
                      //DIM:=3; ROW:=ELX; COL:=DIM1C; PAG:=DIM1P; BLK:=0
                      DIM:=3; ROW:=ENX; COL:=DIM1C; PAG:=DIM1P; BLK:=0
                   else // error
                      RETURN _FUNPUTERROR("[-- M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+6,CP)
                   end
                else   // es un tetramatrix
                   if POS[ELX]<=DIM1R .and. POS[1]>0
                      TEMPORAL:=ARRAY(ENX,DIM1C,DIM1P,DIM1B)
                      for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to ENX; for EIX:=1 to DIM1C
                         TEMPORAL[EHX][EIX][EJX][EKX]:=FUENTE[EMX[EHX]][EIX][EJX][EKX]
                      end; end; end; end
                      if FVWITH!="COPY"
                         BX:=ARRAY(ABS(DIM1R-ELX),DIM1C,DIM1P,DIM1B)
                         if ELX==DIM1R
                            STK_ARRAY_DIM[EFX]:=1
                            STK_ARRAY_ROW[EFX]:=0
                            STK_ARRAY_COL[EFX]:=0
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                            stk_var_02[EAX]:=ARRAY(0)
                            //RELEASE BX
                         else
                            for EKX:=1 to DIM1B
                               for EJX:=1 to DIM1P
                                  EPX:=0
                                  EQX:=1
                                  for EHX:=1 to DIM1R
                                     if EQX<=ELX
                                        if EHX==POS[EQX] 
                                           ++EQX 
                                        else
                                           ++EPX
                                           for EIX:=1 to DIM1C
                                              BX[EPX][EIX][EJX][EKX]:=FUENTE[EHX][EIX][EJX][EKX]
                                           end
                                        end
                                     else
                                        ++EPX
                                        for EIX:=1 to DIM1C
                                           BX[EPX][EIX][EJX][EKX]:=FUENTE[EHX][EIX][EJX][EKX]
                                        end
                                     end
                                  end
                               end
                            end

                            XCOPIADURAMP(EAX,BX,4,ABS(DIM1R-ELX),DIM1C,DIM1P,DIM1B)
                            
                            STK_ARRAY_ROW[EFX]:=ABS(DIM1R-ELX)
                            STK_ARRAY_COL[EFX]:=DIM1C
                            STK_ARRAY_PAG[EFX]:=DIM1P
                            STK_ARRAY_BLK[EFX]:=DIM1B
                         end
                      end
                      //DIM:=4; ROW:=ELX; COL:=DIM1C; PAG:=DIM1P; BLK:=DIM1B
                      DIM:=4; ROW:=ENX; COL:=DIM1C; PAG:=DIM1P; BLK:=DIM1B
                   else // error
                      RETURN _FUNPUTERROR("[-- M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+6,CP)
                   end
                end 
             else    // vertical: columnas
                if DIM1==2  // es una matriz
                   if POS[ELX]<=DIM1C .and. POS[1]>0
                      TEMPORAL:=ARRAY(DIM1R,ENX)
                      for EIX:=1 to ENX; for EHX:=1 to DIM1R
                         TEMPORAL[EHX][EIX]:=FUENTE[EHX][EMX[EIX]] 
                      end; end
                      if FVWITH!="COPY"
                         BX:=ARRAY(DIM1R,DIM1C-ELX)
                         if ELX==DIM1C
                            STK_ARRAY_DIM[EFX]:=1
                            STK_ARRAY_ROW[EFX]:=0
                            STK_ARRAY_COL[EFX]:=0
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                            stk_var_02[EAX]:=ARRAY(0)
                            //RELEASE BX
                         else
                            EPX:=0
                            EQX:=1
                            for EIX:=1 to DIM1C
                               if EQX<=ELX
                                  if EIX==POS[EQX] 
                                     ++EQX 
                                  else
                                     ++EPX
                                     for EHX:=1 to DIM1R
                                        BX[EHX][EPX]:=FUENTE[EHX][EIX]
                                     end
                                  end
                               else
                                  ++EPX
                                  for EHX:=1 to DIM1R
                                     BX[EHX][EPX]:=FUENTE[EHX][EIX]
                                  end
                               end
                            end

                            XCOPIADURAMP(EAX,BX,2,DIM1R,DIM1C-ELX,0,0)
                            
                            STK_ARRAY_ROW[EFX]:=DIM1R
                            STK_ARRAY_COL[EFX]:=DIM1C-ELX
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                         end
                      end
                      //DIM:=2; ROW:=DIM1R; COL:=ELX; PAG:=0; BLK:=0
                      DIM:=2; ROW:=DIM1R; COL:=ENX; PAG:=0; BLK:=0
                   else // error
                      RETURN _FUNPUTERROR("[-| M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+8,CP)
                   end
                elseif DIM1==3  // es una matrix
                   if POS[ELX]<=DIM1C .and. POS[1]>0
                      TEMPORAL:=ARRAY(DIM1R,ENX,DIM1P)
                      for EJX:=1 to DIM1P; for EIX:=1 to ENX; for EHX:=1 to DIM1R
                         TEMPORAL[EHX][EIX][EJX]:=FUENTE[EHX][EMX[EIX]][EJX] 
                      end; end; end
                      if FVWITH!="COPY"
                         BX:=ARRAY(DIM1R,DIM1C-ELX,DIM1P)
                         if ELX==DIM1C
                            STK_ARRAY_DIM[EFX]:=1
                            STK_ARRAY_ROW[EFX]:=0
                            STK_ARRAY_COL[EFX]:=0
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                            stk_var_02[EAX]:=ARRAY(0)
                            //RELEASE BX
                         else
                            for EJX:=1 to DIM1P
                               EPX:=0
                               EQX:=1
                               for EIX:=1 to DIM1C
                                  if EQX<=ELX
                                     if EIX==POS[EQX] 
                                        ++EQX 
                                     else
                                        ++EPX
                                        for EHX:=1 to DIM1R
                                           BX[EHX][EPX]:=FUENTE[EHX][EIX]
                                        end
                                     end
                                  else
                                     ++EPX
                                     for EHX:=1 to DIM1R
                                        BX[EHX][EPX]:=FUENTE[EHX][EIX]
                                     end
                                  end
                               end
                            end

                            XCOPIADURAMP(EAX,BX,3,DIM1R,DIM1C-ELX,DIM1P,0)
                            
                            STK_ARRAY_ROW[EFX]:=DIM1R
                            STK_ARRAY_COL[EFX]:=DIM1C-ELX
                            STK_ARRAY_PAG[EFX]:=DIM1P
                            STK_ARRAY_BLK[EFX]:=0
                         end
                      end
                      //DIM:=3; ROW:=DIM1R; COL:=ELX; PAG:=DIM1P; BLK:=0
                      DIM:=3; ROW:=DIM1R; COL:=ENX; PAG:=DIM1P; BLK:=0
                   else // error
                      RETURN _FUNPUTERROR("[-| M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+5,CP)
                   end
                else   // es un tetramatrix
                   if POS[ELX]<=DIM1C .and. POS[1]>0
                      TEMPORAL:=ARRAY(DIM1R,ENX,DIM1P,DIM1B)
                      for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to ENX; for EHX:=1 to DIM1R
                         TEMPORAL[EHX][EIX][EJX][EKX]:=FUENTE[EHX][EMX[EIX]][EJX][EKX]
                      end; end; end; end
                      if FVWITH!="COPY"
                         BX:=ARRAY(DIM1R,DIM1C-ELX,DIM1P,DIM1B)
                         if ELX==DIM1C
                            STK_ARRAY_DIM[EFX]:=1
                            STK_ARRAY_ROW[EFX]:=0
                            STK_ARRAY_COL[EFX]:=0
                            STK_ARRAY_PAG[EFX]:=0
                            STK_ARRAY_BLK[EFX]:=0
                            stk_var_02[EAX]:=ARRAY(0)
                            //RELEASE BX
                         else
                            for EKX:=1 to DIM1B
                               for EJX:=1 to DIM1P
                                  EPX:=0
                                  EQX:=1
                                  for EIX:=1 to DIM1C
                                     if EQX<=ELX
                                        if EIX==POS[EQX] 
                                           ++EQX 
                                        else
                                           ++EPX
                                           for EHX:=1 to DIM1R
                                              BX[EHX][EPX]:=FUENTE[EHX][EIX]
                                           end
                                        end
                                     else
                                        ++EPX
                                        for EHX:=1 to DIM1R
                                           BX[EHX][EPX]:=FUENTE[EHX][EIX]
                                        end
                                     end
                                  end
                               end
                            end

                            XCOPIADURAMP(EAX,BX,4,DIM1R,DIM1C-ELX,DIM1P,DIM1B)
                            
                            STK_ARRAY_ROW[EFX]:=DIM1R
                            STK_ARRAY_COL[EFX]:=DIM1C-ELX
                            STK_ARRAY_PAG[EFX]:=DIM1P
                            STK_ARRAY_BLK[EFX]:=DIM1B
                         end
                      end
                      //DIM:=4; ROW:=DIM1R; COL:=ELX; PAG:=DIM1P; BLK:=DIM1B
                      DIM:=4; ROW:=DIM1R; COL:=ENX; PAG:=DIM1P; BLK:=DIM1B
                   else // error
                      RETURN _FUNPUTERROR("[-| M],CUT/POS VECTOR OVERFLOW|UNDERFLOW",OP_CODE+5,CP)
                   end
                end 
             end
          end
          //RELEASE FUENTE, POS
       else  // error!
          RETURN _FUNPUTERROR("[- M],CUT/POS VECTOR ERROR",OP_CODE+6,CP)
       end
    end
    //////stk_var_02[CWM]:=ARRAY(ROW,COL,PAG,BLK)
    stk_var_02[CWM]:=TEMPORAL  ///XMMLET(TEMPORAL,DIM,ROW,COL,PAG,BLK,0)
    
    FUNPUTDIMS(CWM,DIM,TYP1,ROW,COL,PAG,BLK)
    STACK[CS]:=CWM
    ELIMINAVARS(TEMPORAL,DIM,ROW,COL,PAG,BLK)
  RETURN .T.

  FUNCTION XUCODESTATIC()   // 63    ARRAYS CONSTANTES
  LOCAL EFX,EEX,EDX,ECX,EBX,EAX,EZX,BX,EPX,EHX,EIX,EJX,EKX
  LOCAL DIM,ROW,COL,PAG,BLK,TYP,TEMPORAL
    EFX:=STACK[CS]    // bloque
    EEX:=STACK[CS-1]  // pagina  
    EDX:=STACK[CS-2]  // columnas
    ECX:=STACK[CS-3]  // filas
    EBX:=STACK[CS-4]  // tipo de la matriz
    EAX:=STACK[CS-5]  // String a macrear
    CWM:=CMPCWM(EEX,CWM,TopCWM)
    CWM:=CMPCWM(EFX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CS-=5
    ++CWM
    //EZX:=strtran(alltrim(stk_var_02[EAX]),"''","' '")
    EZX:=strtran(alltrim(stk_var_02[EAX]),"''","<COD-01201$%-VOID>")
    EZX:=strtran(EZX,"'","")

    ROW:=stk_var_02[ECX]; COL:=stk_var_02[EDX]; PAG:=stk_var_02[EEX]
    BLK:=stk_var_02[EFX]; TYP:=VALTYPE(stk_var_02[EBX])
    TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
    if BLK!=0
       DIM:=4
       EPX:=0
       IF TYP=="N"
          for EKX:=1 to BLK; for EJX:=1 to PAG; for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX][EJX][EKX]:=VAL(BX)
          end; end; end; end
       elseif TYP=="L"
          for EKX:=1 to BLK; for EJX:=1 to PAG; for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(BX=="T",.T.,.F.)
          end; end; end; end
       else
          for EKX:=1 to BLK; for EJX:=1 to PAG; for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX][EJX][EKX]:=IIF(BX=="<COD-01201$%-VOID>","",BX)
          end; end; end; end
       END
    elseif PAG!=0
       DIM:=3
       EPX:=0
       IF TYP=="N"
          for EJX:=1 to PAG; for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX][EJX]:=VAL(BX)
          end; end; end
       ELSEIF TYP=="L"
          for EJX:=1 to PAG; for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX][EJX]:=IIF(BX=="T",.T.,.F.)
          end; end; end
       else
          for EJX:=1 to PAG; for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX][EJX]:=IIF(BX=="<COD-01201$%-VOID>","",BX)
          end; end; end
       end
       
    elseif COL!=0
       DIM:=2
       EPX:=0
       if TYP=="N"
          for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX]:=VAL(BX)
          end; end
       elseif TYP=="L"
          for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX]:=IIF(BX=="T",.T.,.F.)
          end; end
       else
          for EHX:=1 to ROW; for EIX:=1 to COL
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX][EIX]:=IIF(BX=="<COD-01201$%-VOID>","",BX)
          end; end
       end
       
    else
       DIM:=1
       EPX:=0
       if TYP=="N"
          for EHX:=1 to ROW
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX]:=VAL(BX)
          END
       elseif TYP=="L"
          for EHX:=1 to ROW
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX]:=IIF(BX=="T",.T.,.F.)
          END
       else
          for EHX:=1 to ROW
             BX:=alltrim(TOKEN(EZX,",",++EPX))
             TEMPORAL[EHX]:=IIF(BX=="<COD-01201$%-VOID>","",BX)
          end
       end
    end
    //////stk_var_02[CWM]:=ARRAY(ROW,COL,PAG,BLK)
    stk_var_02[CWM]:= TEMPORAL ///XMMLET(TEMPORAL,DIM,ROW,COL,PAG,BLK,0)
    FUNPUTDIMS(CWM,DIM,TYP,ROW,COL,PAG,BLK)
    RELEASE TEMPORAL
    STACK[CS]:=CWM 
  RETURN .T.
  
  FUNCTION FUNBLKCOPY()   // 73
  LOCAL EDX,ECX,EFX,ELX,EPX,EQX,ERX,ESX,ETX,TEMPORAL
  LOCAL DIM,DIMR
  LOCAL DIM1,TYP,DIM1R,DIM1C,DIM1P,DIM1B
  LOCAL DIMX0,DIMX1,DIMY0,DIMY1,DIMZ0,DIMZ1,DIMW0,DIMW1
  LOCAL OP_CODE:=730
    EDX:=STACK[CS]      // array pos
    ECX:=STACK[CS-1]    // Array fuente
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    ++CWM
    --CS        // ajusta puntero de Stack
    // posiciones
    if STK_CWMTOP>0
       EFX := STK_TEMP_DIR[STK_CWMTOP]
       if EFX!=EDX
          EFX := ASCAN(STK_ARRAY_DIR,EDX)
          DIM := STK_ARRAY_DIM[EFX]
          DIMR:=STK_ARRAY_ROW[EFX]
       else   
          DIM:=STK_TEMP_DIM[STK_CWMTOP]
          DIMR:=STK_TEMP_ROW[STK_CWMTOP]
          STK_TEMP_DIR[STK_CWMTOP]:=0
          STK_CWMTOP--
       end
    else  // es legal
       EFX := ASCAN(STK_ARRAY_DIR,EDX)
       DIM := STK_ARRAY_DIM[EFX]
       DIMR:=STK_ARRAY_ROW[EFX]
    end
    // fuente
    IF !FUNGETDIMS(ECX,@EFX,@DIM1,@TYP,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       RETURN _FUNPUTERROR("[% M],COPY BLOCK/STACK PARAMS NOT INITIALIZED",OP_CODE,CP)
    END
    // análisis de dimensiones:
    if DIM!=1 .or. DIMR<1 .or. DIMR>8
       RETURN _FUNPUTERROR("[% M],COPY BLOCK/STACK PARAMS ERROR",OP_CODE,CP)
    elseif DIM1<1
       RETURN _FUNPUTERROR("[% M],COPY BLOCK/MATRIX DIMENSION ERROR",OP_CODE,CP)
    else
       POS:=stk_var_02[EDX]
       FUENTE:=stk_var_02[ECX]
       ELX:=len(POS)
       if ELX==0
          RETURN _FUNPUTERROR("[% M],COPY BLOCK/STACK PARAMS EMPTY",OP_CODE,CP)
       else
          if ELX!=DIM1*2  // Chequeo que DIM de matriz sea correspondiente a las coordenadas
             RETURN _FUNPUTERROR("[% M],COPY BLOCK/STACK PARAMS DIM OVERFLOW",OP_CODE,CP)
          else
             for EHX:=1 to ELX
                if POS[EHX]<=0
                   RETURN _FUNPUTERROR("[% M],COPY BLOCK/STACK PARAMS OVERFLOW",OP_CODE,CP)
                end
             end
          end
       end
    end
    // paso bien: ahora hay que ver las dims mismas si no son 0 o superiores a las de la matriz
    DIM:=0; ROW:=0; COL:=0; PAG:=0; BLK:=0
    if ELX==2   // es un vector:
       DIMX0:=POS[1]; DIMX1:=POS[2]
       if DIMX0>DIMX1   // los params estan invertidos?
          ETX:=DIMX0; DIMX0:=DIMX1; DIMX1:=ETX
       end
       if DIMX1<=DIM1R    //OK
          DIM:=1
          ROW:=DIMX1-DIMX0+1
          TEMPORAL:=ARRAY(ROW)
          EPX:=0
          for EHX:=DIMX0 to DIMX1
             TEMPORAL[++EPX]:=FUENTE[EHX]
          end
       else
          RETURN _FUNPUTERROR("[% M],COPY BLOCK/STACK PARAMS OVERFLOW",OP_CODE,CP)
       end
    elseif ELX==4  // es matriz 2D
       DIMX0:=POS[1]; DIMX1:=POS[2]; DIMY0:=POS[3]; DIMY1:=POS[4]
       if DIMX0>DIMY0  // estan al reves
          ETX:=DIMX0; DIMX0:=DIMY0; DIMY0:=ETX
          ETX:=DIMX1; DIMX1:=DIMY1; DIMY1:=ETX
       end
       if DIMX1>DIMY1
          ETX:=DIMX1; DIMX1:=DIMY1; DIMY1:=ETX
       end
       if DIMY0<=DIM1R .and. DIMY1<=DIM1C
          ROW:=DIMY0-DIMX0+1
          COL:=DIMY1-DIMX1+1
          if ROW==1     //OK
             TEMPORAL:=ARRAY(COL)
             EPX:=0
             for EIX:=DIMX1 to DIMY1
                TEMPORAL[++EPX]:=FUENTE[DIMX0][EIX]
             end
             DIM:=1; ROW:=COL; COL:=0
          elseif COL==1   //OK
             TEMPORAL:=ARRAY(ROW)
             EPX:=0
             for EHX:=DIMX0 to DIMY0
                TEMPORAL[++EPX]:=FUENTE[EHX][DIMX1]
             end
             DIM:=1; COL:=0
          else       //OK
             TEMPORAL:=ARRAY(ROW,COL)
             EPX:=0
             for EHX:=DIMX0 to DIMY0
                ++EPX; EQX:=0
                for EIX:=DIMX1 to DIMY1
                   TEMPORAL[EPX][++EQX]:=FUENTE[EHX][EIX]
                end
             end
             DIM:=2
          end
       else
          RETURN _FUNPUTERROR("[% M],COPY BLOCK 2D /STACK PARAMS OVERFLOW",OP_CODE,CP)
       end
    elseif ELX==5 .or. ELX==6  // es matriz 3D
       DIMX0:=POS[1]; DIMX1:=POS[2]; DIMY0:=POS[3]; DIMY1:=POS[4]; DIMZ0:=POS[5]
       if ELX==5
          DIMZ1:=POS[5]
       else
          DIMZ1:=POS[6]
       end
       if DIMX0>DIMY0  // estan al reves las filas
          ETX:=DIMX0; DIMX0:=DIMY0; DIMY0:=ETX
          ETX:=DIMX1; DIMX1:=DIMY1; DIMY1:=ETX
       end
       if DIMX1>DIMY1   // estan al reves las columnas
          ETX:=DIMX1; DIMX1:=DIMY1; DIMY1:=ETX
       end
       if DIMZ0>DIMZ1  // orden en las paginas
          ETX:=DIMZ0; DIMZ0:=DIMZ1; DIMZ1:=ETX
       end
       if DIMY0<=DIM1R .and. DIMY1<=DIM1C .and. DIMZ1<=DIM1P
          ROW:=DIMY0-DIMX0+1
          COL:=DIMY1-DIMX1+1
          PAG:=DIMZ1-DIMZ0+1
          if PAG==1
             if ROW==1     //OK
                TEMPORAL:=ARRAY(COL)
                EPX:=0
                for EIX:=DIMX1 to DIMY1
                   TEMPORAL[++EPX]:=FUENTE[DIMX0][EIX][DIMZ0]
                end
                DIM:=1; ROW:=COL; COL:=0; PAG:=0                      
             elseif COL==1   //OK
                TEMPORAL:=ARRAY(ROW)
                EPX:=0
                for EIX:=DIMX0 to DIMY0
                   TEMPORAL[++EPX]:=FUENTE[EIX][DIMY1][DIMZ0]
                end
                DIM:=1; COL:=0; PAG:=0   
             else        //OK
                TEMPORAL:=ARRAY(ROW,COL)
                EPX:=0
                for EHX:=DIMX0 to DIMY0
                   ++EPX; EQX:=0
                   for EIX:=DIMX1 to DIMY1
                      TEMPORAL[EPX][++EQX]:=FUENTE[EHX][EIX][DIMZ0]
                   end
                end
                DIM:=2; PAG:=0
             end
          else
             if ROW==1 .and.COL==1  // OK
                TEMPORAL:=ARRAY(PAG)
                EPX:=0
                for EJX:=DIMZ0 to DIMZ1
                   TEMPORAL[++EPX]:=FUENTE[DIMX0][DIMX1][EJX]
                end
                DIM:=1; ROW:=PAG; COL:=0; PAG:=0
             elseif ROW==1  // OK
                TEMPORAL:=ARRAY(COL,PAG)
                EPX:=0
                for EHX:=DIMX1 to DIMY1
                   ++EPX; EQX:=0
                   for EIX:=DIMZ0 to DIMZ1
                      TEMPORAL[EPX][++EQX]:=FUENTE[DIMX0][EHX][EIX]
                   end
                end
                DIM:=2; ROW:=COL; COL:=PAG; PAG:=0
             elseif COL==1    // OK
                TEMPORAL:=ARRAY(ROW,PAG)
                EPX:=0
                for EHX:=DIMX0 to DIMY0
                   ++EPX; EQX:=0
                   for EIX:=DIMZ0 to DIMZ1
                      TEMPORAL[EPX][++EQX]:=FUENTE[EHX][DIMX1][EIX]
                   end
                end
                DIM:=2; COL:=PAG; PAG:=0
             else       //OK
                TEMPORAL:=ARRAY(ROW,COL,PAG)
                ERX:=0
                for EJX:=DIMZ0 to DIMZ1
                   ++ERX; EPX:=0
                   for EHX:=DIMX0 to DIMY0
                      ++EPX; EQX:=0
                      for EIX:=DIMX1 to DIMY1
                         TEMPORAL[EPX][++EQX][ERX]:=FUENTE[EHX][EIX][EJX]
                      end
                   end
                end
                DIM:=3
             end
          end
       else
          RETURN _FUNPUTERROR("[% M],COPY BLOCK 3D/STACK PARAMS OVERFLOW",OP_CODE,CP)
       end
    else       // matriz 4D
       DIMX0:=POS[1]; DIMX1:=POS[2]; DIMY0:=POS[3]; DIMY1:=POS[4]; DIMZ0:=POS[5]; DIMZ1:=POS[6]; DIMW0:=POS[7]
       if ELX==7
          DIMW1:=POS[7]
       else
          DIMW1:=POS[8]
       end
       if DIMX0>DIMY0  // estan al reves las filas
          ETX:=DIMX0; DIMX0:=DIMY0; DIMY0:=ETX
          ETX:=DIMX1; DIMX1:=DIMY1; DIMY1:=ETX
       end
       if DIMX1>DIMY1   // estan al reves las columnas
          ETX:=DIMX1; DIMX1:=DIMY1; DIMY1:=ETX
       end
       if DIMZ0>DIMZ1  // orden en las paginas
          ETX:=DIMZ0; DIMZ0:=DIMZ1; DIMZ1:=ETX
       end
       if DIMW0>DIMW1
          ETX:=DIMW0; DIMW0:=DIMW1; DIMW1:=ETX
       end
       if DIMY0<=DIM1R .and. DIMY1<=DIM1C .and. DIMZ1<=DIM1P .and. DIMW1<=DIM1B
          ROW:=DIMY0-DIMX0+1; COL:=DIMY1-DIMX1+1
          PAG:=DIMZ1-DIMZ0+1; BLK:=DIMW1-DIMW0+1
          if BLK==1   // puede ser una matriz de 3D resultante
             BLK:=0
             if PAG==1   // puede ser una matriz
                PAG:=0
                if ROW==1  // es un vector!  OK
                   TEMPORAL:=ARRAY(COL)
                   EPX:=0
                   for EIX:=DIMX1 to DIMY1
                      TEMPORAL[++EPX]:=FUENTE[DIMX0][EIX][DIMZ0][DIMW0]
                   end
                   DIM:=1; ROW:=COL; COL:=0
                elseif COL==1   //OK
                   TEMPORAL:=ARRAY(ROW)
                   EPX:=0
                   for EIX:=DIMX0 to DIMY0
                      TEMPORAL[++EPX]:=FUENTE[EIX][DIMX1][DIMZ0][DIMW0]
                   end
                   DIM:=1; COL:=0
                else   // es una matriz! OK
                   TEMPORAL:=ARRAY(ROW,COL)
                   EPX:=0
                   for EHX:=DIMX0 to DIMY0
                      ++EPX; EQX:=0
                      for EIX:=DIMX1 to DIMY1
                         TEMPORAL[EPX][++EQX]:=FUENTE[EHX][EIX][DIMZ0][DIMW0]
                      end
                   end
                   DIM:=2
                end
             else    // hay varias paginas involucradas
                if ROW==1 .and. COL==1  // es un vector!  OK
                   TEMPORAL:=ARRAY(PAG)
                   EPX:=0
                   for EIX:=DIMZ0 to DIMZ1
                      TEMPORAL[++EPX]:=FUENTE[DIMX0][DIMX1][EIX][DIMW0]
                   end
                   DIM:=1; ROW:=PAG; PAG:=0; COL:=0
                elseif ROW==1   // matriz  OK
                   TEMPORAL:=ARRAY(COL,PAG)
                   EPX:=0
                   for EIX:=DIMX1 to DIMY1
                      ++EPX; EQX:=0
                      for EHX:=DIMZ0 to DIMZ1
                         TEMPORAL[EPX][++EQX]:=FUENTE[DIMX0][EIX][EHX][DIMW0]
                      end
                   end
                   DIM:=2; ROW:=COL; COL:=PAG; PAG:=0
                elseif COL==1   // matriz   OK
                   TEMPORAL:=ARRAY(ROW,PAG)
                   EPX:=0
                   for EIX:=DIMX0 to DIMY0
                      ++EPX; EQX:=0
                      for EHX:=DIMZ0 to DIMZ1
                         TEMPORAL[EPX][++EQX]:=FUENTE[EIX][DIMX1][EHX][DIMW0]
                      end
                   end
                   DIM:=2; COL:=PAG; PAG:=0
                else       // es 3D!   OK
                   TEMPORAL:=ARRAY(ROW,COL,PAG)
                   ERX:=0
                   for EJX:=DIMZ0 to DIMZ1
                      ++ERX; EPX:=0
                      for EHX:=DIMX0 to DIMY0
                         ++EPX; EQX:=0
                         for EIX:=DIMX1 to DIMY1
                            TEMPORAL[EPX][++EQX][ERX]:=FUENTE[EHX][EIX][EJX][DIMW0]
                         end
                      end
                   end
                   DIM:=3
                end
             end
          else
             if PAG==1   // es una 3D!
                PAG:=0
                if ROW==1 .and. COL==1   // es un vector tetradimensional!  OK
                   TEMPORAL:=ARRAY(BLK)
                   EPX:=0
                   for EIX:=DIMW0 to DIMW1
                      TEMPORAL[++EPX]:=FUENTE[DIMX0][DIMX1][DIMZ0][EIX]
                   end
                   DIM:=1; ROW:=BLK; PAG:=0; COL:=0; BLK:=0
                elseif ROW==1     // OK
                   TEMPORAL:=ARRAY(COL,BLK)
                   EPX:=0
                   for EIX:=DIMX1 to DIMY1
                      ++EPX; EQX:=0
                      for EHX:=DIMW0 to DIMW1
                         TEMPORAL[EPX][++EQX]:=FUENTE[DIMX0][EIX][DIMZ0][EHX]
                      end
                   end
                   DIM:=2; ROW:=COL; COL:=BLK; BLK:=0
                elseif COL==1    //OK
                   TEMPORAL:=ARRAY(ROW,BLK)
                   EPX:=0
                   for EIX:=DIMX0 to DIMY0
                      ++EPX; EQX:=0
                      for EHX:=DIMW0 to DIMW1
                         TEMPORAL[EPX][++EQX]:=FUENTE[EIX][DIMX1][DIMZ0][EHX]
                      end
                   end
                   DIM:=2; COL:=BLK; BLK:=0
                else     // es 3D!!   OK
                   TEMPORAL:=ARRAY(ROW,COL,BLK)
                   ERX:=0
                   for EJX:=DIMW0 to DIMW1
                      ++ERX; EPX:=0
                      for EHX:=DIMX0 to DIMY0
                         ++EPX; EQX:=0
                         for EIX:=DIMX1 to DIMY1
                            TEMPORAL[EPX][++EQX][ERX]:=FUENTE[EHX][EIX][DIMZ0][EJX]
                         end
                      end
                   end
                   DIM:=3; PAG:=BLK; BLK:=0
                end
             else    // es una 4D!   OK
                if ROW==1 .and. COL==1
                   TEMPORAL:=ARRAY(PAG,BLK)
                   EPX:=0
                   for EIX:=DIMW0 to DIMW1
                      ++EPX; EQX:=0
                      for EHX:=DIMZ0 to DIMZ1
                         TEMPORAL[EPX][++EQX]:=FUENTE[DIMX0][DIMX1][EHX][EIX]
                      end
                   end
                   DIM:=2; ROW:=PAG; COL:=BLK; PAG:=0
                   BLK:=0
                elseif ROW==1  // OK
                   TEMPORAL:=ARRAY(COL,PAG,BLK)
                   ERX:=0
                   for EJX:=DIMW0 to DIMW1
                      ++ERX; EPX:=0
                      for EIX:=DIMX1 to DIMY1
                         ++EPX; EQX:=0
                         for EHX:=DIMZ0 to DIMZ1
                            TEMPORAL[EPX][++EQX][ERX]:=FUENTE[DIMX0][EIX][EHX][EJX]
                         end
                      end
                   end
                   DIM:=3; ROW:=COL; COL:=PAG; PAG:=BLK; BLK:=0
                elseif COL==1   // OK
                   TEMPORAL:=ARRAY(ROW,PAG,BLK)
                   ERX:=0
                   for EJX:=DIMW0 to DIMW1
                      ++ERX; EPX:=0
                      for EHX:=DIMX0 to DIMY0
                         ++EPX; EQX:=0
                         for EIX:=DIMZ0 to DIMZ1
                            TEMPORAL[EPX][++EQX][ERX]:=FUENTE[EHX][DIMY1][EIX][EJX]
                         end
                      end
                   end
                   DIM:=3; COL:=PAG; PAG:=BLK; BLK:=0
                else   // es completa!   OK
                   TEMPORAL:=ARRAY(ROW,COL,PAG,BLK)
                   ESX:=0
                   for EKX:=DIMW0 to DIMW1
                      ++ESX; ERX:=0
                      for EJX:=DIMZ0 to DIMZ1
                         ++ERX; EPX:=0
                         for EHX:=DIMX0 to DIMY0
                            ++EPX; EQX:=0
                            for EIX:=DIMX1 to DIMY1
                               TEMPORAL[EPX][++EQX][ERX][ESX]:=FUENTE[EHX][EIX][EJX][EKX]
                            end
                         end
                      end
                   end
                   DIM:=4
                end
             end
          end
       else
          RETURN _FUNPUTERROR("[% M],COPY BLOCK 4D/STACK PARAMS OVERFLOW",OP_CODE,CP)
       end
    end
    //////stk_var_02[CWM]:=ARRAY(ROW,COL,PAG,BLK)
    stk_var_02[CWM]:=TEMPORAL ////XMMLET(TEMPORAL,DIM,ROW,COL,PAG,BLK,0)
    FUNPUTDIMS(CWM,DIM,TYP,ROW,COL,PAG,BLK)
    RELEASE TEMPORAL
    STACK[CS]:=CWM 
  RETURN .T.

  FUNCTION FUNPARSATT()   // 212
  LOCAL EAX,EBX,ECX,AX,BX,CX,FX,EVX,EWX,EXX,EEX,DX,EDX
  LOCAL OP_CODE:=2120
  LOCAL EHX,EIX,EJX,EKX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
  LOCAL DIM3,DIM3R,DIM3C,DIM3P,DIM3B,TYP3
    ECX:=STACK[CS]
    EAX:=STACK[CS-1]
    EBX:=STACK[CS-2]
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS -=2; ++CWM
    CX:=stk_var_02[ECX]          // stack   
    AX:=stk_var_02[EAX]          // Mensaje
    BX:=stk_var_02[EBX]          // Campo
    EVX:=VALTYPE(CX)
    EWX:=VALTYPE(AX)
    EXX:=VALTYPE(BX)
    IF !FUNGETDIMS(ECX,@EDX,@DIM3,@TYP3,@DIM3R,@DIM3C,@DIM3P,@DIM3B,.T.)
       RETURN _FUNPUTERROR("PARSATT/MATRIX-STACK OF ATTRIBS NOT INITIALIZED",OP_CODE,CP)
    END
    IF EVX+EWX+EXX=="ACC"
       if DIM3==1
          stk_var_02[CWM]:=FUNDOPARSATT(AX,BX,@CX,@FX)
          stk_var_02[EAX]:=STRTRAN(stk_var_02[EAX],FX,"",,1)
       else
          RETURN _FUNPUTERROR("PARSATT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
       end
    ELSE
       EEX:=EWX+EXX
       //IF !FUNGETDIMS(ECX,@EDX,@DIM3,@TYP3,@DIM3R,@DIM3C,@DIM3P,@DIM3B,.T.)
       //   RETURN _FUNPUTERROR("PARSATT/MATRIX NOT INITIALIZED",OP_CODE,CP)
       //END
       IF EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.) .OR. DIM1>1
             RETURN _FUNPUTERROR("PARSATT/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
          END
       END
       IF EXX=="A"          
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.) .OR. DIM2>1
             RETURN _FUNPUTERROR("PARSATT/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
          IF DIM1R!=DIM2R
             RETURN _FUNPUTERROR("PARSATT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       ELSEIF DIM1R!=DIM3R 
          RETURN _FUNPUTERROR("PARSATT/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
       END
       IF EEX=="AA"
           TEMPORAL:=ARRAY(DIM1R)
           FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX] := FUNDOPARSATT(AX[EHX],BX[EHX],@CX[EHX],@FX)
              stk_var_02[EAX][EHX]:=STRTRAN(stk_var_02[EAX][EHX],FX,"",,1)
           END
           ///////stk_var_02[CWM]:=ARRAY(DIM1R)
           stk_var_02[CWM]:=TEMPORAL ////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
           FUNPUTDIMS(CWM,DIM1,"C",DIM1R,0,0,0) 
           RELEASE TEMPORAL
       ELSEIF EEX=="AC"
          TEMPORAL:=ARRAY(DIM1R)
           FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX] := FUNDOPARSATT(AX[EHX],BX,@CX[EHX],@FX)
              stk_var_02[EAX][EHX]:=STRTRAN(stk_var_02[EAX][EHX],FX,"",,1)
           END
           /////stk_var_02[CWM]:=ARRAY(DIM1R)
           stk_var_02[CWM]:=TEMPORAL ////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
           FUNPUTDIMS(CWM,DIM1,"C",DIM1R,0,0,0)
           RELEASE TEMPORAL
       ELSE  // DEBE SER EEX="CA"
          TEMPORAL:=ARRAY(DIM2R) 
          FOR EHX:=1 TO DIM2R
             TEMPORAL[EHX] := FUNDOPARSATT(AX,BX[EHX],@CX[EHX],@FX)
             stk_var_02[EAX][EHX]:=STRTRAN(stk_var_02[EAX][EHX],FX,"",,1)
          END
           //////stk_var_02[CWM]:=ARRAY(DIM2R)
           stk_var_02[CWM]:=TEMPORAL ////XMMLET(TEMPORAL,DIM2,DIM2R,0,0,0,0)
          FUNPUTDIMS(CWM,DIM2,"C",DIM2R,0,0,0)
          RELEASE TEMPORAL
       END
    END
    STACK[CS]:=CWM
  RETURN .T.
    
  FUNCTION FUNDOPARSATT(AX,BX,CX,FX)
  LOCAL EX,HX,IX,JX,TX,VX,XVALOR,DX
  LOCAL XINI,XFIN,XXlen,XLEN,OP_CODE:=2120
  //  AX:=stk_var_02[EAX]
    
    EX:="<"+BX+" "     // obtengo el campo sin atributos
    // debo saber si se trata de una etqueta vacía, un tag con atributos o uno norma
    FX:=""
    if len(CX)==0           
       _FUNPUTERROR("PARSATT/MISSING ATTRIBUTE",OP_CODE,CP)
       return ""
    end
    HX:=AT(EX,AX)            // donde empieza el campo
    if HX==0
       _FUNPUTERROR("PARSATT/MISSING FIELD",OP_CODE,CP)
       return ""
    end
    // rescato todo el registro
    XINI:=HX+len(EX)
    DX:=substr(AX,XINI,len(AX))  // obtengo desde el campo en adelante
    XFIN:=at("</"+BX+">",DX)
    JX:=alltrim(substr(DX,1,XFIN-1))  // obtengo todo incluyendo el valor 
 //// setcolor("15/14"); ? JX; inkey(0); setcolor("")
    if JX==""
       XXLen:=at("/>",DX)
       JX:=substr(DX,1,XXLen-1)  // obtengo los atributos
       XVALOR:=""                      // valor vacio!!!
       // ahora obtengo el registro completo           
       FX:=alltrim(substr(DX,1,XXLen+2))
    //   stk_var_02[EAX]:=STRTRAN(stk_var_02[EAX],FX,"",,1)
    else
       XINT:=at(">",JX)
       XXLen:=XFIN
       XVALOR:=alltrim(substr(JX,XINT+1,XFIN-(XINT+1)))  // valor!!
  ////     setcolor("15/3"); ? XVALOR; inkey(0); setcolor("")
       JX:=substr(JX,1,XINT-1)           // obtengo los atributos
  ////     setcolor("15/13"); ? JX; inkey(0); setcolor("")
       // ahora obtengo el registro completo           
       //FX:=alltrim(substr(DX,1,XXLen+len("</"+BX+">")-1))
       FX:=alltrim(substr(AX,1,at("</"+BX+">",AX)+len("</"+BX+">"))) //   XXLen+len("</"+BX+">")-1))
     //  stk_var_02[EAX]:=STRTRAN(stk_var_02[EAX],FX,"",,1)
  ////        setcolor("15/12"); ? FX; inkey(0); setcolor("")
    end       
    // obtengo los atributos desde el array pasado por parámetro
    // CX es el stack
    XLEN:=len(CX)
    for IX:=XLEN to 1 step -1   // parto desde el último atributo y voy eliminando!!
       VX:=CHARREM(" ",CX[IX])
       CX[IX]:=VX
       XINI:=at(VX,JX)   //+len(CX[IX])
       if XINI>0
          TX:=substr(JX,XINI,len(JX))   // respaldo porcion de linea
          VX:=substr(TX,len(CX[IX])+1,len(TX))
          if "'" $ VX
             VX:=strtran(VX,"'","")  //"X$TTR@")
          end 
          if '"' $ VX
             VX:=strtran(VX,'"',"")  //"X$TTR@")
          end 
          CX[IX]:=alltrim(VX)  //alltrim(strtran(VX,"'",""))
//          if "X$TTR@" $ CX[IX]
//             CX[IX]:=strtran(CX[IX],"X$TTR@","'")
//          end 
          JX:=strtran(JX,TX,"")
       else
          CX[IX]:=""  
       end  
    next
  RETURN XVALOR


/******************************************************************
            FAM. FUNCIONES DE ASIGNACION TSFSTK_CODE
*******************************************************************/
  FUNCTION FUNLETSTKSTK()   // 55
  LOCAL AX,BX,EAX,EBX,DIM,ROW,COL,PAG,BLK,TYP,ETX
  LOCAL OP_CODE:=550
    AX:=STACK[CS]
    BX:=STACK[CS-1]
    CWM:=CMPCWM(AX,CWM,TopCWM)
    CWM:=CMPCWM(BX,CWM,TopCWM)
    CS -= 2        // ajusta puntero de Stack
    // actualizar datos del stack destino:
    EAX := ASCAN(STK_ARRAY_DIR,BX)  // 
    if EAX==0
       RETURN _FUNPUTERROR("ASSIGN MATRIX/MATRIX NOT DECLARED",OP_CODE,CP)
    else
       // busco info de stack de origen! por prob. puede ser temporal
       if STK_CWMTOP>0
          EBX := STK_TEMP_DIR[STK_CWMTOP]
       else
          EBX := 0
       end
       
       if EBX==0   // es un stack legal
          EBX := ASCAN(STK_ARRAY_DIR,AX)  // busco info de stack de origen!
          IF STK_ARRAY_TYP[EBX]!=STK_ARRAY_TYP[EAX]
             RETURN _FUNPUTERROR("ASSIGN MATRIX/TYPE MISMATCH (STATIC ARRAY? SHOULD BE CASTED)",OP_CODE,CP)
          END
          STK_ARRAY_DIM[EAX]:=DIM:=STK_ARRAY_DIM[EBX]
          STK_ARRAY_ROW[EAX]:=ROW:=STK_ARRAY_ROW[EBX]   // dimension fila
          STK_ARRAY_COL[EAX]:=COL:=STK_ARRAY_COL[EBX]   // dimension columna
          STK_ARRAY_PAG[EAX]:=PAG:=STK_ARRAY_PAG[EBX]   // dimension pagina
          STK_ARRAY_BLK[EAX]:=BLK:=STK_ARRAY_BLK[EBX]   // dimension bloque
          STK_ARRAY_TYP[EAX]:=TYP:=STK_ARRAY_TYP[EBX]   // tipo del stack
          
       else   // es un stack temporal
          IF STK_TEMP_TYP[STK_CWMTOP]!=STK_ARRAY_TYP[EAX]
             RETURN _FUNPUTERROR("ASSIGN MATRIX/TYPE MISMATCH (STATIC ARRAY? SHOULD BE CASTED)",OP_CODE,CP)
          END
          STK_ARRAY_DIM[EAX]:=DIM:=STK_TEMP_DIM[STK_CWMTOP]
          STK_ARRAY_ROW[EAX]:=ROW:=STK_TEMP_ROW[STK_CWMTOP]   // dimension fila
          STK_ARRAY_COL[EAX]:=COL:=STK_TEMP_COL[STK_CWMTOP]   // dimension columna
          STK_ARRAY_PAG[EAX]:=PAG:=STK_TEMP_PAG[STK_CWMTOP]   // dimension pagina
          STK_ARRAY_BLK[EAX]:=BLK:=STK_TEMP_BLK[STK_CWMTOP]   // dimension bloque
          STK_ARRAY_TYP[EAX]:=TYP:=STK_TEMP_TYP[STK_CWMTOP]   // tipo del stack
          STK_TEMP_DIR[STK_CWMTOP]:=0
          STK_CWMTOP--
          
       end   
      // ASIGNACION MANUAL
      /* SWITCH DIM
       CASE 1
          stk_var_02[BX]:=ARRAY(ROW)
          EXIT
       CASE 2
          stk_var_02[BX]:=ARRAY(ROW,COL)
          EXIT
       CASE 3
          stk_var_02[BX]:=ARRAY(ROW,COL,PAG)
          EXIT
       OTHERWISE
          stk_var_02[BX]:=ARRAY(ROW,COL,PAG,BLK)
       END */
       ////stk_var_02[BX]:=stk_var_02[AX]   ///
       stk_var_02[BX]:=XMMLET(stk_var_02[AX],DIM,ROW,COL,PAG,BLK,0)
    end
  RETURN .T.
  
  FUNCTION FUNLETESPSTK()   //112  rellena con el valor que se le indique
  LOCAL EAX,EBX,EDX,OP_CODE:=1120,ETX,ERX
  LOCAL DIM,DIMR,DIMC,DIMP,DIMB
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS -= 2        // ajusta puntero de Stack
    EDX := ASCAN(STK_ARRAY_DIR,EBX)
    DIM := STK_ARRAY_DIM[EDX]
    SWITCH DIM
    CASE 0
       RETURN _FUNPUTERROR("MOV(STACK)/MATRIX NOT INITIALIZED",OP_CODE,CP)
    CASE 1
       DIMR := STK_ARRAY_ROW[EDX]
       if DIMR>0
          stk_var_02[EBX]:=XEMLET(stk_var_02[EAX],1,DIMR,0,0,0)
       else
          RETURN _FUNPUTERROR("MOV(STACK)/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       EXIT
    CASE 2
       DIMR := STK_ARRAY_ROW[EDX]
       DIMC := STK_ARRAY_COL[EDX]
       if DIMR>0 .AND. DIMC>0
          stk_var_02[EBX]:=XEMLET(stk_var_02[EAX],2,DIMR,DIMC,0,0)
       else
          RETURN _FUNPUTERROR("MOV(STACK)/MATRIX NOT INITIALIZED",OP_CODE+1,CP)
       end
       EXIT
    CASE 3
       DIMR := STK_ARRAY_ROW[EDX]
       DIMC := STK_ARRAY_COL[EDX]
       DIMP := STK_ARRAY_PAG[EDX]
       if DIMR>0 .AND. DIMC>0 .AND. DIMP>0
          stk_var_02[EBX]:=XEMLET(stk_var_02[EAX],3,DIMR,DIMC,DIMP,0)
       else
          RETURN _FUNPUTERROR("MOV(STACK)/MATRIX NOT INITIALIZED",OP_CODE+2,CP)
       end
       EXIT
    OTHERWISE
       DIMR := STK_ARRAY_ROW[EDX]
       DIMC := STK_ARRAY_COL[EDX]
       DIMP := STK_ARRAY_PAG[EDX]
       DIMB := STK_ARRAY_BLK[EDX]
       if DIMR>0 .AND. DIMC>0 .AND. DIMP>0 .AND. DIMB>0
          stk_var_02[EBX]:=XEMLET(stk_var_02[EAX],4,DIMR,DIMC,DIMP,DIMB) 
       else
          RETURN _FUNPUTERROR("MOV(STACK)/MATRIX NOT INITIALIZED",OP_CODE+3,CP)
       end
    end
  RETURN .T.
  
  FUNCTION FUNLETSTRSTK()  // 16  asigna cada token de un string a un stack
  LOCAL EAX,EBX,EDX,ELX,ETX,EHX,EIX,EJX,EKX,EPX,EQX,EZX,ENX
  LOCAL DIM,TYP,ROW,COL,PAG,BLK,ATX
  LOCAL STRING,OP_CODE:=160
    EAX:=STACK[CS]           // ya debe estar dimensionado, por lo que hay que cambiar!!
    EBX:=STACK[CS-1]
    STRING:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS -= 2        // ajusta puntero de Stack
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       FVWITH:=" "   // por defecto
       FTWITH:="C" 
    end
    EDX := ASCAN(STK_ARRAY_DIR,EBX)
    DIM := STK_ARRAY_DIM[EDX]
    TYP := STK_ARRAY_TYP[EDX]
    ROW := STK_ARRAY_ROW[EDX]
    COL := STK_ARRAY_COL[EDX]
    PAG := STK_ARRAY_PAG[EDX]
    BLK := STK_ARRAY_BLK[EDX]
    if TYP!="C"
       RETURN _FUNPUTERROR("MOV(STRING->STACK)/STRING MATRIX EXPECTED",OP_CODE,CP)
    end
    ELX:=NUMTOKEN(STRING,FVWITH)
    if ELX<=1  // es un solo token. se asigna a todo el array si está inicializado; sino, se crea un array
       if alltrim(STRING)==""
        ////  ? "ETX ES CADENA NULA"
          ETX:=""
       else
          ETX:=TOKEN(STRING,FVWITH, 1)
       end
       if ROW>0  // ESTÁ INICIALIZADA
          stk_var_02[EBX]:=XEMLET(ETX,DIM,ROW,COL,PAG,BLK)

       else     // se crea
          stk_var_02[EBX]:={ETX}
          ROW:=1
       end
    else   // SON MUCHOS TOKENS
       // para usar PFLAG, debo crear un array con los tokens.

       ENX:=NUMTOKEN(STRING,FVWITH)
       ATX:=ARRAY(ENX)
       IF PFLAG==1  // QUEUE
          for EHX:=1 to ENX   // relleno el array de tokens
             ATX[EHX]:=TOKEN(STRING,FVWITH, EHX)
          next
       ELSE         // DEQUE
          for EHX:=1 to ENX   // relleno el array de tokens
             ATX[EHX]:=TOKEN(STRING,FVWITH, (ENX-EHX)+1)
          next
       END

      // NO IMPORTA QUE ESTÉ INICIALIZADO: SE CREA IGUAL
       ////stk_var_02[EBX]:=ARRAY(ENX) 
       stk_var_02[EBX]:= ATX ///XMMLET(ATX,1,ENX,0,0,0,0)
       DIM:=1
       ROW:=ENX
       COL:=0; PAG:=0; BLK:=0
       
    end   
    STK_ARRAY_DIM[EDX]:=DIM
    STK_ARRAY_ROW[EDX]:=ROW   // dimension fila
    STK_ARRAY_COL[EDX]:=COL   // dimension columna
    STK_ARRAY_PAG[EDX]:=PAG    // dimension pagina
    STK_ARRAY_BLK[EDX]:=BLK // dimension bloque
    STK_ARRAY_TYP[EDX]:="C"   // tipo del stack
  RETURN .T.

  FUNCTION TOKENSTRMAT()   //137    DIVISION STRING/TOKEN
  LOCAL EAX,EBX,ELX,EHX,TEMPORAL
  LOCAL STRING,OP_CODE:=137
    EAX:=STACK[CS]           // token
    EBX:=STACK[CS-1]         // string a tokear
    STRING:=stk_var_02[EBX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS; ++CWM        // ajusta puntero de Stack
    IF LEN(stk_var_02[EAX])>0
       ELX:=NUMTOKEN(STRING,stk_var_02[EAX])
       TEMPORAL:=ARRAY(ELX) // array de tokens
       FOR EHX:=1 TO ELX
          TEMPORAL[EHX]:=TOKEN(STRING,stk_var_02[EAX],EHX)
       END
    ELSE   // NO HAY TOKEN: DIVIDE CADA CARACTER
       ELX:=LEN(STRING)
       TEMPORAL:=ARRAY(ELX)
       FOR EHX:=1 TO ELX
          TEMPORAL[EHX]:=SUBSTR(STRING,EHX,1)
       END
    END
    //////stk_var_02[CWM]:=ARRAY(ELX)
    stk_var_02[CWM]:=TEMPORAL  //XMMLET(TEMPORAL,1,ELX,0,0,0,0)
    FUNPUTDIMS(CWM,1,"C",ELX,0,0,0)
    RELEASE TEMPORAL
    STACK[CS]:=CWM
  RETURN .T.

 /********
    ORDENA UNA MATRIZ O VECTOR. MATRIZ DEBE SER 2D.
       V<-SORT((FLAG "A|D") MATRIZ "NCOLUM:TIPO" DESDE HASTA)
       v<-sort((flag "A") Mat 12 "N" 0 0)
    LAS COLUMNAS DEBEN SER STRING. EL FLAG INDICA SI ORDENA ASCENDENTE O
    DESCENDENTEMENTE.
    DESDE=0 Y HASTA=0, ORDENA TODO
    SUBTIPOS: "N"=NUMEROS, ""=ES DEL TIPO DEL ARRAY, "L"=LOGICO, "D"=FECHAS.
    SI QUIERO ORDENAR UNA MATRIZ 3D O 4D, PRIMERO DEBO RESHAPEARLA A 2D LEYENDO
    POR FILAS Y ESCRIBIENDO POR FILAS.
    SI SUBTIPO ES "L", DEBE SER "0" Y "1".
    *********/    
  FUNCTION FUNSORT()  // 200
  LOCAL EBX,BX,EAX,AX,ECX,CX,EDX,DX,EFX,HX,EHX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,FUENTE
  LOCAL OP_CODE:=2000 
    EDX:=STACK[CS]
    DX:=stk_var_02[EDX]   // HASTA
    ECX:=STACK[CS-1]
    CX:=stk_var_02[ECX]   // DESDE
    EHX:=STACK[CS-2]
    HX:=stk_var_02[EHX]   // SUBTIPO DE COLUMNA
    EBX:=STACK[CS-3]
    BX:=stk_var_02[EBX]   // columnas por la cuales ordenar. es string
    EAX:=STACK[CS-4]     // ARRAY
    FUENTE:=stk_var_02[EAX]
    CWM:=CMPCWM(EDX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    CWM:=CMPCWM(EHX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)

    CS-=5 //; CWM++
    
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C"
       FVWITH:="A"   // por defecto: ASCENDENTE
       FTWITH:="C" 
    end
    
    // llevar todo a un array, ordenarlo, y extraer el min y el max!
    IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
       IF DIM1==1
          IF FVWITH=="A"  // ORDENACION ASCENDENTE
             SWITCH HX
             CASE ""
                ASORT(FUENTE,CX,DX, { |x, y| x < y })
                EXIT
             CASE "L"
                ASORT(FUENTE,CX,DX, { |x, y| x < y })
                EXIT
             CASE "N"
                IF TYP1!="N"
                   ASORT(FUENTE,CX,DX, { |x, y| VAL(x) < VAL(y) })
                ELSE
                   ASORT(FUENTE,CX,DX, { |x, y| x < y })
                END
                EXIT
             CASE "D"
                IF TYP1=="C"
                   ASORT(FUENTE,CX,DX, { |x, y| CTOD(x) < CTOD(y) })
                ELSE
                   RETURN _FUNPUTERROR("SORT/I NEED STRING TYPE HERE, MERME",OP_CODE,CP)
                END
                EXIT
             OTHERWISE
                RETURN _FUNPUTERROR("SORT/SUBTYPE 'N','L','' OR 'D' REQUERIED, AWEONEITOR",OP_CODE,CP)
             END
          ELSE     // ORDENACION DESCENDENTE
             SWITCH HX
             CASE ""
                ASORT(FUENTE,CX,DX, { |x, y| x > y })
                EXIT
             CASE "L"
                ASORT(FUENTE,CX,DX, { |x, y| x > y })
                EXIT
             CASE "N"
                IF TYP1!="N"
                   ASORT(FUENTE,CX,DX, { |x, y| VAL(x) > VAL(y) })
                ELSE
                   ASORT(FUENTE,CX,DX, { |x, y| x > y })
                END
                EXIT
             CASE "D"
                IF TYP1=="C"
                   ASORT(FUENTE,CX,DX, { |x, y| CTOD(x) > CTOD(y) })
                ELSE
                   RETURN _FUNPUTERROR("SORT/I NEED STRING TYPE HERE, MERME",OP_CODE,CP)
                END
                EXIT
             OTHERWISE
                RETURN _FUNPUTERROR("SORT/SUBTYPE 'N','L','' OR 'D' REQUERIED, AWEONEITOR",OP_CODE,CP)
             END
          END
       ELSEIF DIM1==2
          IF BX>0 .AND. BX<=DIM1C
          IF FVWITH=="A"  // ORDENACION ASCENDENTE
             SWITCH HX
             CASE ""
                ASORT(FUENTE,CX,DX, { |x, y| x[BX] < y[BX] })
                EXIT
             CASE "L"
                ASORT(FUENTE,CX,DX, { |x, y| x[BX] < y[BX] })
                EXIT
             CASE "N"
                IF TYP1!="N"
                   ASORT(FUENTE,CX,DX, { |x, y| VAL(x[BX]) < VAL(y[BX]) })
                ELSE
                   ASORT(FUENTE,CX,DX, { |x, y| x[BX] < y[BX] })
                END
                EXIT
             CASE "D"
                IF TYP1=="C"
                   ASORT(FUENTE,CX,DX, { |x, y| CTOD(x[BX]) < CTOD(y[BX]) })
                ELSE
                   RETURN _FUNPUTERROR("SORT/I NEED STRING TYPE HERE, MERME",OP_CODE,CP)
                END
                EXIT
             OTHERWISE
                RETURN _FUNPUTERROR("SORT/SUBTYPE 'N','L','' OR 'D' REQUERIED, AWEONEITOR",OP_CODE,CP)
             END
          ELSE     // ORDENACION DESCENDENTE
             SWITCH HX
             CASE ""
                ASORT(FUENTE,CX,DX, { |x, y| x[BX] > y[BX] })
                EXIT
             CASE "L"
                ASORT(FUENTE,CX,DX, { |x, y| x[BX] > y[BX] })
                EXIT
             CASE "N"
                IF TYP1!="N"
                   ASORT(FUENTE,CX,DX, { |x, y| VAL(x[BX]) > VAL(y[BX]) })
                ELSE
                   ASORT(FUENTE,CX,DX, { |x, y| x[BX] > y[BX] })
                END
                EXIT
             CASE "D"
                IF TYP1=="C"
                   ASORT(FUENTE,CX,DX, { |x, y| CTOD(x[BX]) > CTOD(y[BX]) })
                ELSE
                   RETURN _FUNPUTERROR("SORT/I NEED STRING TYPE HERE, MERME",OP_CODE,CP)
                END
                EXIT
             OTHERWISE
                RETURN _FUNPUTERROR("SORT/SUBTYPE 'N','L','' OR 'D' REQUERIED, AWEONEITOR",OP_CODE,CP)
             END
          END
          ELSE
             RETURN _FUNPUTERROR("SORT/COLUMN OVERFLOW OR UNDERFLOW (¿"+;
               ALLTRIM(STR(BX))+"? MAX. "+ALLTRIM(STR(DIM1C))+")",OP_CODE,CP)
          END
       ELSE
          RETURN _FUNPUTERROR("SORT/MATRIX 1D OR 2D REQUERIED, MERMELA OF HUEA",OP_CODE,CP)
       END
    ELSE
       RETURN _FUNPUTERROR("SORT/MATRIX NOT INITIALIZED",OP_CODE,CP)
    END
  RETURN .T. 

/**************************************************************
         FAM. MATMINMAX_CODE MIN Y MAX PARA MATRICES
***************************************************************/
FUNCTION MATMINMAX_CODE()   // 101
LOCAL EAX,EBX,ECX,EDX,AX,BX,CX,DX,EX,VAX,VBX
LOCAL EIX,EJX,EKX,ELX,ETX,ESX,EWX,EMX,TEMPORAL
LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
LOCAL OP_CODE:=1011
  EBX:=STACK[CS]     // PARAM 2
  EAX:=STACK[CS-1]   // PARAM 1
  ECX:=STACK[CS-2]   // CODIGO DE FUNCION?
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  ++CWM; CS -=2
  AX:=stk_var_02[EAX]
  BX:=stk_var_02[EBX]
  CX:=stk_var_02[ECX]
  
  // VERIFICAR SI ES EL MINIMO CON FLAG:
  FVWITH := FLAG[1]   // valor
  FTWITH := UPPER(FLAG[2])   // tipo
  if FTWITH=="C"
     FVWITH := UPPER(FVWITH)
     SWITCH FVWITH
     CASE "R"   // OBTIENE EL MIN MAX DE CADA FILA
        EWX:=1
        EXIT
     CASE "C"   // OBTIENE EL MIN MAX DE CADA COLUMNA
        EWX:=2
        EXIT
     CASE "P"   // OBTIENE EL MIN MAX DE CADA PAGINA
        EWX:=3
        EXIT
     CASE "B"   // OBTIENE EL MIN MAX DE CADA BLOQUE
        EWX:=4
        EXIT
     OTHERWISE
        EWX:=0            // minimo normal
     end
  end

  VAX=VALTYPE(AX)
  VBX=VALTYPE(BX)

  IF CX==3   // ES EQUAL: CAMBIA EL FLAG A NEUTRO
     EWX:=0
  END

  IF EWX==1    // EL MINIMO O MAXIMO DE CADA FILA
     IF VAX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
        end        
     ELSE
        RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
     END
     IF CX==1 // MIN
        SWITCH DIM1
        CASE 1
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX>AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0   // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(DIM1R)
           FOR EIX:=1 TO DIM1R; EMX:=AX[EIX][1]; FOR EJX:=2 TO DIM1C
              IF EMX>AX[EIX][EJX]
                 EMX:=AX[EIX][EJX]
              END
           END; TEMPORAL[EIX]:=EMX; END
           DIM1:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(DIM1R,DIM1P)
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1R; EMX:=AX[EIX][1][EKX]; FOR EJX:=2 TO DIM1C
              IF EMX>AX[EIX][EJX][EKX]
                 EMX:=AX[EIX][EJX][EKX]
              END
           END; TEMPORAL[EIX][EKX]:=EMX; END; END
           DIM1:=2; DIM1C:=DIM1P; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1R,DIM1P,DIM1B)
           FOR ELX:=1 TO DIM1B
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1R; EMX:=AX[EIX][1][EKX][ELX]; FOR EJX:=2 TO DIM1C
              IF EMX>AX[EIX][EJX][EKX][ELX]
                 EMX:=AX[EIX][EJX][EKX][ELX]
              END
           END; TEMPORAL[EIX][EKX][ELX]:=EMX; END; END; END
           DIM1:=3; DIM1C:=DIM1P; DIM1P:=DIM1B;DIM1B:=0
           EXIT
        END
     ELSE   // DEBE SER MAXIMO
        SWITCH DIM1
        CASE 1   // DEVUELVE UN ARRAY CON UN SOLO ELEMENTO: SIRVE SI QUIERE HACER PROCESO CON PUSH
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX<AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0   // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(DIM1R)
           FOR EIX:=1 TO DIM1R; EMX:=AX[EIX][1]; FOR EJX:=2 TO DIM1C
              IF EMX<AX[EIX][EJX]
                 EMX:=AX[EIX][EJX]
              END
           END; TEMPORAL[EIX]:=EMX; END
           DIM1:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(DIM1R,DIM1P)
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1R; EMX:=AX[EIX][1][EKX]; FOR EJX:=2 TO DIM1C
              IF EMX<AX[EIX][EJX][EKX]
                 EMX:=AX[EIX][EJX][EKX]
              END
           END; TEMPORAL[EIX][EKX]:=EMX; END; END
           DIM1:=2; DIM1C:=DIM1P; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1R,DIM1P,DIM1B)
           FOR ELX:=1 TO DIM1B
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1R; EMX:=AX[EIX][1][EKX][ELX]; FOR EJX:=2 TO DIM1C
              IF EMX<AX[EIX][EJX][EKX][ELX]
                 EMX:=AX[EIX][EJX][EKX][ELX]
              END
           END; TEMPORAL[EIX][EKX][ELX]:=EMX; END; END; END
           DIM1:=3; DIM1C:=DIM1P; DIM1P:=DIM1B;DIM1B:=0
           EXIT
        END
     
     END
  ELSEIF EWX==2   // MINIMO MAXIMO DE CADA COLUMNA
     IF VAX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
        end        
     ELSE
        RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
     END
     IF CX==1   // MIN
        SWITCH DIM1
        CASE 1   // DEVUELVE UN ARRAY CON UN SOLO ELEMENTO: SIRVE SI QUIERE HACER PROCESO CON PUSH
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX>AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0    // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(DIM1C)
           FOR EIX:=1 TO DIM1C; EMX:=AX[1][EIX]; FOR EJX:=2 TO DIM1R
              IF EMX>AX[EJX][EIX]
                 EMX:=AX[EJX][EIX]
              END
           END; TEMPORAL[EIX]:=EMX; END
           DIM1:=1; DIM1R:=DIM1C; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(DIM1C,DIM1P)
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; EMX:=AX[1][EIX][EKX]; FOR EJX:=2 TO DIM1R
              IF EMX>AX[EJX][EIX][EKX]
                 EMX:=AX[EJX][EIX][EKX]
              END
           END; TEMPORAL[EIX][EKX]:=EMX; END; END
           DIM1:=2; DIM1R:=DIM1C; DIM1C:=DIM1P; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1C,DIM1P,DIM1B)
           FOR ELX:=1 TO DIM1B
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; EMX:=AX[1][EIX][EKX][ELX]; FOR EJX:=2 TO DIM1R
              IF EMX>AX[EJX][EIX][EKX][ELX]
                 EMX:=AX[EJX][EIX][EKX][ELX]
              END
           END; TEMPORAL[EIX][EKX][ELX]:=EMX; END; END; END
           DIM1:=3; DIM1R:=DIM1C; DIM1C:=DIM1P; DIM1P:=DIM1B; DIM1B:=0
        END
     ELSE   // MAXIMO
        SWITCH DIM1
        CASE 1   // DEVUELVE UN ARRAY CON UN SOLO ELEMENTO: SIRVE SI QUIERE HACER PROCESO CON PUSH
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX<AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0    // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(DIM1C)
           FOR EIX:=1 TO DIM1C; EMX:=AX[1][EIX]; FOR EJX:=2 TO DIM1R
              IF EMX<AX[EJX][EIX]
                 EMX:=AX[EJX][EIX]
              END
           END; TEMPORAL[EIX]:=EMX; END
           DIM1:=1; DIM1R:=DIM1C; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(DIM1C,DIM1P)
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; EMX:=AX[1][EIX][EKX]; FOR EJX:=2 TO DIM1R
              IF EMX<AX[EJX][EIX][EKX]
                 EMX:=AX[EJX][EIX][EKX]
              END
           END; TEMPORAL[EIX][EKX]:=EMX; END; END
           DIM1:=2; DIM1R:=DIM1C; DIM1C:=DIM1P; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1C,DIM1P,DIM1B)
           FOR ELX:=1 TO DIM1B
           FOR EKX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; EMX:=AX[1][EIX][EKX][ELX]; FOR EJX:=2 TO DIM1R
              IF EMX<AX[EJX][EIX][EKX][ELX]
                 EMX:=AX[EJX][EIX][EKX][ELX]
              END
           END; TEMPORAL[EIX][EKX][ELX]:=EMX; END; END; END
           DIM1:=3; DIM1R:=DIM1C; DIM1C:=DIM1P; DIM1P:=DIM1B; DIM1B:=0
        END
     END
  ELSEIF EWX==3   // MINIMO MAXIMO DE CADA PAGINA
     IF VAX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
        end        
     ELSE
        RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
     END
     IF CX==1    // MINI
        SWITCH DIM1
        CASE 1   // DEVUELVE UN ARRAY CON UN SOLO ELEMENTO: SIRVE SI QUIERE HACER PROCESO CON PUSH
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX>AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0    // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1][1]
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX>AX[EIX][EJX]
                 EMX:=AX[EIX][EJX]
              END
           END; END
           TEMPORAL[1]:=EMX 
           DIM1:=1; DIM1R:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(DIM1P)
           FOR EKX:=1 TO DIM1P; EMX:=AX[1][1][EKX]; FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX>AX[EIX][EJX][EKX]
                 EMX:=AX[EIX][EJX][EKX]
              END
           END; END; TEMPORAL[EKX]:=EMX; END
           DIM1:=1; DIM1R:=DIM1P; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1P,DIM1B)
           FOR ELX:=1 TO DIM1B
           FOR EKX:=1 TO DIM1P; EMX:=AX[1][1][EKX][ELX]; FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX>AX[EIX][EJX][EKX][ELX]
                 EMX:=AX[EIX][EJX][EKX][ELX]
              END
           END; END; TEMPORAL[EKX][ELX]:=EMX; END; END
           DIM1:=2; DIM1R:=DIM1P; DIM1C:=DIM1B; DIM1P:=0; DIM1B:=0
           EXIT
        END
     ELSE        // MAXI
        SWITCH DIM1
        CASE 1   // DEVUELVE UN ARRAY CON UN SOLO ELEMENTO: SIRVE SI QUIERE HACER PROCESO CON PUSH
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX<AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0    // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1][1]
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX<AX[EIX][EJX]
                 EMX:=AX[EIX][EJX]
              END
           END; END
           TEMPORAL[1]:=EMX 
           DIM1:=1; DIM1R:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(DIM1P)
           FOR EKX:=1 TO DIM1P; EMX:=AX[1][1][EKX]; FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX<AX[EIX][EJX][EKX]
                 EMX:=AX[EIX][EJX][EKX]
              END
           END; END; TEMPORAL[EKX]:=EMX; END
           DIM1:=1; DIM1R:=DIM1P; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1P,DIM1B)
           FOR ELX:=1 TO DIM1B
           FOR EKX:=1 TO DIM1P; EMX:=AX[1][1][EKX][ELX]; FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX<AX[EIX][EJX][EKX][ELX]
                 EMX:=AX[EIX][EJX][EKX][ELX]
              END
           END; END; TEMPORAL[EKX][ELX]:=EMX; END; END
           DIM1:=2; DIM1R:=DIM1P; DIM1C:=DIM1B; DIM1P:=0; DIM1B:=0
           EXIT
        END
     END
  ELSEIF EWX==4   // MINIMO MAXIMO DE CADA BLOQUE
     IF VAX=="A"
        IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
           RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
        end        
     ELSE
        RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
     END

     IF CX==1    // MIN
        SWITCH DIM1
        CASE 1
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX>AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0    // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1][1]
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX>AX[EIX][EJX]
                 EMX:=AX[EIX][EJX]
              END
           END; END
           TEMPORAL[1]:=EMX 
           DIM1:=1; DIM1R:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1][1][1]
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C; FOR EKX:=1 TO DIM1P
              IF EMX>AX[EIX][EJX][EKX]
                 EMX:=AX[EIX][EJX][EKX]
              END
           END; END; END
           TEMPORAL[1]:=EMX
           DIM1:=1; DIM1R:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1B)
           FOR ELX:=1 TO DIM1B
           EMX:=AX[1][1][1][ELX] 
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C; FOR EKX:=1 TO DIM1P
              IF EMX>AX[EIX][EJX][EKX][ELX]
                 EMX:=AX[EIX][EJX][EKX][ELX]
              END
           END; END; END; TEMPORAL[ELX]:=EMX; END
           DIM1:=1; DIM1R:=DIM1B; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT        
        END
     ELSE        // MAX
        SWITCH DIM1       
        CASE 1
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1]
           FOR EIX:=2 TO DIM1R
              IF EMX<AX[EIX]
                 EMX:=AX[EIX]
              END
           END
           TEMPORAL[1]:=EMX
           DIM1=1;DIM1R:=1; DIM1C:=0; DIM1P:=0; DIM1B:=0
           EXIT
        CASE 2
           EMX:=0    // PARA USO TEMPORAL
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1][1]
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C
              IF EMX<AX[EIX][EJX]
                 EMX:=AX[EIX][EJX]
              END
           END; END
           TEMPORAL[1]:=EMX 
           DIM1:=1; DIM1R:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        CASE 3
           EMX:=0
           TEMPORAL:=ARRAY(1)
           EMX:=AX[1][1][1]
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C; FOR EKX:=1 TO DIM1P
              IF EMX<AX[EIX][EJX][EKX]
                 EMX:=AX[EIX][EJX][EKX]
              END
           END; END; END
           TEMPORAL[EKX]:=EMX
           DIM1:=1; DIM1R:=1; DIM1C:=0; DIM1P:=0;DIM1B:=0
           EXIT
        OTHERWISE
           EMX:=0
           TEMPORAL:=ARRAY(DIM1B)
           FOR ELX:=1 TO DIM1B
           EMX:=AX[1][1][1][ELX] 
           FOR EIX:=1 TO DIM1R; FOR EJX:=1 TO DIM1C; FOR EKX:=1 TO DIM1P
              IF EMX<AX[EIX][EJX][EKX][ELX]
                 EMX:=AX[EIX][EJX][EKX][ELX]
              END
           END; END; END; TEMPORAL[ELX]:=EMX; END
           DIM1:=1; DIM1R:=DIM1B; DIM1C:=0; DIM1P:=0; DIM1B:=0 
        END
     END
  ELSE     // FLAG NEUTRO
     if CX==1  // MIN
        IF VAX=="A".AND.VBX=="A"
           IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
           end
           IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 2 NOT INITIALIZED",OP_CODE,CP)
           end
           IF DIM1==DIM2
              SWITCH DIM1
              CASE 1 
                 IF DIM1R==DIM2R
                    TEMPORAL:=ARRAY(DIM1R)
                    FOR EIX:=1 TO DIM1R
                       TEMPORAL[EIX]:=IIF(AX[EIX]<BX[EIX],AX[EIX],BX[EIX])
                    END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 2
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C
                    TEMPORAL:=ARRAY(DIM1R,DIM1C)
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C 
                       TEMPORAL[EIX][EJX]:=IIF(AX[EIX][EJX]<BX[EIX][EJX],AX[EIX][EJX],BX[EIX][EJX])
                    END; END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 3
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P
                    TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P)
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P 
                       TEMPORAL[EIX][EJX][EKX]:=IIF(AX[EIX][EJX][EKX]<BX[EIX][EJX][EKX],AX[EIX][EJX][EKX],BX[EIX][EJX][EKX])
                    END; END; END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 4
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P .AND. DIM1B==DIM2B
                    TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P; FOR ELX:=1 TO DIM1B 
                       TEMPORAL[EIX][EJX][EKX][ELX]:=IIF(AX[EIX][EJX][EKX][ELX]<BX[EIX][EJX][EKX][ELX],AX[EIX][EJX][EKX][ELX],BX[EIX][EJX][EKX][ELX])
                    END; END; END; END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              END 
           ELSE
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
           END
        ELSE
           IF VAX=="A" .AND. VBX=="N"
              IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
                 RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
              END
              AX:=stk_var_02[EBX]
              BX:=stk_var_02[EAX]
           ELSE
              IF !FUNGETDIMS(EBX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
                 RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
              END
           END
           SWITCH DIM1
           CASE 1 
              TEMPORAL:=ARRAY(DIM1R)
              FOR EIX:=1 TO DIM1R
                 TEMPORAL[EIX]:=IIF(AX<BX[EIX],AX,BX[EIX])
              END
              EXIT
           CASE 2
              TEMPORAL:=ARRAY(DIM1R,DIM1C)
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C 
                 TEMPORAL[EIX][EJX]:=IIF(AX<BX[EIX][EJX],AX,BX[EIX][EJX])
              END; END
              EXIT
           CASE 3
              TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P)
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P 
                 TEMPORAL[EIX][EJX][EKX]:=IIF(AX<BX[EIX][EJX][EKX],AX,BX[EIX][EJX][EKX])
              END; END; END
              EXIT
           OTHERWISE
              TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P; FOR ELX:=1 TO DIM1B 
                 TEMPORAL[EIX][EJX][EKX][ELX]:=IIF(AX<BX[EIX][EJX][EKX][ELX],AX,BX[EIX][EJX][EKX][ELX])
              END; END; END; END
           END
        END
     elseif CX==2      // MAX
        IF VAX=="A".AND.VBX=="A"
           IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
           end
           IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 2 NOT INITIALIZED",OP_CODE,CP)
           end
           IF DIM1==DIM2
              SWITCH DIM1
              CASE 1 
                 IF DIM1R==DIM2R
                    TEMPORAL:=ARRAY(DIM1R)
                    FOR EIX:=1 TO DIM1R
                       TEMPORAL[EIX]:=IIF(AX[EIX]>BX[EIX],AX[EIX],BX[EIX])
                    END   
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 2
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C
                    TEMPORAL:=ARRAY(DIM1R,DIM1C)
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C 
                       TEMPORAL[EIX][EJX]:=IIF(AX[EIX][EJX]>BX[EIX][EJX],AX[EIX][EJX],BX[EIX][EJX])
                    END; END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 3
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P
                    TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P)
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P 
                       TEMPORAL[EIX][EJX][EKX]:=IIF(AX[EIX][EJX][EKX]>BX[EIX][EJX][EKX],AX[EIX][EJX][EKX],BX[EIX][EJX][EKX])
                    END; END; END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              OTHERWISE
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P .AND. DIM1B==DIM2B
                    TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P; FOR ELX:=1 TO DIM1B 
                       TEMPORAL[EIX][EJX][EKX][ELX]:=IIF(AX[EIX][EJX][EKX][ELX]>BX[EIX][EJX][EKX][ELX],AX[EIX][EJX][EKX][ELX],BX[EIX][EJX][EKX][ELX])
                    END; END; END; END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
              END 
           ELSE
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
           END
        ELSE
           IF VAX=="A" .AND. VBX=="N"
              IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
                 RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
              END
              AX:=stk_var_02[EBX]
              BX:=stk_var_02[EAX]
           ELSE
              IF !FUNGETDIMS(EBX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
                 RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
              END
           END
           SWITCH DIM1
           CASE 1 
              TEMPORAL:=ARRAY(DIM1R)
              FOR EIX:=1 TO DIM1R
                 TEMPORAL[EIX]:=IIF(AX>BX[EIX],AX,BX[EIX])
              END
              EXIT
           CASE 2
              TEMPORAL:=ARRAY(DIM1R,DIM1C)
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C 
                 TEMPORAL[EIX][EJX]:=IIF(AX>BX[EIX][EJX],AX,BX[EIX][EJX])
              END; END
              EXIT
           CASE 3
              TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P)
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P 
                 TEMPORAL[EIX][EJX][EKX]:=IIF(AX>BX[EIX][EJX][EKX],AX,BX[EIX][EJX][EKX])
              END; END; END
              EXIT
           OTHERWISE
              TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P; FOR ELX:=1 TO DIM1B 
                 TEMPORAL[EIX][EJX][EKX][ELX]:=IIF(AX>BX[EIX][EJX][EKX][ELX],AX,BX[EIX][EJX][EKX][ELX])
              END; END; END; END
           END
       END  
     else              // EQUAL
        IF VAX=="A".AND.VBX=="A"
           IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 1 NOT INITIALIZED",OP_CODE,CP)
           end
           IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX 2 NOT INITIALIZED",OP_CODE,CP)
           end
           IF DIM1==DIM2
              SWITCH DIM1
              CASE 1 
                 IF DIM1R==DIM2R
                    TEMPORAL:={}
                    ESX:=0
                    FOR EIX:=1 TO DIM1R
                       IF AX[EIX]==BX[EIX]
                          AADD(TEMPORAL,EIX)
                          ++ESX
                       END
                    END
                    DIM1R:=ESX
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 2
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C
                    TEMPORAL:={}
                    ESX:=0
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C
                       IF AX[EIX][EJX]==BX[EIX][EJX]
                          AADD(TEMPORAL,{EIX,EJX})
                          ++ESX
                       END
                    END; END
                    DIM1R:=ESX
                    IF ESX==0
                       DIM1C:=0
                       DIM1:=1
                    ELSE   
                       DIM1C:=2
                    END
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              CASE 3
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P
                    TEMPORAL:={}
                    ESX:=0
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P 
                       IF AX[EIX][EJX][EKX]==BX[EIX][EJX][EKX]
                          AADD(TEMPORAL,{EIX,EJX,EKX})
                          ++ESX
                       END
                    END; END; END
                    IF ESX==0
                       DIM1:=1
                       DIM1R:=0
                       DIM1C:=0
                    ELSE   
                       DIM1:=2
                       DIM1R:=ESX
                       DIM1C:=3
                    END
                    DIM1P:=0
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
                 EXIT
              OTHERWISE
                 IF DIM1R==DIM2R .AND. DIM1C==DIM2C .AND. DIM1P==DIM2P .AND. DIM1B==DIM2B
                    TEMPORAL:={}
                    ESX:=0
                    FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P; FOR ELX:=1 TO DIM1B 
                       IF AX[EIX][EJX][EKX][ELX]==BX[EIX][EJX][EKX][ELX]
                          AADD(TEMPORAL,{EIX,EJX,EKX,ELX})
                          ++ESX
                       END
                    END; END; END; END
                    IF ESX==0
                       DIM1:=1
                       DIM1R:=0
                       DIM1C:=0
                    ELSE
                       DIM1:=2
                       DIM1R:=ESX
                       DIM1C:=4
                    END
                    DIM1P:=0
                    DIM1B:=0
                 ELSE
                    RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR PLEASE!",OP_CODE,CP)
                 END
              END 
           ELSE
              RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/DIMENSION FUCKING ERROR",OP_CODE,CP)
           END
       ELSE
           IF VAX=="A" .AND. VBX=="N"
              IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
                 RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
              END
              AX:=stk_var_02[EBX]
              BX:=stk_var_02[EAX]
           ELSE
              IF !FUNGETDIMS(EBX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
                 RETURN _FUNPUTERROR("MAT.MIN-MAX-EQUAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
              END
           END
           SWITCH DIM1
           CASE 1 
              TEMPORAL:={}
              ESX:=0
              FOR EIX:=1 TO DIM1R
                 IF AX==BX[EIX]
                    AADD(TEMPORAL,EIX)
                    ++ESX
                 END
              END
              IF ESX==0
                 DIM1R:=0
              ELSE
                 DIM1R:=ESX
              END
              EXIT
           CASE 2
              TEMPORAL:={}
              ESX:=0
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C 
                 IF AX==BX[EIX][EJX]
                    AADD(TEMPORAL,{EIX,EJX})
                    ++ESX
                 END
              END; END
              IF ESX==0
                 DIM1:=1
                 DIM1R:=0
                 DIM1C:=0
              ELSE
                 DIM1R:=ESX
                 DIM1C:=2
              END
              EXIT
           CASE 3
              TEMPORAL:={}
              ESX:=0
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P 
                 IF AX==BX[EIX][EJX][EKX]
                    AADD(TEMPORAL,{EIX,EJX,EKX})
                    ++ESX
                 END
              END; END; END
              IF ESX==0
                 DIM1:=1
                 DIM1R:=0
                 DIM1C:=0
              ELSE
                 DIM1:=2
                 DIM1R:=ESX
                 DIM1C:=3
              END
              DIM1P:=0
              EXIT
           OTHERWISE
              TEMPORAL:={}
              ESX:=0
              FOR EIX:=1 TO DIM1R;FOR EJX:=1 TO DIM1C;FOR EKX:=1 TO DIM1P; FOR ELX:=1 TO DIM1B 
                 IF AX==BX[EIX][EJX][EKX][ELX]
                    AADD(TEMPORAL,{EIX,EJX,EKX,ELX})
                    ++ESX
                 END
              END; END; END; END
              IF ESX==0
                 DIM1:=1
                 DIM1R:=0
                 DIM1C:=0
              ELSE
                 DIM1:=2
                 DIM1R:=ESX
                 DIM1C:=4
              END
              DIM1P:=0
              DIM1B:=0
           END
       END       
     end
  END
  ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
  stk_var_02[CWM]:= TEMPORAL   /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
  FUNPUTDIMS(CWM,DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B)
  RELEASE TEMPORAL
  STACK[CS] := CWM  
RETURN .T.
        
/**************************************************************
           FAM. TSTATS_CODE MISCELANEOS media y suma
**************************************************************/
FUNCTION TSTATS_CODE()   // 127
LOCAL EAX,EBX,BX,EDX,EMX,EHX,EIX,EJX,EKX,AX
LOCAL DIM1,TYP1,DIM1R,DIM1C,DIM1P,DIM1B,ROW,COL,PAG,BLK
LOCAL OP_CODE:=1270,FUENTE,TEMPORAL,DIV
  EAX:=STACK[CS]
  FUENTE:=stk_var_02[EAX]     // arreglo
  EBX:=STACK[CS-1] 
  BX:=stk_var_02[EBX]     // codigo de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  FVWITH := FLAG[1]   // valor
  FTWITH := UPPER(FLAG[2])   // tipo
  if FTWITH!="C"
     FTWITH:="C"
     FVWITH:=""
  end
  FVWITH:=upper(FVWITH)
  if BX==1    // ^MEDIA
     EMX:="MEAN"
  elseif BX==2  // ^SUM
     EMX:="SUM"
  end   
  IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
     RETURN _FUNPUTERROR(EMX+"/MATRIX NOT INITIALIZED",OP_CODE,CP)
  end

  if BX==1 .or. BX==2    // ^MEAN o ^SUM
     ROW:=0; COL:=0; PAG:=0; BLK:=0
     SWITCH DIM1
     CASE 1   // es un vector!
        TEMPORAL:=ARRAY(1)
        TEMPORAL[1]:=FT_ASUM(FUENTE)
        if BX==1  // es una media!
           TEMPORAL[1]:=TEMPORAL[1]/DIM1R
        end
        ROW:=1
        EXIT
     CASE 2  // es una matrix 2D
        COL:=0
        SWITCH FVWITH
        CASE "R"   
           TEMPORAL:=ARRAY(DIM1R)
           for EHX:=1 to DIM1R
              TEMPORAL[EHX]:=FT_ASUM(FUENTE[EHX])
              if BX==1
                 TEMPORAL[EHX]:=TEMPORAL[EHX]/DIM1C
              end
           end
           ROW:=DIM1R
           EXIT
        CASE "C"
           TEMPORAL:=ARRAY(DIM1C)
           for EIX:=1 to DIM1C
              EPX:=0
              for EHX:=1 to DIM1R
                 EPX+=FUENTE[EHX][EIX]
              end
              TEMPORAL[EIX]:=EPX
              if BX==1
                 TEMPORAL[EIX]:=TEMPORAL[EIX]/DIM1R
              end
           end
           ROW:=DIM1C
           EXIT
        OTHERWISE
           // suma todas las filas y las columnas y devuelve un único valor
           TEMPORAL:=ARRAY(1)
           EPX:=0
           DIV := IIF( BX==1, DIM1R*DIM1C, 1 )
           for EHX:=1 to DIM1R
              EPX += FT_ASUM(FUENTE[EHX])
           end
           TEMPORAL[1]:=EPX / DIV
           ROW:=1
        end
        DIM1:=1  // porque es un vector de sumas
        EXIT
     CASE 3   // 3D!
        PAG:=0
        // FVWITH puede ser ROW(todas), ROWPAG(todas las row por la pag indicada), COL, COLPAG
        // ROW=vector de sumas; ROWPAG=matriz de sumas por pag; omision=suma total
        SWITCH FVWITH
        CASE "R"   
           TEMPORAL:=ARRAY(DIM1R)
           DIV := IIF( BX==1, DIM1C*DIM1P, 1 )
           for EHX:=1 to DIM1R
              EPX:=0
              for EJX:=1 to DIM1P; for EIX:=1 to DIM1C
                 EPX:=EPX+FUENTE[EHX][EIX][EJX]
              end; end
              TEMPORAL[EHX]:=EPX / DIV
           end
           DIM1:=1
           ROW:=DIM1R
           EXIT
        CASE "C"
           TEMPORAL:=ARRAY(DIM1C)
           DIV := IIF( BX==1, DIM1R*DIM1P, 1 )
           for EIX:=1 to DIM1C
              EPX:=0
              for EJX:=1 to DIM1P; for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX]
              end; end
              TEMPORAL[EIX]:=EPX / DIV
           end
           DIM1:=1
           ROW:=DIM1C
           EXIT
        CASE "P"   // suma toda la pagina=vector de sumas
           TEMPORAL:=ARRAY(DIM1P)
           DIV := IIF( BX==1, DIM1R*DIM1C, 1 )
           for EJX:=1 to DIM1P
              EPX:=0
              for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX]
              end; end
              TEMPORAL[EJX]:=EPX / DIV
           end
           DIM1:=1
           ROW:=DIM1P
           EXIT
        CASE "RP" // suma filas para cada pagina de todos los bloques
           TEMPORAL:=ARRAY(DIM1R,DIM1P)
           DIV := IIF( BX==1, DIM1C, 1 )
           for EJX:=1 to DIM1P; for EHX:=1 to DIM1R
              EPX:=0
              for EIX:=1 to DIM1C
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end
              TEMPORAL[EHX][EJX]:=EPX / DIV
           end; end
           DIM1:=2
           ROW:=DIM1R
           COL:=DIM1P
           EXIT
        CASE "CP" // suma cols para cada pagina de todos los bloques
           TEMPORAL:=ARRAY(DIM1C,DIM1P)
           DIV := IIF( BX==1, DIM1R, 1 )
           for EJX:=1 to DIM1P; for EIX:=1 to DIM1C
              EPX:=0
              for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX]
              end
              TEMPORAL[EIX][EJX]:=EPX / DIV
           end; end
           DIM1:=2
           ROW:=DIM1C
           COL:=DIM1P
           EXIT
        OTHERWISE    // calcula la suma total!!
           TEMPORAL:=ARRAY(1)
           EPX:=0
           DIV := IIF( BX==1, DIM1R*DIM1C*DIM1P, 1 )
           for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
              EPX:=EPX+FUENTE[EHX][EIX][EJX]
           end; end; end
           TEMPORAL[1]:=EPX / DIV
           DIM1:=1
           ROW:=1
        end
        EXIT
     OTHERWISE   // 4D!
        // idem 
        // FVWITH puede ser ROW(todas), ROWPAG(todas las row por la pag indicada), COL, COLPAG
        // ROW=vector de sumas; ROWPAG=matriz de sumas por pag; omision=suma total
        SWITCH FVWITH
        CASE "R"   
           TEMPORAL:=ARRAY(DIM1R)
           DIV := IIF( BX==1, DIM1B*DIM1C*DIM1P, 1 )
           for EHX:=1 to DIM1R
              EPX:=0
              for EJX:=1 to DIM1P; for EKX:=1 to DIM1B; for EIX:=1 to DIM1C
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end; end; end
              TEMPORAL[EHX]:=EPX / DIV
           end
           DIM1:=1
           ROW:=DIM1R
           EXIT
        CASE "C"
           TEMPORAL:=ARRAY(DIM1C)
           DIV := IIF( BX==1, DIM1R*DIM1B*DIM1P, 1 )
           for EIX:=1 to DIM1C
              EPX:=0
              for EJX:=1 to DIM1P; for EKX:=1 to DIM1B; for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end; end; end
              TEMPORAL[EIX]:=EPX / DIV
           end
           DIM1:=1
           ROW:=DIM1C
           EXIT
        CASE "P"   // suma cada pagina de todos los bloques
           TEMPORAL:=ARRAY(DIM1P)
           DIV := IIF( BX==1, DIM1R*DIM1C*DIM1B, 1 )
           for EJX:=1 to DIM1P
              EPX:=0
              for EKX:=1 to DIM1B; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end; end; end
              TEMPORAL[EJX]:=EPX / DIV
           end
           DIM1:=1
           ROW:=DIM1P
           EXIT
        CASE "RP" // suma filas para cada pagina de todos los bloques
           TEMPORAL:=ARRAY(DIM1R,DIM1P)
           DIV := IIF( BX==1, DIM1B*DIM1C, 1 )
           for EJX:=1 to DIM1P; for EHX:=1 to DIM1R
              EPX:=0
              for EKX:=1 to DIM1B; for EIX:=1 to DIM1C
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end; end
              TEMPORAL[EHX][EJX]:=EPX / DIV
           end; end
           DIM1:=2
           ROW:=DIM1R
           COL:=DIM1P
           EXIT
        CASE "CP" // suma cols por pag=matriz de sumas
           TEMPORAL:=ARRAY(DIM1C,DIM1P)
           DIV := IIF( BX==1, DIM1R*DIM1B, 1 )
           for EJX:=1 to DIM1P; for EIX:=1 to DIM1C
              EPX:=0
              for EKX:=1 to DIM1B; for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end; end
              TEMPORAL[EIX][EJX]:=EPX / DIV
           end; end
           DIM1:=2
           ROW:=DIM1C
           COL:=DIM1P
           EXIT
        CASE "PB" // suma cada pagina por bloques: matriz!
           TEMPORAL:=ARRAY(DIM1P,DIM1B)
           DIV := IIF( BX==1, DIM1R*DIM1C, 1 )
           for EKX:=1 to DIM1B; for EJX:=1 to DIM1P
              EPX:=0
              for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end; end
              TEMPORAL[EJX][EKX]:=EPX / DIV
           end; end
           DIM1:=2
           ROW:=DIM1P
           COL:=DIM1B
           EXIT
        CASE "RPB" // suma cada fila por pagina por bloques: matriz 3D!
           TEMPORAL:=ARRAY(DIM1R,DIM1P,DIM1B)
           DIV := IIF( BX==1, DIM1C, 1 )
           for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R
              EPX:=0
              for EIX:=1 to DIM1C
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end
              TEMPORAL[EHX][EJX][EKX]:=EPX / DIV
           end; end; end
           DIM1:=3
           ROW:=DIM1R
           COL:=DIM1P
           PAG:=DIM1B
           EXIT
        CASE "CPB" // suma cada col por pagina por bloques: matriz 3D!
           TEMPORAL:=ARRAY(DIM1C,DIM1P,DIM1B)
           DIV := IIF( BX==1, DIM1R, 1 )
           for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C
              EPX:=0
              for EHX:=1 to DIM1R
                 EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
              end
              TEMPORAL[EIX][EJX][EKX]:=EPX / DIV
           end; end; end
           DIM1:=3
           ROW:=DIM1C
           COL:=DIM1P
           PAG:=DIM1B
           EXIT
        OTHERWISE    // calcula la suma total!!
           TEMPORAL:=ARRAY(1)
           EPX:=0
           DIV := IIF( BX==1, DIM1R*DIM1C*DIM1P*DIM1B, 1 )
           for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
              EPX:=EPX+FUENTE[EHX][EIX][EJX][EKX]
           end; end; end; end
           TEMPORAL[1]:=EPX / DIV
           DIM1:=1
           ROW:=1
           EXIT
        end
     end
  end
  //////stk_var_02[CWM]:=ARRAY(ROW,COL,PAG,BLK)
  stk_var_02[CWM]:=TEMPORAL ////XMMLET(TEMPORAL,DIM1,ROW,COL,PAG,BLK,0)
  FUNPUTDIMS(CWM,DIM1,TYP1,ROW,COL,PAG,BLK)
  RELEASE TEMPORAL
  --CS 
  STACK[CS] := CWM
RETURN .T.

FUNCTION FUNTOSTRING()   // 41
  LOCAL AX,EDX,DX,OP_CODE:=410,EAX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
  EAX:=STACK[CS]     // valor, argumento
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  ++CWM
  AX:=stk_var_02[EAX]
  EVX:=valtype(AX)
  if EVX!="A"
      
       stk_var_02[CWM]:=iif(EVX=="N",XFUNNUM2STRING(AX,XUPRECISION),;
              iif(EVX=="C",AX,;
              iif(AX,CONTEXT_TRUE,CONTEXT_FALSE)))   // chequear si se puede convertir
      
  else
     IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
        RETURN _FUNPUTERROR("($..),XTOSTR/MATRIX NOT INITIALIZED",OP_CODE,CP)
     end
     IF TYP1=="C"
        /*TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
        XMMLET(TEMPORAL,stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
        stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
        XMMLET(stk_var_02[CWM],TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
        FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
        STACK[CS] := CWM */
        
        //////XCOPIAMATRIX(CWM,EAX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
      /*  TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
        XMMLET(TEMPORAL,stk_var_02[EAX],DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
        stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
        XMMLET(stk_var_02[CWM],TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0) */
        FUNPUTDIMS(EAX,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
        STACK[CS] := EAX
        RETURN .T.
     END
     TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
//     SET DECIMALS TO XUPRECISION
//     SET FIXED ON
     SWITCH DIM1
     CASE 1
        SWITCH TYP1
           CASE "N"
             FOR EHX:=1 TO DIM1R
               TEMPORAL[EHX]:=XFUNNUM2STRING(AX[EHX],XUPRECISION)//alltrim(str(AX[EHX]))
             END
             EXIT
           CASE "L"
             FOR EHX:=1 TO DIM1R
               TEMPORAL[EHX]:=iif(AX[EHX],CONTEXT_TRUE,CONTEXT_FALSE)
             END
             EXIT
        END
        EXIT
     CASE 2
        SWITCH TYP1
           CASE "N"
             IF DIM1R<=DIM1C
                FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX]:=XFUNNUM2STRING(AX[EHX][EIX],XUPRECISION)//alltrim(str(AX[EHX][EIX]))
                END; END
             ELSE
                FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                   TEMPORAL[EHX][EIX]:=XFUNNUM2STRING(AX[EHX][EIX],XUPRECISION)//alltrim(str(AX[EHX][EIX]))
                END; END
             END
             EXIT
           CASE "L"
             IF DIM1R<=DIM1C
                FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
                   TEMPORAL[EHX][EIX]:=iif(AX[EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE)
                END; END
             ELSE
                FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
                   TEMPORAL[EHX][EIX]:=iif(AX[EHX][EIX],CONTEXT_TRUE,CONTEXT_FALSE)
                END; END
             END
             EXIT
        END
        EXIT
     CASE 3
        SWITCH TYP1
        CASE "N"
           IF DIM1R<=DIM1C
           FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
              TEMPORAL[EHX][EIX][EJX]:=XFUNNUM2STRING(AX[EHX][EIX][EJX],XUPRECISION)//alltrim(str(AX[EHX][EIX][EJX]))
           END; END; END
           ELSE
           FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX][EIX][EJX]:=XFUNNUM2STRING(AX[EHX][EIX][EJX],XUPRECISION)//alltrim(str(AX[EHX][EIX][EJX]))
           END; END; END
           END
           EXIT
        CASE "L"
           IF DIM1R<=DIM1C
           FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
              TEMPORAL[EHX][EIX][EJX]:=iif(AX[EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE)
           END; END; END
           ELSE
           FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX][EIX][EJX]:=iif(AX[EHX][EIX][EJX],CONTEXT_TRUE,CONTEXT_FALSE)
           END; END; END
           END
           EXIT
        END
        EXIT
     CASE 4
        SWITCH TYP1
        CASE "N"
           IF DIM1R<=DIM1C
           FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
              TEMPORAL[EHX][EIX][EJX][EKX]:=XFUNNUM2STRING(AX[EHX][EIX][EJX][EKX],XUPRECISION)//alltrim(str(AX[EHX][EIX][EJX][EKX]))
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX][EIX][EJX][EKX]:=XFUNNUM2STRING(AX[EHX][EIX][EJX][EKX],XUPRECISION)//alltrim(str(AX[EHX][EIX][EJX][EKX]))
           END; END; END; END
           END
           EXIT
        CASE "L"
           IF DIM1R<=DIM1C
           FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
              TEMPORAL[EHX][EIX][EJX][EKX]:=iif(AX[EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE)
           END; END; END; END
           ELSE
           FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX][EIX][EJX][EKX]:=iif(AX[EHX][EIX][EJX][EKX],CONTEXT_TRUE,CONTEXT_FALSE)
           END; END; END; END
           END
           EXIT
        END
        EXIT
     END
     //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
     stk_var_02[CWM]:=TEMPORAL  ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
     FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
     RELEASE TEMPORAL
//     SET DECIMALS TO 16
//     SET FIXED OFF
  end   
  STACK[CS] := CWM
RETURN .T.


/******************************************************************
                       FAM. XCODE_CN 44 "CN"
*******************************************************************/
FUNCTION XCODE_CN()  // 44
LOCAL EAX,EBX
  EAX:=STACK[CS]     // valor, argumento
  EBX:=STACK[CS-1]   // codigo de funcion
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  --CS
RETURN (__PXCODCN[stk_var_02[EBX]]:EXEC(EAX))
    
  FUNCTION FUNCHAR(EAX)
  LOCAL AX,EDX,OP_CODE:=440
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       stk_var_02[CWM]:= CHR( AX )
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("CHR/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       SWITCH DIM1
       CASE 1
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX]:=CHR( AX[EHX])
          END
          EXIT
       CASE 2
          IF DIM1R<=DIM1C
          FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX]:=CHR( AX[EHX][EIX])
          END; END
          ELSE
          FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX]:=CHR( AX[EHX][EIX])
          END; END
          END
          EXIT
       CASE 3
          IF DIM1R<=DIM1C
          FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX]:=CHR( AX[EHX][EIX][EJX])
          END; END; END
          ELSE
          FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX]:=CHR( AX[EHX][EIX][EJX])
          END; END; END
          END
          EXIT
       OTHERWISE
          IF DIM1R<=DIM1C
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX][EKX]:=CHR( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          ELSE
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX][EKX]:=CHR( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          END
       END
       ///////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    end   
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBASEHEXA(EAX)
  LOCAL AX,EDX,DX,OP_CODE:=440
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       stk_var_02[CWM]:= DECTOHEXA( AX )
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("BASE.HEXA/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       IF DIM1==1
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX]:=DECTOHEXA( AX[EHX])
          END
       ELSEIF DIM1==2
          IF DIM1R<=DIM1C
          FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX]:=DECTOHEXA( AX[EHX][EIX])
          END; END
          ELSE
          FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX]:=DECTOHEXA( AX[EHX][EIX])
          END; END
          END
       ELSEIF DIM1==3
          IF DIM1R<=DIM1C
          FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX]:=DECTOHEXA( AX[EHX][EIX][EJX])
          END; END; END
          ELSE
          FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX]:=DECTOHEXA( AX[EHX][EIX][EJX])
          END; END; END
          END
       ELSE
          IF DIM1R<=DIM1C
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX][EKX]:=DECTOHEXA( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          ELSE
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX][EKX]:=DECTOHEXA( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          END
       END
       //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:=TEMPORAL  ///XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    end   
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNBASEOCTAL(EAX)
  LOCAL AX,EDX,DX,OP_CODE:=440
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       stk_var_02[CWM]:= DECTOOCTAL( AX )
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("BASE.OCTAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       SWITCH DIM1
       CASE 1
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX]:=DECTOOCTAL( AX[EHX])
          END
          EXIT
       CASE 2
          IF DIM1R<=DIM1C
          FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX]:=DECTOOCTAL( AX[EHX][EIX])
          END; END
          ELSE
          FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX]:=DECTOOCTAL( AX[EHX][EIX])
          END; END
          END
          EXIT
       CASE 3
          IF DIM1R<=DIM1C
          FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX]:=DECTOOCTAL( AX[EHX][EIX][EJX])
          END; END; END
          ELSE
          FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX]:=DECTOOCTAL( AX[EHX][EIX][EJX])
          END; END; END
          END
          EXIT
       OTHERWISE
          IF DIM1R<=DIM1C
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX][EKX]:=DECTOOCTAL( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          ELSE
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX][EKX]:=DECTOOCTAL( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          END
          EXIT
       END
       /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:=TEMPORAL  ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    end   
    STACK[CS] := CWM
  RETURN .T.
  
  FUNCTION FUNTONATURAL(EAX)  // SEC2TIME
  LOCAL AX,EDX,DX,OP_CODE:=440
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       stk_var_02[CWM]:= TSTRING( AX )
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("SEC2TIME/MATRIX NOT INITIALIZED",XOP_CODE,CP)
       end
       TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       SWITCH DIM1
       CASE 1
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX]:=TSTRING( AX[EHX])
          END
          EXIT
       CASE 2
          IF DIM1R<=DIM1C
          FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX]:=TSTRING( AX[EHX][EIX])
          END; END
          ELSE
          FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX]:=TSTRING( AX[EHX][EIX])
          END; END
          END
          EXIT
       CASE 3
          IF DIM1R<=DIM1C
          FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX]:=TSTRING( AX[EHX][EIX][EJX])
          END; END; END
          ELSE
          FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX]:=TSTRING( AX[EHX][EIX][EJX])
          END; END; END
          END
          EXIT
       OTHERWISE
          IF DIM1R<=DIM1C
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX][EKX]:=TSTRING( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          ELSE
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX][EKX]:=TSTRING( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          END
          EXIT
       END
       //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    end   
    STACK[CS] := CWM
  RETURN .T.
         
  FUNCTION FUNBASEBIN(EAX)
  LOCAL AX,EDX,DX,OP_CODE:=440
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       stk_var_02[CWM]:= DECTOBIN( AX )
    else
       IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("BASE.BIN/MATRIX NOT INITIALIZED",OP_CODE,CP)
       end
       TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       SWITCH DIM1
       CASE 1
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX]:=DECTOBIN( AX[EHX])
          END
          EXIT
       CASE 2
          IF DIM1R<=DIM1C
          FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX]:=DECTOBIN( AX[EHX][EIX])
          END; END
          ELSE
          FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX]:=DECTOBIN( AX[EHX][EIX])
          END; END
          END
          EXIT
       CASE 3
          IF DIM1R<=DIM1C
          FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX]:=DECTOBIN( AX[EHX][EIX][EJX])
          END; END; END
          ELSE
          FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX]:=DECTOBIN( AX[EHX][EIX][EJX])
          END; END; END
          END
          EXIT
       OTHERWISE
          IF DIM1R<=DIM1C
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EHX:=1 TO DIM1R; FOR EIX:=1 TO DIM1C
             TEMPORAL[EHX][EIX][EJX][EKX]:=DECTOBIN( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          ELSE
          FOR EKX:=1 TO DIM1B; FOR EJX:=1 TO DIM1P; FOR EIX:=1 TO DIM1C; FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX][EIX][EJX][EKX]:=DECTOBIN( AX[EHX][EIX][EJX][EKX])
          END; END; END; END
          END
          EXIT
       END
       //////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    end   
    STACK[CS] := CWM
  RETURN .T.

/******************************************************************
                    FAMILIA XCODE_CCC 45 "CCC"
*******************************************************************/
FUNCTION XCODE_CCC()  // 45
LOCAL EAX,EBX,ECX
  EAX:=STACK[CS]
  ECX:=STACK[CS-1]
  EBX:=STACK[CS-2]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(ECX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  ++CWM
  CS -= 2
RETURN (__PXCODCCC[stk_var_02[EBX]]:EXEC(EAX,ECX))

  FUNCTION FUNCRYPT(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EXX,DX,EHX,EIX,EJX,EKX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TYP2,TEMPORAL
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,XOP_CODE:=450
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    if EXX=="CC" 
       stk_var_02[CWM]:=CRYPT (stk_var_02[ECX],stk_var_02[EAX])
    else
       // obtiene EAX array DE CLAVE
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("CRYPT/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  MENSAJE A CIFRAR
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("CRYPT/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("CRYPT/DIMENSION ERROR",XOP_CODE,CP)
             end
          end
       end
       TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       IF EXX=="AA"   // AMBOS SON MATRICES
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=CRYPT(CX[EHX],AX[EHX])
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=CRYPT(CX[EHX][EIX],AX[EHX][EIX])
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=CRYPT(CX[EHX][EIX],AX[EHX][EIX])
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=CRYPT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=CRYPT(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=CRYPT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=CRYPT(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             END
             EXIT
          END
       ELSEIF EXX=="AC"
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=CRYPT(CX[EHX],AX)
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=CRYPT(CX[EHX][EIX],AX)
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=CRYPT(CX[EHX][EIX],AX)
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=CRYPT(CX[EHX][EIX][EJX],AX)
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=CRYPT(CX[EHX][EIX][EJX],AX)
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=CRYPT(CX[EHX][EIX][EJX][EKX],AX)
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=CRYPT(CX[EHX][EIX][EJX][EKX],AX)
             END; END; END; END
             END
             EXIT
          END
       END
       //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    end
    STACK[CS]:=CWM
  RETURN .T.

  FUNCTION FUNELAPTIME(EAX,ECX)
  LOCAL AX,CX,EVX,EWX,EXX,DX,EHX,EIX,EJX,EKX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TYP2,TEMPORAL
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,XOP_CODE:=450
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    if EXX=="CC" 
       stk_var_02[CWM]:=ELAPTIME(CX,AX)
    else
       // obtiene EAX array DE CLAVE
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("ELAPTIME/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  MENSAJE A CIFRAR
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("ELAPTIME/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("ELAPTIME/DIMENSION ERROR",XOP_CODE,CP)
             end
          end
       end
       TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       IF EXX=="AA"   // AMBOS SON MATRICES
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=ELAPTIME(CX[EHX],AX[EHX])
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=ELAPTIME(CX[EHX][EIX],AX[EHX][EIX])
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=ELAPTIME(CX[EHX][EIX],AX[EHX][EIX])
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=ELAPTIME(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=ELAPTIME(CX[EHX][EIX][EJX],AX[EHX][EIX][EJX])
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=ELAPTIME(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=ELAPTIME(CX[EHX][EIX][EJX][EKX],AX[EHX][EIX][EJX][EKX])
             END; END; END; END
             END
             EXIT
          END
       ELSEIF EXX=="AC"
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX]:=ELAPTIME(CX[EHX],AX)
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX]:=ELAPTIME(CX[EHX][EIX],AX)
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX]:=ELAPTIME(CX[EHX][EIX],AX)
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX]:=ELAPTIME(CX[EHX][EIX][EJX],AX)
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX]:=ELAPTIME(CX[EHX][EIX][EJX],AX)
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                TEMPORAL[EHX][EIX][EJX][EKX]:=ELAPTIME(CX[EHX][EIX][EJX][EKX],AX)
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                TEMPORAL[EHX][EIX][EJX][EKX]:=ELAPTIME(CX[EHX][EIX][EJX][EKX],AX)
             END; END; END; END
             END
             EXIT
          END
       END
       //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
    end
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNXUMLUNPARSER()   // 39
  LOCAL AX,CX,DX,FX
  LOCAL ES_VACIO,ABX,AEX,EDX,OP_CODE:=390
  LOCAL EHX,EIX,EJX,EKX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS; ++CWM
    // chequear si contiene atributos o si es una etiqueta vacía
    EVX:=VALTYPE(AX)
    EWX:=VALTYPE(BX)
    IF EVX+EWX=="CC"
       stk_var_02[CWM]:=FUNUNPARSER(AX,BX,@FX)
       if alltrim(stk_var_02[CWM])=="CODERROR-XU-$%@"
          RETURN _FUNPUTERROR("UNPARSER/MISSING TAG",OP_CODE,CP)
       end
       stk_var_02[EAX]:=STRTRAN(stk_var_02[EAX],FX,"",,1)
    ELSE
       EEX:=EVX+EWX
       IF EVX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.) .OR. DIM1>1
             RETURN _FUNPUTERROR("UNPARSER/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
          END
       END
       IF EWX=="A"          
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.) .OR. DIM2>1
             RETURN _FUNPUTERROR("UNPARSER/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
          IF DIM1R!=DIM2R
             RETURN _FUNPUTERROR("UNPARSER/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
           TEMPORAL:=ARRAY(DIM1R)
           FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX] := FUNUNPARSER(AX[EHX],BX[EHX],@FX)
              stk_var_02[EAX][EHX]:=STRTRAN(stk_var_02[EAX][EHX],FX,"",,1)
           END
           /////stk_var_02[CWM]:=ARRAY(DIM1R)
           stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
           FUNPUTDIMS(CWM,DIM1,"C",DIM1R,0,0,0) 
           RELEASE TEMPORAL
       ELSEIF EEX=="AC"
          TEMPORAL:=ARRAY(DIM1R) //,DIM1C,DIM1P,DIM1B)
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX] := FUNUNPARSER(AX[EHX],BX,@FX)
             stk_var_02[EAX][EHX]:=STRTRAN(stk_var_02[EAX][EHX],FX,"",,1)
          END
           //////stk_var_02[CWM]:=ARRAY(DIM1R)
           stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,0,0,0) 
          RELEASE TEMPORAL
       ELSE  // DEBE SER EEX="CA"
          TEMPORAL:=ARRAY(DIM2R)
          FOR EHX:=1 TO DIM2R
             TEMPORAL[EHX] := FUNUNPARSER(AX,BX[EHX],@FX)
             stk_var_02[EAX][EHX]:=STRTRAN(stk_var_02[EAX][EHX],FX,"",,1)
          END
           //////stk_var_02[CWM]:=ARRAY(DIM2R)
           stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM2,DIM2R,0,0,0,0)
          FUNPUTDIMS(CWM,DIM2,"C",DIM2R,0,0,0) 
          RELEASE TEMPORAL
       END
    END
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNUNPARSER(AX,BX,FX)  
  LOCAL EX,ES_VACIO,DX,GX,OP_CODE:=390
    EX:="<"+BX+">"     // obtengo el campo
    // debo saber si se trata de una etqueta vacía, un tag con atributos o uno norma
    ES_VACIO:=.F.
    GX:=AT(EX,AX)            // donde empieza el campo
    if GX==0
       EX:="<"+BX+"/>"
       GX:=AT(EX,AX)
       if GX==0
          ///_FUNPUTERROR("UNPARSER/MISSING TAG",OP_CODE,CP)
          FX:=""
          RETURN "CODERROR-XU-$%@"
       else
          ES_VACIO:=.T.
          DX:="" 
       end
    end
    FX:=""
    if !ES_VACIO
       DX:=substr(AX,GX+len(EX),len(AX))
       DX:=substr(DX,1,at("</"+BX+">",DX)-1)
       FX:=EX+DX+"</"+BX+">"
    end
  RETURN DX 
  
  FUNCTION FUNXUMLPARSER()    // 54
  LOCAL AX,CX,EVX,EWX,EEX,DX,EDX,OP_CODE:=540
  LOCAL EHX,EIX,EJX,EKX,TEMPORAL
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,TYP2
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS; ++CWM
    // chequear FLAG
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C" 
       FVWITH:="U"
       FTWITH:="C"
    else
       FVWITH:=UPPER(FVWITH)
    end
    // chequear si contiene atributos o si es una etiqueta vacía
    EVX:=VALTYPE(AX)
    EWX:=VALTYPE(BX)
    IF EVX+EWX=="CC"
       stk_var_02[CWM]:=FUNDOPARSER(AX,BX,FVWITH)
    ELSE
       EEX:=EVX+EWX
       IF EVX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.) .OR. DIM1>1
             RETURN _FUNPUTERROR("PARSER/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
          END
       END
       IF EWX=="A"          
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.) .OR. DIM2>1
             RETURN _FUNPUTERROR("PARSER/MATRIX NOT INITIALIZED OR INVALID",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
          IF DIM1R!=DIM2R 
             RETURN _FUNPUTERROR("PARSER/DIMENSION GARRAFAL ERROR",OP_CODE,CP)
          END
       END
       IF EEX=="AA"
           TEMPORAL:=ARRAY(DIM1R)
           FOR EHX:=1 TO DIM1R
              TEMPORAL[EHX] := FUNDOPARSER(AX[EHX],BX[EHX],FVWITH)
           END
           /////stk_var_02[CWM]:=ARRAY(DIM1R)
           stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
           FUNPUTDIMS(CWM,DIM1,"C",DIM1R,0,0,0)
           RELEASE TEMPORAL
       ELSEIF EEX=="AC"
          TEMPORAL:=ARRAY(DIM1R)
          FOR EHX:=1 TO DIM1R
             TEMPORAL[EHX] := FUNDOPARSER(AX[EHX],BX,FVWITH)
          END
           /////stk_var_02[CWM]:=ARRAY(DIM1R)
           stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,0,0,0,0)
          FUNPUTDIMS(CWM,DIM1,"C",DIM1R,0,0,0)
          RELEASE TEMPORAL
       ELSE  // DEBE SER EEX="CA"
          TEMPORAL:=ARRAY(DIM2R)
          FOR EHX:=1 TO DIM2R
             TEMPORAL[EHX] := FUNDOPARSER(AX,BX[EHX],FVWITH)
          END
           //////stk_var_02[CWM]:=ARRAY(DIM2R)
           stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM2,DIM2R,0,0,0,0)
           FUNPUTDIMS(CWM,DIM2,"C",DIM2R,0,0,0)
           RELEASE TEMPORAL
       END
    END
    STACK[CS]:=CWM
  RETURN .T.
  
  FUNCTION FUNDOPARSER(AX,CX,FVWITH)
  LOCA EDX,AEX,EBX,HX,DX
    EDX:=.F.
    if alltrim(AX)==""    // es una etiqueta vacía
       EDX:=.T.
    end
    if "=" $ CX    // hay atributos
       ABX:=at(" ",CX)
       AEX:=alltrim(substr(CX,ABX, len(CX)) )
       CX:=alltrim(substr(CX,1,ABX-1) )
       if EDX
          if FVWITH=="U"  // unico tag
             HX:="<"+CX+" "+AEX+"/>"
          else
             HX:="<"+CX+" "+AEX+">"
          end
       else
          HX:="<"+CX+" "+AEX+">"
       end 
    else 
       if EDX
          if FVWITH=="U"  // unico tag
             HX:="<"+CX+"/>"   // es un tag simple
          else
             HX:="<"+CX+">"
          end
       else
          HX:="<"+CX+">"   // es un tag simple
       end
    end
    
    if EDX
       if FVWITH!="U"  // unico tag
          DX:= HX+"</"+CX+">"
       else
          DX:= HX
       end
    else   
       DX:= (HX+AX+"</"+CX+">")
    end
  RETURN DX
/******************************************************************
               FUNCIONES MISCELANEAS FAM FMISCA_CODE
*******************************************************************/
   FUNCTION FUNFLAG()  // 31
  LOCAL EAX
    EAX:=STACK[CS]
    FLAG[1]:=stk_var_02[EAX]
    FLAG[2]:=valtype(FLAG[1])
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
  RETURN .T.
  
  FUNCTION FUNSTRPAD()  // 154
  LOCAL EAX,EBX,EDX,AX,BX,CX,DX,EX,TEMPORAL
  LOCAL DIM2R,DIM2C,DIM2P,DIM2B,DIM1R,DIM1C,DIM1P,DIM1B,DIM1,DIM2,TYP1,TYP2
  LOCAL OP_CODE:=1540
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    AX:=stk_var_02[EAX]          // tamano
    BX:=stk_var_02[EBX]        // string
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS
    ++CWM
    // almaceno los flag de WITH por si se usan
    FVWITH := FLAG[1]   // valor
    FTWITH := UPPER(FLAG[2])   // tipo
    if FTWITH!="C" .or. len(FVWITH)!=2
       FVWITH:="L "
       FTWITH:="C"
    end
    FVWITH:=upper(FVWITH)
    DX:=substr(FVWITH,1,1)
    EX:=substr(FVWITH,2,1)
    if EX==""
       EX:=" "
    end
    
    EVX:=VALTYPE(BX)  // TYPO STRING O MAT
    EWX:=VALTYPE(AX)  // TYPE TAMANO O MAT DE TAMANO
    IF EVX+EWX == "CN" .or. EVX+EWX == "NN"
       CX:=""
       SWITCH DX
       CASE "C"             // centrado
          CX:=PADC(BX,AX,EX)
          EXIT
       CASE "L"         // izquierda
          CX:=PADR(BX,AX,EX)
          EXIT
       CASE "R"         // derecha
          CX:=PADL(BX,AX,EX)
          EXIT
       OTHERWISE
          CX:=PADC(BX,AX,EX)    // SE ASUME EN AUSENCIA DE FLAG!
       end
       stk_var_02[CWM]:=CX
       STACK[CS]:=CWM
    ELSE   // ES MATRIX??
       if EWX=="A"   // obtiene EAX array DE TAMANO
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("STRPAD/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  MENSAJE A PADEAR
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("STRPAD/MATRIX NOT INITIALIZED",OP_CODE,CP)
          end
          if EVX+EWX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("STRPAD/DIMENSION ERROR",OP_CODE,CP)
             end
          end
       end
       CX:=IIF(DX=="C",0,IIF(DX=="L",1,2))
       ////TEMPORAL:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       TEMPORAL:=XSTRPAD(BX,AX,EX,{DIM2,DIM2R,DIM2C,DIM2P,DIM2B,CX,IIF(EWX=="A",1,0)})
       //////stk_var_02[CWM]:=ARRAY(DIM2R,DIM2C,DIM2P,DIM2B)
       stk_var_02[CWM]:= TEMPORAL ////  XMMLET(TEMPORAL,DIM2,DIM2R,DIM2C,DIM2P,DIM2B,0)
       FUNPUTDIMS(CWM,DIM2,"C",DIM2R,DIM2C,DIM2P,DIM2B)
       RELEASE TEMPORAL
       STACK[CS]:=CWM
    END
  RETURN .T.

  FUNCTION FUNNEAR()   // 71
  LOCAL EAX,ECX,AX,CX,EDX
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TYP2
  LOCAL DIM2,DIM2R,DIM2C,DIM2P,DIM2B,XOP_CODE:=710
    EAX:=STACK[CS]
    ECX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    ++CWM; --CS
    AX:=stk_var_02[EAX]
    CX:=stk_var_02[ECX]
    EWX:=valtype(AX)
    EVX:=valtype(CX)
    EXX:=EVX+EWX
    if EXX=="NN" 
       stk_var_02[CWM]:=(ABS(CX-ABS(AX)) <= DFLAG)
       STACK[CS]:=CWM
    else
       // obtiene EAX array DE CLAVE
       if EWX=="A"
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("ISNEAR/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          ELSEIF TYP1!="N"
             RETURN _FUNPUTERROR("ISNEAR/TYPE MISMATCH (I NEED MATRIX NUMBER)",XOP_CODE,CP)
          end
       end
       if EVX=="A" // correcto  MENSAJE A CIFRAR
          IF !FUNGETDIMS(ECX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("ISNEAR/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          ELSEIF TYP2!="N"
             RETURN _FUNPUTERROR("ISNEAR/TYPE MISMATCH (I NEED MATRIX NUMBER)",XOP_CODE,CP)
          end
          if EXX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("ISNEAR/DIMENSION ERROR",XOP_CODE,CP)
             end
          end
       end
      
       STACK[CS]:=CWM
       IF EXX=="AA"   // AMBOS SON MATRICES
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX]-ABS(AX[EHX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                IF (ABS(CX[EHX][EIX]-ABS(AX[EHX][EIX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX][EIX]-ABS(AX[EHX][EIX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END
             END
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                IF (ABS(CX[EHX][EIX][EJX]-ABS(AX[EHX][EIX][EJX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX][EIX][EJX]-ABS(AX[EHX][EIX][EJX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                IF (ABS(CX[EHX][EIX][EJX][EKX]-ABS(AX[EHX][EIX][EJX][EKX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX][EIX][EJX][EKX]-ABS(AX[EHX][EIX][EJX][EKX])) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END; END
             END
             EXIT
          END
       ELSEIF EXX=="AN"
          SWITCH DIM2
          CASE 1
             FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END
             EXIT
          CASE 2
             IF DIM2R<=DIM2C
             FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                IF (ABS(CX[EHX][EIX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END
             ELSE
             FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX][EIX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END
             END 
             EXIT
          CASE 3
             IF DIM2R<=DIM2C
             FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                IF (ABS(CX[EHX][EIX][EJX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END
             ELSE
             FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX][EIX][EJX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END
             END
             EXIT
          OTHERWISE
             IF DIM2R<=DIM2C
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EHX:=1 TO DIM2R; FOR EIX:=1 TO DIM2C
                IF (ABS(CX[EHX][EIX][EJX][EKX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END; END
             ELSE
             FOR EKX:=1 TO DIM2B; FOR EJX:=1 TO DIM2P; FOR EIX:=1 TO DIM2C; FOR EHX:=1 TO DIM2R
                IF (ABS(CX[EHX][EIX][EJX][EKX]-ABS(AX)) > DFLAG)
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                END
             END; END; END; END
             END
             EXIT
          END
       END
       stk_var_02[CWM]:=.T.
    end
    
  RETURN .T.

  FUNCTION FUNNEGATIVE()   // 28
  LOCAL EAX,AX,EFX,EHX,EIX,EJX,EKX,OP_CODE:=280
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    if valtype(AX)=="N"
       stk_var_02[CWM]:=(stk_var_02[EAX]<0)
       STACK[CS] := CWM
    else   // es array!
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
         IF TYP1=="N" 
          STACK[CS] := CWM
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                if AX[EHX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if AX[EHX][EIX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if AX[EHX][EIX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if AX[EHX][EIX][EJX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if AX[EHX][EIX][EJX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end
             END
             EXIT
          OTHERWISE
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if AX[EHX][EIX][EJX][EKX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if AX[EHX][EIX][EJX][EKX]>=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end; end
             END
             EXIT
          END
          stk_var_02[CWM]:=.T.
         ELSE
          RETURN _FUNPUTERROR("ISPOS/TYPE MISMATCH (I NEED MATRIX NUMBER)",OP_CODE,CP)
         END
       ELSE
          RETURN _FUNPUTERROR("ISNEG/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    end
  RETURN .T.
  
  FUNCTION FUNPOSITIVE()  // 22
  LOCAL EAX,AX,EFX,EHX,EIX,EJX,EKX,OP_CODE:=220
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    if valtype(AX)=="N"
       stk_var_02[CWM]:=(stk_var_02[EAX]>0)
       STACK[CS] := CWM
    else   // es array!
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
         IF TYP1=="N" 
          STACK[CS] := CWM
          SWITCH DIM1
          CASE 1
             for EHX:=1 to DIM1R
                if AX[EHX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if AX[EHX][EIX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end
             ELSE
             for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if AX[EHX][EIX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if AX[EHX][EIX][EJX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end
             ELSE
             for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if AX[EHX][EIX][EJX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end
             END
             EXIT
          OTHERWISE
             IF DIM1R<=DIM1C
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                if AX[EHX][EIX][EJX][EKX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end; end
             ELSE
             for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                if AX[EHX][EIX][EJX][EKX]<=0
                   stk_var_02[CWM]:=.F.
                   RETURN .T.
                end
             end; end; end; end
             END
             EXIT
          END
          stk_var_02[CWM]:=.T.
         ELSE
          RETURN _FUNPUTERROR("ISPOS/TYPE MISMATCH (I NEED MATRIX NUMBER)",OP_CODE,CP)
         END
       ELSE
          RETURN _FUNPUTERROR("ISPOS/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    end
  RETURN .T.
          
  FUNCTION FUNISALL()   // 32  SIRVE PARA COMPARAR SI ES CERO, O SI TIENE ELEMENTOS VACIOS SI ES STRING
  LOCAL EAX,AX,BX,EBX,EFX,EHX,EIX,EJX,EKX,OP_CODE:=320
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1
    EBX:=STACK[CS]    // ESCALAR
    EAX:=STACK[CS-1]  // ARREGLO O MATRIZ
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(EAX,CWM,TopCWM)    
    ++CWM
    --CS
    BX:=stk_var_02[EBX]
    AX:=stk_var_02[EAX]
    if valtype(AX)!="A"
       if VALTYPE(BX)!="C"
          stk_var_02[CWM]:=(AX==BX)
       else
          stk_var_02[CWM]:=(AX+" "==BX+" ")
       end
       STACK[CS] := CWM
    else   // es array!
       IF FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          
          STACK[CS] := CWM
          SWITCH DIM1
          CASE 1
             if TYP1=="C" .and. LEN(BX)==0
                for EHX:=1 to DIM1R
                   if LEN(AX[EHX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end
             else
                for EHX:=1 to DIM1R
                   if AX[EHX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end
             end
             EXIT
          CASE 2
             IF DIM1R<=DIM1C
             if TYP1=="C" .and. LEN(BX)==0
                for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if LEN(AX[EHX][EIX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end
             else
                for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end
             end
             ELSE
             if TYP1=="C" .and. LEN(BX)==0
                for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if LEN(AX[EHX][EIX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end
             else
                for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end
             end
             END
             EXIT
          CASE 3
             IF DIM1R<=DIM1C
             if TYP1=="C" .and. LEN(BX)==0
                for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if LEN(AX[EHX][EIX][EJX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end
             else
                for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX][EJX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end
             end
             ELSE
             if TYP1=="C" .and. LEN(BX)==0
                for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if LEN(AX[EHX][EIX][EJX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end
             else
                for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX][EJX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end
             end
             END
             EXIT
          OTHERWISE
             IF DIM1R<=DIM1C
             if TYP1=="C" .and. LEN(BX)==0
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if LEN(AX[EHX][EIX][EJX][EKX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end; end
             else
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EHX:=1 to DIM1R; for EIX:=1 to DIM1C
                   if AX[EHX][EIX][EJX][EKX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end; end
             end
             ELSE
             if TYP1=="C" .and. LEN(BX)==0
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if LEN(AX[EHX][EIX][EJX][EKX])!=0
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end; end
             else
                for EKX:=1 to DIM1B; for EJX:=1 to DIM1P; for EIX:=1 to DIM1C; for EHX:=1 to DIM1R
                   if AX[EHX][EIX][EJX][EKX]!=BX
                      stk_var_02[CWM]:=.F.
                      RETURN .T.
                   end
                end; end; end; end
             end
             END
             EXIT
          END
          stk_var_02[CWM]:=.T.
       ELSE
          RETURN _FUNPUTERROR("ISALL/MATRIX NOT INITIALIZED",OP_CODE,CP)
       END
    end
  RETURN .T.

  FUNCTION FUNIIF()  // 35
  LOCAL EAX,EBX,ECX,AX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    ECX:=STACK[CS-2]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CWM:=CMPCWM(ECX,CWM,TopCWM)
    if stk_var_02[ECX]
       AX:=stk_var_02[EBX]
    else
       AX:=stk_var_02[EAX]
    end
    CS -= 2
    stk_var_02[++CWM]:=AX
    STACK[CS] := CWM
  RETURN .T.


/******************************************************************
                   FUNCIONES FAM. FMISCB_CODE
*******************************************************************/

  FUNCTION FUNREADKEY()  // 29
  LOCAL EAX
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS 
    stk_var_02[EAX]:=INKEY()

    //stk_var_02[++CWM]:=AX
    //STACK[CS] := CWM
    
  RETURN .T.

  FUNCTION FUNSWAP()   // 66
  LOCAL EAX,EBX,AX,EFX,EGX,op_code:=660
  LOCAL DIM2R,DIM2C,DIM2P,DIM2B,DIM1R,DIM1C,DIM1P,DIM1B,DIM1,DIM2,TYP1,TYP2
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    if valtype(stk_var_02[EAX])!="A"
       AX:=stk_var_02[EAX]      // caracter
       stk_var_02[EAX]:=stk_var_02[EBX]
       stk_var_02[EBX]:=AX 
    else
       IF !FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.F.)
          RETURN _FUNPUTERROR("SWAP/MATRIX INVALID OR NOT INITIALIZED",OP_CODE,CP)
       END
       IF !FUNGETDIMS(EBX,@EGX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.F.)
          RETURN _FUNPUTERROR("SWAP/MATRIX INVALID OR NOT INITIALIZED",OP_CODE,CP)
       END
       AX:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       XCOPIAPM(AX,EAX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
       XCOPIAMATRIX(EAX,EBX,DIM2,DIM2R,DIM2C,DIM2P,DIM2B)
       XCOPIADURAMP(EBX,AX,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
    //   XMMLET(stk_var_02[EBX],stk_var_02[EAX],DIM,ROW,COL,PAG,BLK,0)
       STK_ARRAY_DIM[EGX]:=DIM1
       STK_ARRAY_TYP[EGX]:=TYP1
       STK_ARRAY_ROW[EGX]:=DIM1R
       STK_ARRAY_COL[EGX]:=DIM1C
       STK_ARRAY_PAG[EGX]:=DIM1P
       STK_ARRAY_BLK[EGX]:=DIM1B

       STK_ARRAY_DIM[EFX]:=DIM2
       STK_ARRAY_TYP[EFX]:=TYP2
       STK_ARRAY_ROW[EFX]:=DIM2R
       STK_ARRAY_COL[EFX]:=DIM2C
       STK_ARRAY_PAG[EFX]:=DIM2P
       STK_ARRAY_BLK[EFX]:=DIM2B       
    end
    CS -= 2
    //RELEASE AX
  RETURN .T.
  
  FUNCTION FUNLREPLEFT()   // 105
  LOCAL EAX,EBX,AX,BX,CX,DX,EDX,EXX,EVX,EWX,FUENTE,REPITE,TEMPORAL,XOP_CODE:=1050
  LOCAL DIM2R,DIM2C,DIM2P,DIM2B,DIM1R,DIM1C,DIM1P,DIM1B,DIM1,DIM2,TYP1,TYP2
    EAX:=STACK[CS]     // caracter
    EBX:=STACK[CS-1]   // numero DE REPETICIONES
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    EVX:=VALTYPE(stk_var_02[EAX])
    EWX:=VALTYPE(stk_var_02[EBX])
    EXX:=EVX+EWX
    if EXX=="CN"
       stk_var_02[CWM]:=REPLICATE(AX,BX)
    elseif EXX=="NC"
       stk_var_02[CWM]:=REPLICATE(BX,AX)
    else   // hay al menos una matriz y es la numerica
       if EVX=="A"   // obtiene EAX
          IF !FUNGETDIMS(EAX,@EDX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
             RETURN _FUNPUTERROR("REPLICATE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
       end
       if EWX=="A" // correcto  
          IF !FUNGETDIMS(EBX,@EDX,@DIM2,@TYP2,@DIM2R,@DIM2C,@DIM2P,@DIM2B,.T.)
             RETURN _FUNPUTERROR("REPLICATE/MATRIX NOT INITIALIZED",XOP_CODE,CP)
          end
          if EVX+EWX=="AA"
             if DIM1!=DIM2 .or. DIM1R!=DIM2R .or. DIM1C!=DIM2C .or. DIM1P!=DIM2P .or. DIM1B!=DIM2B
                RETURN _FUNPUTERROR("REPLICATE/DIMENSION ERROR",XOP_CODE,CP)
             end
          end
       end
       IF EXX=="AA"   // AMBOS SON MATRICES
          
          if TYP1=="N"   // DEBO VOLTEAR SI AX ES NUMBER
             FUENTE:=stk_var_02[EBX]
             REPLICA:=stk_var_02[EAX]
             TMP:=TYP1;TYP1:=TYP2;TYP2:=TMP
             TMP:=DIM1;DIM1:=DIM2;DIM2:=TMP
             TMP:=DIM1R;DIM1R:=DIM2R;DIM2R:=TMP
             TMP:=DIM1C;DIM1C:=DIM2C;DIM2C:=TMP
             TMP:=DIM1P;DIM1P:=DIM2P;DIM2P:=TMP
             TMP:=DIM1B;DIM1B:=DIM2B;DIM2B:=TMP
          else
             FUENTE:=stk_var_02[EAX]
             REPLICA:=stk_var_02[EBX]
          end
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XRPSUBSTR(FUENTE,REPLICA,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,3)
          IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("REPLICATE/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
          END
       ELSE
          
          IF EXX=="NA" // ESTÁ AL REVES: AX ES EL NUMERO ESCALAR
             FUENTE:=stk_var_02[EBX]
             REPLICA:=stk_var_02[EAX]
             TYP1:=TYP2; DIM1:=DIM2; DIM1R:=DIM2R
             DIM1C:=DIM2C; DIM1P:=DIM2P; DIM1B:=DIM2B
          else
             FUENTE:=stk_var_02[EAX]
             REPLICA:=stk_var_02[EBX] 
          END
          /////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMEADDSTR(FUENTE,REPLICA,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,3)
          IF LEN(TEMPORAL)==0
             RETURN _FUNPUTERROR("REPLICATE/NOT ENOUGHT MEMORY TO ALLOCATE",XOP_CODE,CP)
          END
       END
       /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
       stk_var_02[CWM]:= TEMPORAL   ////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
       FUNPUTDIMS(CWM,DIM1,"C",DIM1R,DIM1C,DIM1P,DIM1B)
       RELEASE TEMPORAL
    end
    STACK[--CS] := CWM
    
  RETURN .T.

  FUNCTION FUNISTYPE()   // 118
  LOCAL EAX,EBX,AX,BX,EDX,TYP
  LOCAL OP_CODE:=1180
    EAX:=STACK[CS]    // TIPO A COMPARAR
    EBX:=STACK[CS-1]  // VARIABLE
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    --CS
    ++CWM
    AX:=valtype(stk_var_02[EBX]) 

    if AX=="A"  // buscar en stk_array...
       if STK_CWMTOP>0
          EDX := STK_TEMP_DIR[STK_CWMTOP]
          if EDX!=EAX
             EDX := ASCAN(STK_ARRAY_DIR,EBX)
             TYP :=STK_ARRAY_TYP[EDX]
          else   
             TYP :=STK_TEMP_TYP[STK_CWMTOP]
             STK_TEMP_DIR[STK_CWMTOP]:=0
             STK_CWMTOP--
          end
       else
          EDX := ASCAN(STK_ARRAY_DIR,EBX)
          TYP := STK_ARRAY_TYP[EDX]
       end
       if TYP=="N"
          TYP:="<number>"
       elseif TYP=="L"
          TYP:="<boolean>"
       elseif TYP=="C"
          TYP:="<string>"
       end
       
       if TYP==stk_var_02[EAX]
          AX:=.T.
       else
          AX:=.F.
       end
    else
       if AX=="N"
          BX:="number"
       elseif AX=="C"
          BX:="string"
          if stk_var_02[EAX]=="<null>"
             BX:="(null)"
          end
       elseif AX=="L"
          BX:="boolean"
       end 

       if BX==stk_var_02[EAX]
          AX:=.T.
       else
          AX:=.F.
       end   
    end
    stk_var_02[CWM]:=AX
    STACK[CS] := CWM
    
  RETURN .T.

  FUNCTION FUNTYPE()   // 121
  LOCAL EAX,AX,EDX,TYP
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=valtype(stk_var_02[EAX]) 
    if AX=="A"  // buscar en stk_array...
       if STK_CWMTOP>0
          EDX := STK_TEMP_DIR[STK_CWMTOP]
          if EDX!=EAX
             EDX := ASCAN(STK_ARRAY_DIR,EAX)
             TYP :=STK_ARRAY_TYP[EDX]
          else   
             TYP :=STK_TEMP_TYP[STK_CWMTOP]
             STK_TEMP_DIR[STK_CWMTOP]:=0
             STK_CWMTOP--
          end
       else
          EDX := ASCAN(STK_ARRAY_DIR,EAX)
          TYP  := STK_ARRAY_TYP[EDX]
       end
       if TYP=="N"
          AX:="<number>"
       elseif TYP=="L"
          AX:="<boolean>"
       elseif TYP=="C"
          AX:="<string>"
       end
    else
       if AX=="N"
          AX:="number"
       elseif AX=="C"
          AX:="string"
          if stk_var_02[EAX]=="<null>"
             AX:="(null)"
          end
       elseif AX=="L"
          AX:="boolean"
       end 
    end
    stk_var_02[CWM]:=AX
    STACK[CS] := CWM
  RETURN .T.

  FUNCTION FUNFACTORIAL()  // 15
  LOCAL EAX,AX,BX,EFX,OP_CODE:=150
  LOCAL DIM1,DIM1R,DIM1C,DIM1P,DIM1B,TYP1,TEMPORAL
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    ++CWM
    AX:=stk_var_02[EAX]
    if valtype(AX)=="N"
       if AX<0
          RETURN _FUNPUTERROR("FACTORIAL/ARGUMENT COULD BE POSITIVE O ZERO",OP_CODE,CP)
       end
       stk_var_02[CWM]:=FACTORIAL(AX)
    else   // es array!
       IF !FUNGETDIMS(EAX,@EFX,@DIM1,@TYP1,@DIM1R,@DIM1C,@DIM1P,@DIM1B,.T.)
          RETURN _FUNPUTERROR("FACTORIAL/MATRIX NOT INITIALIZED",OP_CODE,CP)
       ELSE
          ///////TEMPORAL:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          TEMPORAL:=XMATHCOMPUTE(AX,22,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
          /////stk_var_02[CWM]:=ARRAY(DIM1R,DIM1C,DIM1P,DIM1B)
          stk_var_02[CWM]:=TEMPORAL /////XMMLET(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,0)
          FUNPUTDIMS(CWM,DIM1,"N",DIM1R,DIM1C,DIM1P,DIM1B)
          ELIMINAVARS(TEMPORAL,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
       END
    end
    STACK[CS] := CWM
  RETURN .T.


/******************************************************************
                             MISCELANEAS
*******************************************************************/
 FUNCTION FUNTRUE()   // 214
  stk_var_02[++CWM]:=.T.
  STACK[++CS] := CWM
RETURN .T.

 FUNCTION FUNFALSE()  // 215
  stk_var_02[++CWM]:=.F.
  STACK[++CS] := CWM
RETURN .T.

FUNCTION FUNGARBAGE()  // 216

  ///FT_IDLE()
  hb_gcAll()
  
RETURN .T.

FUNCTION FUNCOLOR()  // 236
LOCAL EAX
  EAX:=STACK[CS]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS
  SETCOLOR (N2COLOR(stk_var_02[EAX]))  //(NTOCOLOR(stk_var_02[EAX]))
RETURN .T.      

FUNCTION FUNCURSOR()  // 153
LOCAL EAX
  EAX:=STACK[CS]
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS
  SETCURSOR (stk_var_02[EAX])
RETURN .T.

FUNCTION FUNCLS()  //9
  CLEAR
RETURN .T.

FUNCTION FUNAPI()   // 48
LOCAL EAX,AX,BX,CX,EBX,DX,EX,ECX,EDX,EEX
LOCAL EEX1,EEX2,EEX3
LOCAL OP_CODE:=480, _codos
  EAX:=STACK[CS]
  AX:=lower(stk_var_02[EAX])
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS
  // analisis de string de API
  BX:=alltrim(substr(AX,1,at("=",AX)-1))
  CX:=alltrim(substr(AX,at("=",AX)+1,len(AX)))
  if BX=="screen"
     if CX=="0"
        clear
     else
        EAX:=ROW()
        EBX:=COL()
        DX:=REPLICATE(CX,MAXCOL())
        DISPBEGIN()
        for EX:=0 to MAXROW()
           setpos(EX,0);dispout(DX)   
        next
        @ EAX, EBX say ""
        DISPEND()
     end
  elseif BX=="box"   // api "box=2,2,14,25,D|S|DS|SD"
     EAX:=numtoken(CX,",")
     EBX:={}
     for EX:=1 to EAX-1
        aadd(EBX,val(token(CX,",",EX)))
     next
     aadd(EBX,token(CX,",",EX))
     if len(EBX)!=5
        RETURN _FUNPUTERROR("API/BOX MISSING COORS",OP_CODE,CP)
     end
     EBX[5]:=upper(EBX[5])
     if EBX[5]=="D"
        _codos:=chr(201)+chr(205)+chr(187)+chr(186)+chr(188)+chr(205)+chr(200)+chr(186)
     elseif EBX[5]=="S"
        _codos:=chr(218)+chr(196)+chr(191)+chr(179)+chr(217)+chr(196)+chr(192)+chr(179)  
     elseif EBX[5]=="DS"
        _codos:=chr(214)+chr(196)+chr(183)+chr(186)+chr(189)+chr(196)+chr(211)+chr(186)  
     elseif EBX[5]=="SD"
        _codos:=chr(213)+chr(205)+chr(184)+chr(179)+chr(190)+chr(205)+chr(212)+chr(179)  
     end   
     @ EBX[1], EBX[2] clear to EBX[3], EBX[4]
     @ EBX[1], EBX[2], EBX[3], EBX[4] box _codos             

  elseif BX=="crux"   // api "crux=x,y[,x1,y1,x2,y2,...],D|S|DS|SD"
     EAX:=numtoken(CX,",")
     EBX:={}
     for EX:=1 to EAX-1
        aadd(EBX,val(token(CX,",",EX)))
     next
     EEX:=upper(token(CX,",",EAX))

     for EX:=1 to len(EBX) step 2
        if EEX=="D"
           @ EBX[EX],EBX[EX+1] say chr(206)
        elseif EEX=="S"
           @ EBX[EX],EBX[EX+1] say chr(197)
        elseif EEX=="DS"
           @ EBX[EX],EBX[EX+1] say chr(215)
        elseif EEX=="SD"
           @ EBX[EX],EBX[EX+1] say chr(216)
        end
     end
     
  elseif BX=="hline"   // api "hline=2,2,14,<0123>,D|S|DS|SD" fila, desde, hasta, 
     EAX:=numtoken(CX,",")
     EBX:={}
     for EX:=1 to EAX-1
        aadd(EBX,val(token(CX,",",EX)))
     next
     aadd(EBX,token(CX,",",EX))
     if len(EBX)!=5
        RETURN _FUNPUTERROR("API/HLINE FUCKING ARGUMENTS",OP_CODE,CP)
     end
     ECX:=EBX[4]
     _codos:=upper(EBX[5])
     if _codos=="D" .or. _codos=="SD"
        EDX:=REPLICATE(chr(205),EBX[3]-EBX[2]-1)
     elseif _codos=="S" .or. _codos=="DS"
        EDX:=REPLICATE(chr(196),EBX[3]-EBX[2]-1)
     end
     if ECX==0
        if _codos=="D" .or. _codos=="DS"
           EDX:=chr(186)+EDX+chr(186)
        else
           EDX:=chr(179)+EDX+chr(179)
        end   
     elseif ECX==1
        if _codos=="D" 
           EDX:=chr(204)+EDX+chr(185)
        elseif _codos=="DS"
           EDX:=chr(199)+EDX+chr(182)
        elseif _codos=="S"
           EDX:=chr(195)+EDX+chr(180)
        elseif _codos=="SD"
           EDX:=chr(198)+EDX+chr(181)
        end   
     elseif ECX==2             
        if _codos=="D" 
           EDX:=chr(186)+EDX+chr(185)
        elseif _codos=="DS"
           EDX:=chr(186)+EDX+chr(182)
        elseif _codos=="S"
           EDX:=chr(179)+EDX+chr(180)
        elseif _codos=="SD"
           EDX:=chr(179)+EDX+chr(181)
        end   
     else   
        if _codos=="D" 
           EDX:=chr(204)+EDX+chr(186)
        elseif _codos=="DS"
           EDX:=chr(199)+EDX+chr(186)
        elseif _codos=="S"
           EDX:=chr(195)+EDX+chr(179)
        elseif _codos=="SD"
           EDX:=chr(198)+EDX+chr(179)
        end   
     end
     @ EBX[1], EBX[2] say EDX

  elseif BX=="vline"   // api "vline=12,30,18,D|S|DS|SD"
     EAX:=numtoken(CX,",")
     EBX:={}
     for EX:=1 to EAX-1
        aadd(EBX,val(token(CX,",",EX)))
     next
     aadd(EBX,token(CX,",",EX))  // tipo
     if len(EBX)!=4
        RETURN _FUNPUTERROR("API/VLINE FUCKING ARGUMENTS",OP_CODE,CP)
     end
     ECX:=upper(EBX[4])
     EEX1:=EBX[1]
     EEX2:=EBX[2]
     EEX3:=EBX[3]  
     if ECX=="D" 
        @ EEX1, EEX2 say chr(203)
     elseif ECX=="SD"    
        @ EEX1, EEX2 say chr(209)
     elseif ECX=="S"
        @ EEX1, EEX2 say chr(194)
     elseif ECX=="DS"
        @ EEX1, EEX2 say chr(210)
     end
     for EX:=EEX1+1 to EEX3
        if ECX=="D" .or. ECX=="DS"
           @ EX, EEX2 say chr(186)
        else
           @ EX, EEX2 say chr(179)
        end   
     next
     if ECX=="D" 
        @ EEX3, EEX2 say chr(202)
     elseif ECX=="SD"    
        @ EEX3, EEX2 say chr(207)
     elseif ECX=="S"
        @ EEX3, EEX2 say chr(193)
     elseif ECX=="DS"
        @ EEX3, EEX2 say chr(208)
     end          
  end
  RELEASE EBX
RETURN .T.


/******************************************************************
                  FAM. MISCELANEAS FMISCC_CODE
*******************************************************************/
  FUNCTION FUNOUT()  // 49
  LOCAL EAX,_files
    EAX:=STACK[CS]
    AX:=stk_var_02[EAX]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
    if SW_FHNDLOUT==1  
       FCLOSE (FHNDLOUT)
    end
    if len(alltrim(AX))==0
       SW_FHNDLOUT:=0    // desactiva salida simple
    else
       SW_FHNDLOUT:=1     // activa sw de handler
       _files:=iif(_fileSeparator $ AX,AX,PATH_OUTPUT+_fileSeparator+AX)
       FHNDLOUT:=fcreate (_files)   //crea el archivo y lo abre.
    end
  RETURN .T.

  FUNCTION FUNCONSOLE()   // 67
  LOCAL EAX
    EAX:=STACK[CS]
    if stk_var_02[EAX]==0
       SW_CONSOLE:=1
    else
       SW_CONSOLE:=0
    end
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
  RETURN .T.
  
  FUNCTION FUNVIDEO()    // 68
  LOCAL EAX,EBX,AX,BX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS-=2
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    SETMODE(BX,AX)
  RETURN .T.

/******************************************************************
                 FAM. MISCELANEAS FMISCD_CODE
*******************************************************************/

  FUNCTION FUNGOODBYE()  // 11
    __LOOP:=.F.   // PARA QUE SALGA DEL MAIN SIN ERROR
  RETURN .T.

  FUNCTION FUNSTATUS()  // 93
  LOCAL EAX
    EAX:=STACK[CS]
    if stk_var_02[EAX]
       OKFLAG:=.T.
    else
       OKFLAG:=.F.
    end
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
  RETURN .T.

  FUNCTION FUNOK()   // 162
    stk_var_02[++CWM]:=OKFLAG
    STACK[++CS] := CWM
  RETURN .T.

  FUNCTION FUNFLUSH()   // 181
  LOCAL AX:=inkey()
    while AX!=0
       AX:=inkey()
    end
  RETURN .T.
  
  FUNCTION FUNSEED()   // 143
    LOCAL EAX
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
    HB_RANDOMSEED(stk_var_02[EAX])
  RETURN .T.
  
  FUNCTION FUNKEYPUT()  // 144
    LOCAL EAX,EBX,AX,BX
    EAX:=STACK[CS]
    EBX:=STACK[CS-1]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    CWM:=CMPCWM(EBX,CWM,TopCWM)
    CS-=2
    AX:=stk_var_02[EAX]
    BX:=stk_var_02[EBX]
    if BX==256
       SETTYPEAHEAD(AX)
    else
       PUTKEY(BX,AX)
    end
  RETURN .T.
  
  FUNCTION FUNFIX()   //150
  LOCAL EAX
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
    //FIX(stk_var_02[EAX])  // precision será solo para mantisa de notacion cientifica
    XUPRECISION:=stk_var_02[EAX]
    if XUPRECISION>16
       XUPRECISION:=16
    end
  RETURN .T.
  
  FUNCTION FUNMILLISECONDS()  // 133
  LOCAL EAX
    EAX:=STACK[CS]
    CWM:=CMPCWM(EAX,CWM,TopCWM)
    --CS
    MILLISEC(stk_var_02[EAX])
  RETURN .T.
  
  FUNCTION FUNLASTKEY()  // 14
    stk_var_02[++CWM]:=LASTKEY()
    INKEY()   // consume la tecla
    STACK[++CS] := CWM
  RETURN .T.
  
  FUNCTION FUNSYSTEM()   // 34
    stk_var_02[++CWM]:=OS()
    STACK[++CS] := CWM
  RETURN .T.
  
  FUNCTION FUNPAUSE()   // 26
  LOCAL SX
    if SW_FHNDLOUT!=1
       while inkey()!=0   // flush!!
       end
       inkey(0)       // pausa
    else
       SX:="******* PAUSE inhabilitado en OUT activo"
       fwrite (FHNDLOUT,SX,len(SX))
    end
  RETURN .T.
  

/******************************************************************
             OPERACIONES INTERNAS TRY, Y DE PILA
*******************************************************************/
FUNCTION _FUNPUTERROR(MENSAJE,OP_CODE,DIR)
  IF !SW_TRY
     _ErrorSys(MENSAJE+" Excepción no manejada",OP_CODE,DIR+254)
  END
  VEXCEPTION:=OP_CODE    // validar tabla de errores
//  SW_TRY_ON:=1

// if SW_TRY_ON==1      // hay exception!!!
    // existe una variable previa de exception definida por TRY?
    if len(stk_try)==0  // Excepción dentro de otra, sin manejar
       _ErrorSys("ERROR: Excepción sin manejar, dentro de otra excepción!",0,CP+254)
    end
    CP:=stackpop(stk_try)
//    SW_TRY_ON:=0
    CS:=stackpop(BREAKCS)    //0
    // Aniadido el 8 de agosto de 2016: es posible que falle
    CWM :=stackpop(BREAKCWM)    //TopCWM
// end

RETURN .F.

FUNCTION FUNRAISE()  // 219   GENERA UN ERROR DE EXCEPCION
LOCAL EAX
  EAX:=STACK[CS]  
  --CS
  VEXCEPTION:=stk_var_02[EAX]    // validar tabla de errores
//  SW_TRY_ON:=1

// if SW_TRY_ON==1      // hay exception!!!
    // existe una variable previa de exception definida por TRY?
    if len(stk_try)==0  // Excepción dentro de otra, sin manejar
       _ErrorSys("ERROR: Excepción sin manejar, dentro de otra excepción!",0,CP+254)
    end
    CP:=stackpop(stk_try)
//    SW_TRY_ON:=0
    CS:=stackpop(BREAKCS)    //0
    // Aniadido el 8 de agosto de 2016: es posible que falle
    CWM :=stackpop(BREAKCWM)    //TopCWM
// end

RETURN .F.

FUNCTION FUNTRY()  // 159
LOCAL EAX,AX
  EAX:=STACK[CS]
  AX:=EAX-DIR
  --CS
  stackpush(stk_try,AX)
  stackpush(BREAKCS,CS)
  stackpush(BREAKCWM,CWM)
  SW_TRY:=.T.
RETURN .T.

FUNCTION FUNCLEARTRY()  // 155
  stk_try:={}
  BREAKCS:={}
  BREAKCWM:={}
  SW_TRY:=.F.
RETURN .T.

FUNCTION FUNENDT()  // 158  FIN TRY
  stackpop(stk_try)
  stackpop(BREAKCS)
  stackpop(BREAKCWM)
  SW_TRY:=.F.
RETURN .T.

FUNCTION FUNCATCH()   // 161
  // toma el valor de la variable de Excepción y lo coloca en stack main
  stk_var_02[++CWM]:=VEXCEPTION
  STACK[++CS] := CWM
  VEXCEPTION:=0
RETURN .T.

FUNCTION FUNPUSHD()  //104  guarda direccion actual POR LLAMADA A FUNCION
  stackpush(stk_local,CP+3)
RETURN .T.

FUNCTION FUNSTPOP()  // 180   cache intermedio de parametros sin referencia
LOCAL AX,VX,BX,EDX,EEX
LOCAL XDIM,TYP,DIMR,DIMC,DIMP,DIMB
  AX:=stackpop(_StackPops)        // STACK[CS-1]  // viene de llamada a funcion
  VX:=stackpop(_StackPops)     // tipo
  BX:=stackpop(_StackPops)        // STACK[CS]  // local de funcion
  // Agrego dir a STK_ARRAY... porque el array destino es legal!
  if VX=="A"  // es un array: copiar info:
     // busco info de array fuente existente: puede ser temporal
     FUNGETDIMS(AX,@EDX,@XDIM,@TYP,@DIMR,@DIMC,@DIMP,@DIMB,.T.)
     
     /////stk_var_02[BX]:=ACLO(stk_var_02[AX])  // porque es de origen temporal y se perdera
     // Busco array destino: ya existe en el stack de dirs arrays:
     EEX := ASCAN(STK_ARRAY_DIR,BX)       
     // agrego valores del array fuente. procedimiento inverso al retorno!
     STK_ARRAY_DIM[EEX]:=XDIM
     STK_ARRAY_TYP[EEX]:=TYP
     STK_ARRAY_ROW[EEX]:=DIMR
     STK_ARRAY_COL[EEX]:=DIMC
     STK_ARRAY_PAG[EEX]:=DIMP
     STK_ARRAY_BLK[EEX]:=DIMB
     /////stk_var_02[BX]:=ARRAY(DIMR,DIMC,DIMP,DIMB)
     ////stk_var_02[BX]:=stk_var_02[AX]   ///
     stk_var_02[BX]:=XMMLET(stk_var_02[AX],XDIM,DIMR,DIMC,DIMP,DIMB,0)
  else
     stk_var_02[BX]:=AX   // dato simple: guarda valor
  end
RETURN .T.

FUNCTION FUNPOPS()  // 110  guardo dirs de variable (sin ref) fuente y de funcion invocada para STPOP
LOCAL EAX,EBX,EVX
  // debiera activar un SW y debiera dejar estos valores en un stack
  // para luego asignar correctamente a las variables destino del UDF
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  stackpush(_StackPops,EAX)
  EVX:=valtype(stk_var_02[EBX])  
  stackpush(_StackPops,EVX)
  if EVX!="A"
     stackpush(_StackPops,stk_var_02[EBX])  //guardo el valor... revisar comportamiento con recursividad
  else   
     stackpush(_StackPops,EBX)  // guardo direccion
  end
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CS-=2
RETURN .T.

FUNCTION FUNRETV()   // 57   RETORNO VACIO
LOCAL AX,BX,CX,DX,EX,EAX,EBX,EDX,EEX
LOCAL DIM,ROW,COL,PAG,BLK
  // verifico referencias y traspaso valores nuevos a dorecciones originales
  if FLAGREF>0     // hay referencias?
     CX:=Stackpop(Stack_RefRecept)    // esto debe ser -1
     DX:=Stackpop(Stack_RefRecept)    // esto debe ser el valor
     if DX>0
        for EX:=1 to DX
           AX:=Stackpop(Stack_RefOrigin)
           BX:=Stackpop(Stack_RefRecept)
           if valtype(stk_var_02[AX])=="A"
              EBX:=stackpop(_MATFUNCION)
              EAX:=stackpop(_MATRETORNO)
              EDX := ASCAN(STK_ARRAY_DIR,EBX)
              EEX := ASCAN(STK_ARRAY_DIR,EAX)
              // agrego valores del array fuente. procedimiento inverso al retorno!
              STK_ARRAY_DIM[EEX]:=DIM:=STK_ARRAY_DIM[EDX]
              STK_ARRAY_TYP[EEX]:=STK_ARRAY_TYP[EDX]
              STK_ARRAY_ROW[EEX]:=ROW:=STK_ARRAY_ROW[EDX]
              STK_ARRAY_COL[EEX]:=COL:=STK_ARRAY_COL[EDX]
              STK_ARRAY_PAG[EEX]:=PAG:=STK_ARRAY_PAG[EDX]
              STK_ARRAY_BLK[EEX]:=BLK:=STK_ARRAY_BLK[EDX]

            //  stk_var_02[AX]:=ARRAY(ROW,COL,PAG,BLK)
            //  XMMLET(stk_var_02[AX],stk_var_02[BX],DIM,ROW,COL,PAG,BLK,0)
              stk_var_02[AX]:=stk_var_02[BX]
            ///  stk_var_02[AX]:=XMMLET(stk_var_02[BX],DIM,ROW,COL,PAG,BLK,0)
           else
              stk_var_02[AX]:=stk_var_02[BX]
           end
        next
        --FLAGREF
     end
  end
  CP:=stackpop(stk_local)-1
RETURN .T.

FUNCTION FUNRET()   // 58   RETORNO CON VALOR
LOCAL AX,BX,CX,DX,EX,EAX,EBX,EDX,EEX,ROW,COL,PAG,BLK
  // verifico referencias y traspaso valores nuevos a dorecciones originales
  if FLAGREF>0     // hay referencias?
     // saco el puntero y el numero de valores en referencia:
     CX:=Stackpop(Stack_RefRecept)    // esto debe ser -1
     DX:=Stackpop(Stack_RefRecept)    // esto debe ser el valor
     if DX>0
        for EX:=1 to DX    
           AX:=Stackpop(Stack_RefOrigin)
           BX:=Stackpop(Stack_RefRecept)
           if valtype(stk_var_02[AX])=="A"
              EBX:=stackpop(_MATFUNCION)
              EAX:=stackpop(_MATRETORNO)
              EDX := ASCAN(STK_ARRAY_DIR,EBX)
              EEX := ASCAN(STK_ARRAY_DIR,EAX)
              // agrego valores del array fuente. procedimiento inverso al retorno!
              STK_ARRAY_DIM[EEX]:=DIM:=STK_ARRAY_DIM[EDX]
              STK_ARRAY_TYP[EEX]:=TYP:=STK_ARRAY_TYP[EDX]
              STK_ARRAY_ROW[EEX]:=ROW:=STK_ARRAY_ROW[EDX]
              STK_ARRAY_COL[EEX]:=COL:=STK_ARRAY_COL[EDX]
              STK_ARRAY_PAG[EEX]:=PAG:=STK_ARRAY_PAG[EDX]
              STK_ARRAY_BLK[EEX]:=BLK:=STK_ARRAY_BLK[EDX]

              //stk_var_02[AX]:=ARRAY(ROW,COL,PAG,BLK)
              
              //XMMLET(stk_var_02[AX],stk_var_02[BX],DIM,ROW,COL,PAG,BLK,0)
              /** no necesito copiar la matriz, porque solo trasspaso el puntero 
                  la info de la metadata ya está traspasada **/
              stk_var_02[AX]:=stk_var_02[BX]
              ////stk_var_02[AX]:=XMMLET(stk_var_02[BX],DIM,ROW,COL,PAG,BLK,0)
           else
              stk_var_02[AX]:=stk_var_02[BX]
           end
        next
        --FLAGREF
     end
  end
  CP:=stackpop(stk_local)-1
RETURN .T.

FUNCTION FUNPOPL()   // 52   saca datos de var de stack local
LOCAL AX,EAX,EDX,DIM,ROW,COL,PAG,BLK,ETX
  AX:=stackpop(stk_var_local)
  if valtype(AX)=="A"   // puta puta puta puta puta puta puta
     //////stk_var_02[STACK[CS]]:=ACLO(AX)
     EAX:=stackpop(stk_dim_local)
     EDX := ASCAN(STK_ARRAY_DIR,EAX[1])
     //EAX,DIM,TYP,ROW,COL,PAG,BLK
     STK_ARRAY_DIM[EDX]:=DIM:=EAX[2]
     STK_ARRAY_TYP[EDX]:=EAX[3]
     STK_ARRAY_ROW[EDX]:=ROW:=EAX[4]
     STK_ARRAY_COL[EDX]:=COL:=EAX[5]
     STK_ARRAY_PAG[EDX]:=PAG:=EAX[6]
     STK_ARRAY_BLK[EDX]:=BLK:=EAX[7]
     
     /////stk_var_02[STACK[CS]]:=ARRAY(ROW,COL,PAG,BLK)
     /////ETX:=stk_var_02[STACK[CS]]
     stk_var_02[STACK[CS]]:=ETX  ///XMMLET(AX,DIM,ROW,COL,PAG,BLK,0)
  else
     stk_var_02[STACK[CS]]:=AX
  end
  --CS
RETURN .T.

FUNCTION FUNPOPSR()   //107  GUARDA PARA REFERENCIA
LOCAL EAX,EBX,EEX
LOCAL XDIM,TYP,DIMR,DIMC,DIMP,DIMB
LOCAL OP_CODE:=1070
  EAX:=STACK[CS]
  EBX:=STACK[CS-1]
  if VALTYPE(stk_var_02[EBX])=="A"  // es un array: copiar info:
     // busco info de array fuente existente: puede ser temporal
     if STK_CWMTOP>0
        EDX := STK_TEMP_DIR[STK_CWMTOP]
        if EDX!=EBX
           EDX := ASCAN(STK_ARRAY_DIR,EBX)
           XDIM := STK_ARRAY_DIM[EDX]
           TYP  := STK_ARRAY_TYP[EDX]
           DIMR := STK_ARRAY_ROW[EDX]
           DIMC := STK_ARRAY_COL[EDX]
           DIMP := STK_ARRAY_PAG[EDX]
           DIMB := STK_ARRAY_BLK[EDX]
        else   
          // error: no puede pasar una direccion temporal como referencia!!
           RETURN _FUNPUTERROR("PARAMS/TEMPORAL MATRIX PARAM WITH REFERENCE",OP_CODE,CP)
        end
     else  // es legal
        EDX := ASCAN(STK_ARRAY_DIR,EBX)
        XDIM := STK_ARRAY_DIM[EDX]
        TYP  := STK_ARRAY_TYP[EDX]
        DIMR := STK_ARRAY_ROW[EDX]
        DIMC := STK_ARRAY_COL[EDX]
        DIMP := STK_ARRAY_PAG[EDX]
        DIMB := STK_ARRAY_BLK[EDX]
     end
     stk_var_02[EAX]:=stk_var_02[EBX]
     // Busco array destino: ya existe en el stack de dirs arrays:
     EEX := ASCAN(STK_ARRAY_DIR,EAX)       
     // agrego valores del array fuente. procedimiento inverso al retorno!
     STK_ARRAY_DIM[EEX]:=XDIM
     STK_ARRAY_TYP[EEX]:=TYP
     STK_ARRAY_ROW[EEX]:=DIMR
     STK_ARRAY_COL[EEX]:=DIMC
     STK_ARRAY_PAG[EEX]:=DIMP
     STK_ARRAY_BLK[EEX]:=DIMB
     stackpush(_MATFUNCION,EAX)  // origen->destino
     stackpush(_MATRETORNO,EBX)
  else
     stk_var_02[EAX]:=stk_var_02[EBX]
  end
  AADD (Stack_RefRecept,EAX)       // guardo direccion receptora de UDF
  AADD (Stack_RefOrigin,EBX)     // guardo direccion original
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  CWM:=CMPCWM(EBX,CWM,TopCWM)
  CS-=2
RETURN .T.

FUNCTION FUNRPUSH()  // 179    limite para direcciones referentes
LOCAL EAX,AX
  EAX:=STACK[CS]
  AX:=stk_var_02[EAX]      // constante: nº de referencias
  CWM:=CMPCWM(EAX,CWM,TopCWM)
  --CS
  AADD (Stack_RefRecept,AX)  // guardo nº de referencias
  AADD (Stack_RefRecept,-1)  // punto de fin de lectura (o inicio)
  if AX>0
     ++FLAGREF         // hay al menos una referencia
  end
RETURN .T.



/****************************************************************
       OTROS PROCEDIMIENTOS
*****************************************************************/
/**************************************************
   CARGA DIMENSIONES DE LA DIRECCION INDICADA
   SI NECESITA oBTENER DIRECCIONES DE TEMPORAL
   INDICAR NEEDTMP=.T.; .F. DE LO CONTRARIO.
   DEVUELVE .T. SI LA MATRIZ ESTA INICIALIZADA
   O SI ES VALIDA CUANDO NO SE NECESITA TMP
***************************************************/ 
FUNCTION FUNGETDIMS(EAX,ERX,DIM,TYP,DIMR,DIMC,DIMP,DIMB,NEEDTMP)
LOCAL EEX
  EEX:=.T.
  if STK_CWMTOP>0
     ERX := STK_TEMP_DIR[STK_CWMTOP]
     if ERX!=EAX
        ERX := ASCAN(STK_ARRAY_DIR,EAX)
        DIM :=STK_ARRAY_DIM[ERX]
        TYP :=STK_ARRAY_TYP[ERX]
        DIMR:=STK_ARRAY_ROW[ERX]
        DIMC:=STK_ARRAY_COL[ERX]
        DIMP:=STK_ARRAY_PAG[ERX]
        DIMB:=STK_ARRAY_BLK[ERX]
     else
        if NEEDTMP   
           DIM :=STK_TEMP_DIM[STK_CWMTOP]
           TYP :=STK_TEMP_TYP[STK_CWMTOP]
           DIMR:=STK_TEMP_ROW[STK_CWMTOP]
           DIMC:=STK_TEMP_COL[STK_CWMTOP]
           DIMP:=STK_TEMP_PAG[STK_CWMTOP]
           DIMB:=STK_TEMP_BLK[STK_CWMTOP]
           STK_TEMP_DIR[STK_CWMTOP]:=0
           STK_CWMTOP--
        else
           EEX:=.F.
        end
     end
  else  // es legal
     ERX := ASCAN(STK_ARRAY_DIR,EAX)
     DIM :=STK_ARRAY_DIM[ERX]
     TYP :=STK_ARRAY_TYP[ERX]
     DIMR:=STK_ARRAY_ROW[ERX]
     DIMC:=STK_ARRAY_COL[ERX]
     DIMP:=STK_ARRAY_PAG[ERX]
     DIMB:=STK_ARRAY_BLK[ERX]
  end
  IF DIM==0
     EEX:=.F.
  END
RETURN EEX  // .F. SI NO ESTÁ INICIALIZADA o no es matriz valida, .T. SI LO ESTA

/********************************************
  PONE LAS DIMENSIONES EN EL STACK DE ARRAYS
  TEMPORALES PARA SU PROCESO POSTERIOR
*********************************************/ 
PROCEDURE FUNPUTDIMS(CWM,DIM,TYP,DIMR,DIMC,DIMP,DIMB)
  STK_CWMTOP++
  STK_TEMP_DIR[STK_CWMTOP]:=CWM
  STK_TEMP_DIM[STK_CWMTOP]:=DIM
  STK_TEMP_TYP[STK_CWMTOP]:=TYP
  STK_TEMP_ROW[STK_CWMTOP]:=DIMR
  STK_TEMP_COL[STK_CWMTOP]:=DIMC
  STK_TEMP_PAG[STK_CWMTOP]:=DIMP
  STK_TEMP_BLK[STK_CWMTOP]:=DIMB
RETURN

/*
 * Conversion Funtions
 *
 * Copyright 1999 Luiz Rafael Culik <Culik@sl.conex.net>
 */

FUNCTION DecToBin( nNumber )

   LOCAL cNewString := ""
   LOCAL nTemp

   DO WHILE nNumber > 0
      nTemp := nNumber % 2
      cNewString := SubStr( "01", nTemp + 1, 1 ) + cNewString
      nNumber := Int( ( nNumber - nTemp ) / 2 )
   ENDDO

   RETURN cNewString

FUNCTION DecToOctal( nNumber )

   LOCAL cNewString := ""
   LOCAL nTemp

   DO WHILE nNumber > 0
      nTemp := nNumber % 8
      cNewString := SubStr( "01234567", nTemp + 1, 1 ) + cNewString
      nNumber := Int( ( nNumber - nTemp ) / 8 )
   ENDDO

   RETURN cNewString

FUNCTION DecToHexa( nNumber )

   LOCAL cNewString := ""
   LOCAL nTemp

   DO WHILE nNumber > 0
      nTemp := nNumber % 16
      cNewString := SubStr( "0123456789ABCDEF", nTemp + 1, 1 ) + cNewString
      nNumber := Int( ( nNumber - nTemp ) / 16 )
   ENDDO

   RETURN cNewString

FUNCTION BinToDec( cString )

   LOCAL nNumber := 0, nX
   LOCAL cNewString := AllTrim( cString )
   LOCAL nLen := Len( cNewString )

   FOR nX := 1 TO nLen
      nNumber += ( At( SubStr( cNewString, nX, 1 ), "01" ) - 1 ) * ( 2 ^ ( nLen - nX ) )
   NEXT

   RETURN nNumber

FUNCTION OctalToDec( cString )

   LOCAL nNumber := 0, nX
   LOCAL cNewString := AllTrim( cString )
   LOCAL nLen := Len( cNewString )

   FOR nX := 1 TO nLen
      nNumber += ( At( SubStr( cNewString, nX, 1 ), "01234567" ) - 1 ) * ( 8 ^ ( nLen - nX ) )
   NEXT

   RETURN nNumber

FUNCTION HexaToDec( cString )

   LOCAL nNumber := 0, nX
   LOCAL cNewString := AllTrim( cString )
   LOCAL nLen := Len( cNewString )

   FOR nX := 1 TO nLen
      nNumber += ( At( SubStr( cNewString, nX, 1 ), "0123456789ABCDEF" ) - 1 ) * ( 16 ^ ( nLen - nX ) )
   NEXT

   RETURN nNumber
 

/*
 * Author....: David Husnian
 * CIS ID....: ?
 *
 * This is an original work by David Husnian and is placed in the
 * public domain.
 *
 * Modification history:
 * ---------------------
 *
 *    Rev 1.2   15 Aug 1991 23:02:48   GLENN
 * Forest Belt proofread/edited/cleaned up doc
 *
 *    Rev 1.1   14 Jun 1991 19:50:56   GLENN
 * Minor edit to file header
 *
 *    Rev 1.0   01 Apr 1991 01:00:36   GLENN
 * Nanforum Toolkit
 *
 */

#define CASE_AT( x, y, z )               z[ At( x, y ) + 1 ]
#define FORCE_BETWEEN( x, y, z )         ( y := Max( Min( y, z ), x ) )

FUNCTION ft_ASum( aArray) //, nStartIndex, nEndIndex )

   LOCAL nSumTotal := 0                 // Array Sum

//   __defaultNIL( @nStartIndex, 1 )
//   __defaultNIL( @nEndIndex, Len( aArray ) )

   // Make Sure Bounds are in Range
   //FORCE_BETWEEN( 1, nEndIndex,   Len( aArray ) )
   //FORCE_BETWEEN( 1, nStartIndex, nEndIndex )
   nStartIndex:=1
   nEndIndex:=Len( aArray )
   
   AEval( aArray, ;
      {| xElement | ;
      nSumTotal += ;
      CASE_AT( ValType( xElement ), "NC", ;
      { 0, xElement, ;
      iif( HB_ISSTRING( xElement ), Len( xElement ), 0 ) } ) }, ;
      nStartIndex, nEndIndex - nStartIndex + 1 )

RETURN nSumTotal

   
/*********************************************
        FUNCION DE MENSAJE DE ERROR
**********************************************/

/*
procedure DEBUG_ON(archivo_log)

set printer to &archivo_log   //debug.log
set printer on
set console off

return

procedure DEBUG_OFF()

set printer off
set console on

return */

Procedure _ErrorSys (bajada,CodError, linea)
  _LIN:=hb_UTF8tostr("LAPSUS:"+strzero(CodError,5)+" => "+bajada)
  outstd(_CR)
  outstd( replicate("*",len(_LIN)+2),_CR)
  outstd( _LIN,_CR)
  outstd( replicate("*",len(_LIN)+2),_CR)
  outstd( "Programa  = "+upper(_file),_CR)
  outstd( hb_UTF8tostr("Fecha de la Excepción = "+dtoc(date())+", "+time()),_CR)

// busca la línea donde está el error
 /* _busca:=PATH_DEBUG+_fileSeparator+substr(_file,1,at(".",_file))+"map"
  _fuente:=PATH_SOURCE+_fileSeparator+substr(_file,1,at(".",_file))+"xu"*/

  _busca:=PATH_DEBUG+_fileSeparator+_file+".map"
  if _sw_source
     _fuente:=PATH_SOURCE+_fileSeparator+_file+".xu"
  else
     _fuente:=_file+".xu"
  end
  outstd( _CR,"Lugar del error en [",_fuente,"]:",_CR)

  _numbusca:=strzero(linea,5)
  if file(_busca)
    _v:=Memoread(_busca)
    _nl:=mlcount(_v)
    for _i:=1 to _nl
      _linea:=alltrim(Memoline(_v,1600,_i))
      _num:=substr(_linea,11,5)
   
      if _num==_numbusca
         _numbusca:=substr(_linea,2,5)
         _vnum:=val(_numbusca)
         // cargo programa fuente, si existe
         if file(_fuente) 
            _v:=Memoread(_fuente)
            outstd( " ",_CR)
            outstd("          :",_CR)
            for _j:=_vnum-3 to _vnum+3
               _linea:=alltrim(Memoline(_v,1600,_j))
               if _j==_vnum
                  outstd(hb_UTF8tostr(_numbusca+" >>>"+_linea),_CR) 
               else
                  outstd(hb_UTF8tostr("         "+_linea),_CR) 
               end
            end
            outstd("          :",_CR)
            break
         end
      end
    end
  else
    outstd("Archivo MAP no disponible: cagaste!",_CR,"Para la otra, compila con el switch '-m'")
  end
  RELEASE ALL
  CLEAR MEMORY
  QUIT
return

Procedure _Error(bajada)
  ? bajada
  ?;?
  QUIT
return 

/*  CONJUNTOS by Daniel Stuardo*/
/*
FUNCTION SETDIFFS(A,B,LA,LB)  // ESTÁ EN A, O EN B, PERO NO EN AMBAS
LOCAL U,I
  U:=SETUNION(A,B,LA,LB,IIF(VALTYPE(A[1])=="N",1,0))
  I:=SETINTERSECTION(A,B,LA,LB,IIF(VALTYPE(A[1])=="N",1,0))
RETURN SETDIFF(U,I,LEN(U),LEN(I))

FUNCTION SETDIFF(A,B,LA,LB)  // ESTA EN A, PERO NO EN B
LOCAL C:={},I,J,SW,T,LT
  T:=SETINTERSECTION(A,B,LA,LB,IIF(VALTYPE(A[1])=="N",1,0))
  LT:=LEN(T)
  FOR I:=1 TO LA
     SW:=.T.
     FOR J:=1 TO LT
        IF A[I]==T[J]
           SW:=.F.; EXIT
        END
     END
     IF SW
        AADD(C,A[I])
     END
  END
  C:=ASORT(C)
RETURN C 
*/

/*FUNCTION SETINTERSECTION(A,B,LA,LB)
//LOCAL C:={},I,J
LOCAL C,I,J,K:=0
  C:=ARRAY(IIF(LA>LB,LA,LB))
  FOR I:=1 TO LA
     FOR J:=1 TO LB
        IF A[I]==B[J]
           //AADD(C,A[I])
           C[++K]:=A[I]
           EXIT
        END
     END
  END
  ASIZE(C,K)
  C:=ASORT(C)
RETURN C

FUNCTION SETUNION(A,B,LA,LB)
LOCAL C,SW,I,J
  C:=ARRAY(LA)
  FOR I:=1 TO LA
     C[I]:=A[I]
  END
  
  FOR I:=1 TO LB
     SW:=.T.
     FOR J:=1 TO LA
        IF B[I]==C[J]
           SW:=.F.
           EXIT
        END
     END
     IF SW
        AADD(C,B[I])
     END
  END
  C:=ASORT(C)
RETURN C

function UNIQUE(A,LA)
local C,I,D:=0,P:=2,AX
AX:=ARRAY(LA)
FOR I:=1 TO LA
   AX[I]:=A[I]
END
AX:=ASORT(AX)
C:=ARRAY(LA)
C[1]:=AX[1]
for I:=2 to LA
  if AX[I]!=AX[I-1]
     C[P++]:=AX[I]
  else
     ++D
  end
end
ASIZE(C,LA-D)
return C
*/
/***************/

FUNCTION MILLISEC( nDelay )
   HB_IDLESLEEP( nDelay / 1000 )
   RETURN ""
 

*  **************************************************************************
*
function SDC( _lista )
local _last_valor,_nLongi
   _Last_valor:=0

      _nLongi := len( _lista )
      // Chequea si existen elementos
      if _nLongi == 0
         return ( nil )
      end
      // obtiene el ultimo valor
      _Last_valor := _lista[ 1 ]
      // Remueve el ultimo elemento del stack
      _lista[ 1 ]:=0
      Adel ( _lista, 1 )
      Asize( _lista, _nLongi - 1 )

   // Retorna el elemento extraido
return  _Last_valor 

//***********************************************************************
/*function FIX(_arg)
local _FixAnt:=_GET_FIX
  if _arg <= 0 .or. _arg > 16
     set decimals to
     set fixed off
  elseif _arg==0
     set decimals to
     set fixed off
  else
     _GET_FIX := _arg
     set fixed on 
     Set decimals to _arg
  end

return _FixAnt
*/

/*********************************************************************
    _definesegmentos
**********************************************************************/
procedure _DefineSegmentos()

   stk_prg:=stacknew()    // segmento de programa
  // stk_var_01:=stacknew()    // segmento de datos
   stk_var_02:=stacknew()    // segmento de datos

return nil


Procedure _SettingVar()

PUBLIC stk_local     := stacknew()
PUBLIC stk_var_local := stacknew()
PUBLIC stk_dim_local := stacknew()
PUBLIC stk_try       := stacknew()

PUBLIC FEVAL     := .F.
PUBLIC OKFLAG    := .F.                 // retorno de status para UDF
PUBLIC DFLAG     := 1            // flag delta de funcion difusa de verdad: asume verdad=1
PUBLIC FLAG      := {"",""}   //flag estandar

PUBLIC SFLAG     := {"",""}   //flag para stacks
PUBLIC _MATRETORNO:=stacknew()   // direcciones de matrices para retornar desde funcion!
PUBLIC _MATFUNCION:=stacknew()

PUBLIC CS        := 0 
PUBLIC CP        := 0 
PUBLIC OP_CODE   := 0   

PUBLIC PFLAG     := 0                  // flag para modo pila=0 y cola=1

PUBLIC FLOCV     := 0  // puntero a lista unidimensional
//PUBLIC SWFLOCV   := 0  // sw que indica si se ha iniciado este flag
PUBLIC FLOCW     := 0  // puntero a lista bidimensional
PUBLIC FLOCX     := 0  // puntero a lista tridimensional
PUBLIC FLOCY     := 0  // puntero a lista cuatridimensional

PUBLIC FLAGREF   := 0    // indica si direcciones son referenciadas en argumentos

PUBLIC Stack_refRecept := stacknew()  // asi puedo popearlas ambas!!!
PUBLIC Stack_refOrigin := stacknew()
PUBLIC _StackPops    := stacknew()

//PUBLIC NEDFLAG   := {0,0,0,0}  // se activa si solo se ha inicializado un puntero a lista anterior

PUBLIC FHNDLOUT  := 0  // handler de salida simple

PUBLIC SW_FHNDLOUT:= 0  // sw de handler de salida simple
PUBLIC SW_CONSOLE := 0  // salida por pantalla o no

PUBLIC VEXCEPTION:= 0 // codigo de exception. sera evaluado constantemente.
PUBLIC SW_TRY    := .F.                // indica si esta activo el manejador de Excepciónes
//PUBLIC SW_TRY_ON := 0                // se activo una exception


public BREAKCS:=STACKNEW()
PUBLIC BREAKCWM:=STACKNEW()

PUBLIC STK_ARRAY_DIR:={}
PUBLIC STK_ARRAY_DIM:={}
PUBLIC STK_ARRAY_ROW:={}
PUBLIC STK_ARRAY_COL:={}
PUBLIC STK_ARRAY_PAG:={}
PUBLIC STK_ARRAY_BLK:={}
PUBLIC STK_ARRAY_TYP:={}
PUBLIC SFLAGDIR:=0 
PUBLIC SFLAGDIM:=0
PUBLIC SFLAGSTK:=0
PUBLIC SFLAGROW:=0
PUBLIC SFLAGCOL:=0
PUBLIC SFLAGPAG:=0
PUBLIC SFLAGBLK:=0
PUBLIC SFLAGTYP:=""
// stacks para arrays temporales
PUBLIC STK_TEMP_DIR:={}
PUBLIC STK_TEMP_DIM:={}
PUBLIC STK_TEMP_ROW:={}
PUBLIC STK_TEMP_COL:={}
PUBLIC STK_TEMP_PAG:={}
PUBLIC STK_TEMP_BLK:={}
PUBLIC STK_TEMP_TYP:={}


PUBLIC GET_COLOR:=""

PUBLIC _XU_SEMANA:={"Domingo","Lunes","Martes","Miercoles","Jueves","Viernes","Sabado"}
PUBLIC _XU_ANO:={"Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio",;
          "Agosto","Septiembre","Octubre","Noviembre","Diciembre"} 

PUBLIC FVWITH := ""
PUBLIC FTWITH := ""

PUBLIC _APPLICATION:=" "
PUBLIC _LEVEL:=" "
PUBLIC _OUTPUT:=" "
PUBLIC _DEPENDENCE:=" "

// para ejecucion: toda direccion debera ser offseteada a 254 bytes
PUBLIC DIR:=254

return  

// Procedimeinto que carga el archivo en el stack de programa, junto a
// las direcciones de memoria

Procedure _CargaArchivo(_file)

local h,t,n,_cola,_tmpfile,SW_STACK:=.F.

if _sw_source
   h:=fopen(PATH_BINARY+_fileSeparator+_file,"r")
else
   h:=fopen(_file,"r")
end
t:=space(3)
n:=0

// tamaño del archivo:
h_fin:=fseek(h,0,2)
h_ini:=fseek(h,0,0)


// identificador de programa valido XU
fread(h,@t,3)
if t!="FBI"   // Ferny, Benja y mamita Irma
   _Error("ES EL COLMO! No es un programa Valido",)
end

// identificador de cola anexada
fread(h,@_APPLICATION,1)    // si la app es normal o tiene hilos
fread(h,@_LEVEL,1)      // 0=normal, 1=recursivo
fread(h,@_OUTPUT,1)     // salida: archivo terminal=2  o emulate=1 default
fread(h,@_DEPENDENCE,1)     // Dependencia. 9=yes, 8=no

// lee el nombre del metodo
t:=" "
_METODO:=""
while (!hb_feof(h) .and. t!=chr(255))
   fread(h,@t,1)
   _METODO:=_METODO+iif(t!=chr(255),t,"")
end

// crea el archivo temporal para llamadas a sistema
fecha:=strtran(dtoc(date()),"-","")
hora:=strtran(time(),":","")

_tmpfile:=_METODO+"_"+fecha+"_"+hora+".tmp"
// --------------------------------------------------


//Lee la cantidad de objetos de memoria existen en el archivo
fread(h,@t,1)    // lee el codigo de total de objetos del memoria

if t==chr(2)   // hay mas de 255 objetos de memoria
   _stktmp:=array(2)
   _i:=1
   t:=" "
   while _i<3   // leera hasta el siguiente 2
      fread(h,@t,1)  
      _stktmp[_i]:=bin2i(t)
      ++_i
   end

   // recalcula direccion real
   _vtotmem:=255*_stktmp[2]+_stktmp[1]
else
   fread(h,@t,1)  // leo el numero de objetos menor a 255
   _vtotmem:=bin2i(t)
end


// lee el segmento de datos:
_sw_segmento:=0
_mem:=" "
_ndxParam:=0

// reservo espacio para calculos: direccion 00001

while _sw_segmento<2
   fread(h,@_mem,1)
   
   // lectura de direccion de pertenencia del objeto
   if _mem==chr(5)       // direccion de pertenencia
      _stktmp:=array(2)
      _i:=1
      _mem:=" "
      
      while _i<3        // siempre leera para calcular offset
         fread(h,@_mem,1)
         _stktmp[_i]:=bin2i(_mem)
         ++_i
      end
      fread(h,@_mem,1)   // agregado recientemente
      if _mem!=chr(5)     // el siguiente es un #5
         outstd("ERROR: No es un programa valido TXU.",_CR)
         Quit
      end

      _stktmp:=array(2)
      _i:=1
      _mem:=" "
      
      while _i<3        // siempre leera para calcular offset
         fread(h,@_mem,1)
         _stktmp[_i]:=bin2i(_mem)
         ++_i
      end

      // actualiza stk_var:
    //  stk_var_01[len(stk_var_01)]:=1

      // relee para siguiente objeto a cargar
      fread(h,@_mem,1)
   end
   //

   if _mem==chr(255)
      _sw_segmento++
   elseif _mem==chr(3) .or. _mem==chr(4)    // es variable
      _fmem:=_mem
      _sw_segmento:=0

      _sw_parametro:=.F.
      if _mem==chr(3)
         _param:=" "
         
         _pospar:=0
         fread(h,@_param,1)
         if _param==chr(1)       // es un parametro
            
            fread(h,@_param,1)    // posicion dl parametro 1..2..3...
            if len(_arr_par)>0
               _pospar:=bin2i(_param)
               ///? "ES PARAM = ",_param," CHR=",asc(_param)," POSPAR=",_pospar
               _sw_parametro:=.T.
               //if _pospar>len(_arr_par)    // no hay parametro
               if _ndxParam>len(_arr_par)    // no hay parametro
                  _sw_parametro:=.F.
               end
            end

         end          
      end

      _mem:=" "
      fread(h,@_mem,1)

      _tipo_var:="X"
      _CNT_STACKPARAM:=0
      _CNT_STACKDIM:=0
      if _mem==chr(15)
        _tipo_var:="N"
        //_Valor := iif(_sw_parametro,iif(ISTNUMBER(_arr_par[_pospar])==1,val(_arr_par[_pospar]),0),0)
        ++_ndxParam
        if _ndxParam<=len(_arr_par)
           _Valor := iif(_sw_parametro,iif(ISTNUMBER(_arr_par[_ndxParam])==1,val(_arr_par[_ndxParam]),0),0)
        else
           _Valor := 0
        end

      elseif _mem==chr(26)     // tipo FILE 
        _tipo_var:="N"  //"F"
        _Valor := 0   

      elseif _mem==chr(16)
        _tipo_var:="C"
        ////////_Valor := iif(_sw_parametro,hb_valtostr(_arr_par[_pospar]),"")
        //_Valor := iif(_sw_parametro,_arr_par[_pospar],"")
        ++_ndxParam
        if _ndxParam<=len(_arr_par)
           _Valor := iif(_sw_parametro,_arr_par[_ndxParam],"")
        else
           _Valor := ""
        end
        
/*      elseif _mem==chr(17)    // variable de thread
        _tipo_var:="T"
        _Valor := 0 */

      elseif _mem==chr(18)
        _tipo_var:="L"
        //_Valor := iif(_sw_parametro,iif(upper(_arr_par[_pospar])=="1",.T.,.F.),.F.)
        ++_ndxParam
        if _ndxParam<=len(_arr_par)
           _Valor := iif(_sw_parametro,iif(upper(_arr_par[_ndxParam])=="1",.T.,.F.),.F.)
        else
           _Valor := .F.
        end
        
      elseif _mem==chr(21)   // stack de numeros
        _tipo_var:="N"  //"AN"  //N"
        SW_STACK:=.T.
        
        if _sw_parametro
           _Valor:={}
           
           _CNT_STACKDIM:=1
           ++_ndxParam
           for i:=_ndxParam to len(_arr_par)
              if ISTNUMBER(_arr_par[i])==1
                 aadd(_Valor,val(_arr_par[i]))
                 ++_CNT_STACKPARAM
              else
                 --i
                 exit
              end
           end
           _ndxParam:=i  // ya superó el limite de parametros.
        else
           _Valor:={}
        end

      elseif _mem==chr(22)   // stack de cadenas
        _tipo_var:="C"  //"AC"  //C"
        SW_STACK:=.T.
        if _sw_parametro
           _Valor:={}
           
           _CNT_STACKDIM:=1
           ++_ndxParam
           for i:=_ndxParam to len(_arr_par)
              aadd(_Valor,_arr_par[i])
            //  ? "llena -->",_arr_par[i]," = ",_Valor[len(_Valor)]
              ++_CNT_STACKPARAM
           end
           _ndxParam:=i  // ya superó el limite de parametros.
        else
           _Valor:={}
        end

      elseif _mem==chr(23)     // stack de bools
        _tipo_var:="L" //"AL"  //"AL"
        SW_STACK:=.T.
        if _sw_parametro
           _Valor:={}
           
           _CNT_STACKDIM:=1
           ++_ndxParam
           for i:=_ndxParam to len(_arr_par)
              if _arr_par[i]=="1"
                 aadd(_Valor,.T.)
                 ++_CNT_STACKPARAM
              elseif _arr_par[i]=="0"
                 aadd(_Valor,.F.)
                 ++_CNT_STACKPARAM
              else
                 --i
                 exit
              end
           end
           _ndxParam:=i  // ya superó el limite de parametros.
        else
           _Valor:={}
        end

      elseif _mem==chr(24)     // stack de archivos
        _tipo_var:="N"  //"AF"   //"AF"
        SW_STACK:=.T.
        _Valor:={} //stacknew()
      end

      if _tipo_var=="X"
          _Error ("MORTAL: Problemas al leer el segmento de datos")
      end

      if _fmem==chr(4)    // leer el valor de la constante
         _mem:=" "
         _valor:=""
         while _mem!=chr(255)
            fread(h,@_mem,1)
            if _mem!=chr(255) .and. _mem!=chr(34)   // 34=comilla
               _valor:=_valor+chr(bin2i(_mem))
            end
         end

         // encontre un 255
         _sw_segmento++
         if _Tipo_var=="N"
            _valor:=val(_valor)
         elseif _Tipo_var=="C"
            if "\'" $ _valor
               _valor:=strtran(_valor,"\'",'"')
            end
         end
      end

      // chequeo direccion de variable si se trata de un stack.
      // guardo en stack de arreglos:
      if  SW_STACK  //_valor==nil   // es stack
          //_valor:=array(0)
          if len(_Valor)==0
             _Valor:=array(0)
          end
          
          aadd(stk_var_02,{})
          _newdir := len(stk_var_02)    // ultima dir conocida de arreglo
          stk_var_02[_newdir]:=aclone(_Valor)
          
          stackpush(STK_ARRAY_DIR,_newdir)    // direccion del stack
          stackpush(STK_ARRAY_TYP,_tipo_var)   //substr(_tipo_var,2,1))  // tipo del arreglo
          stackpush(STK_ARRAY_DIM,_CNT_STACKDIM)      // dimension
          stackpush(STK_ARRAY_ROW,_CNT_STACKPARAM)      // dim fila
          stackpush(STK_ARRAY_COL,0)      // dim columna
          stackpush(STK_ARRAY_PAG,0)      // dim pagina
          stackpush(STK_ARRAY_BLK,0)      // dim bloque
          SW_STACK:=.F.  // resetea stack.
      end    
      
      //stackpush(stk_var_01,0)    //_tipo_var)  // stack de variables y constantes
      if valtype(_Valor)=="C"
         stackpush(stk_var_02,hb_UTF8tostr(_Valor))
      elseif valtype(_Valor)!="A"
         stackpush(stk_var_02,_Valor)     // del programa
      end

//      stackpush(stk_vudf,{len(stk_var_01),0,0,_tipo_var})   // guardo datos de variable
                                                            // 0=valor temporal  
   end
end

   /** crea stack de arrays temporales que se accederan como una pila **/
   STK_TEMP_DIR={0,0,0,0,0,0}
   STK_TEMP_TYP={"","","","","",""}
   STK_TEMP_DIM={0,0,0,0,0,0}
   STK_TEMP_ROW={0,0,0,0,0,0}
   STK_TEMP_COL={0,0,0,0,0,0}
   STK_TEMP_PAG={0,0,0,0,0,0}
   STK_TEMP_BLK={0,0,0,0,0,0}
   /****/

// define segmento de trabajo.

CWM_INICIAL:=len(stk_var_02)+1

//////////CWM:=len(stk_var)+1     // memoria de calculos en T de Ejecucion. Es unica
                        // para todos los posibles ejecuciones paralelos

// segun _LEVEL, determino el tope de memoria asignada a cada proceso:
if ASC(_LEVEL)==22     // memoria normal: 16 bytes extras
  EMEM:=BSTACK_NORMAL
else             // tiene recursividad: 80 bytes extras (puede ser diferente)
  EMEM:=BSTACK_RECURSIVE
end

RELEASE BSTACK_NORMAL,BSTACK_RECURSIVE

// anadir mas espacio para los calculos en memoria.
for i:=1 to EMEM    //  casillas de memoria extra
 // stackpush(stk_var_01,0)
  stackpush(stk_var_02,"")
next

// lectura del segmento de programa
t:=" "
_vmem:=0

_Cnt:=255

h_act:=fseek(h,0,1)

while h_act<h_fin  //!hb_feof(h) 
   fread(h,@t,1)   ; ++_Cnt
   _vmem:=bin2i(t)
    if _vmem==0
         _stktmp:=array(2)
         _i:=1
         t:=" "

         while t!=chr(0) .or. _i<3   // leera hasta el siguiente 239   
            fread(h,@t,1) // ; ++_Cnt
            if t!=chr(0) .or. _i<3
               _stktmp[_i]:=iif(t==chr(1),1,bin2i(t))
            end
            ++_i
         end

         // recalcula direccion real
         _vmem:=255*_stktmp[2]+_stktmp[1]
   end
   stackpush(stk_prg,_vmem)
   h_act:=fseek(h,0,1)

end
// cerrando archivo binario
fclose(h)


//if _OUTPUT==chr(2)
  /* _archivo_log:=PATH_LOG+_fileSeparator+upper(_file)+".LOG."+fecha+"_"+hora
  
   debug_on(_archivo_log)
   ? "*********************** RUN PROGRAM: "+_METODO
   ? "*********************** DATE SYSTEM: "+fecha+", "+hora;?
   ? "*********************** RUNNING ON: "+OS();?
  */
//end

// Ojo con esto: si cargará varios progrsmas, debo resetear esto.

CWM       := CWM_INICIAL
TopCWM    := CWM               // puntero al inicio del espacio de trabajo
TopApp    := CWM  // espacio asignado a NULL  EMEM         // indica el espacio maximo ocupado por aplicacion
//
STACK     := array(EMEM)       // Bytes asignados segun tipo de aplicacion

Return 

procedure _Carga_Configuracion()
local _f,_v,_w,_nl,_i,_linea,_p
local PATH_XU,OSHost

///Public PATH_ROOT
public PATH_BINARY
public PATH_UTILITY
public PATH_SOURCE
public PATH_OUTPUT
public PATH_LOG
public PATH_DEBUG
public SW_CLEAR_LOG:=.F.   // por defecto no borra los logs de las llamadas a shell

PATH_XU:=CURDIR()
OSHost:=OS()
OSHost:=upper(alltrim(substr(OSHost,1,at(" ",OSHost))))
if OSHost=="LINUX" .or. OSHost=="DARWIN"
  _fileSeparator:="/"
  PATH_XU:="/"+PATH_XU
elseif OSHost=="WINDOWS"
  _fileSeparator:="\"
end

if !file(PATH_XU+_fileSeparator+"xu")
   PATH_XU:=GETENV("PATH_XU")
   if alltrim(PATH_XU)==""
      outstd(_CR,hb_UTF8tostr("Atención: debe declarar la variable de entorno PATH_XU"))
      outstd(_CR,hb_UTF8tostr("          si quiere ejecutar desde cualquier parte del"))
      outstd(_CR,hb_UTF8tostr("          sistema."))
      outstd(_CR,hb_UTF8tostr("          Si está en Linux u OSX, hágalo así:"),_CR)
      outstd(_CR,hb_UTF8tostr("                export PATH_XU=ruta-de-XU"),_CR)
      outstd(_CR,hb_UTF8tostr("          Si está en Win8=Dows, hágalo así:"),_CR)
      outstd(_CR,hb_UTF8tostr("                set PATH_XU=ruta-de-XU"),_CR)
      outstd(_CR,hb_UTF8tostr("     donde:"),_CR)
      outstd(_CR,hb_UTF8tostr("        ruta-de-XU = la ruta donde está guardada XU."),_CR)
      release all
      quit
   end
end

if !FILE(PATH_XU+_fileSeparator+"xu.config")
   outstd(_CR,hb_UTF8tostr("Atención: no encuentro el archivo XU.CONFIG."),_CR)
   release all
   quit
else
   _v:=Memoread(PATH_XU+_fileSeparator+"xu.config")
   _nl:= MlCount(_v)
   for _i:=1 to _nl
      _linea:=alltrim(Memoline(_v,1600,_i))
      if substr(_linea,1,1)!=";"
         if !empty(_linea)
            _w:=upper(alltrim(substr(_linea,1,at("=",_linea)-1)))
            _p:=alltrim(substr(_linea,at("=",_linea)+1,len(_linea)))

            do case
              /* case _w=="ROOT"
                  PATH_ROOT:=_p */
               case _w=="BINARY"
                  PATH_BINARY:=PATH_XU+_fileSeparator+_p
               case _w=="UTILITY"
                  PATH_UTILITY:=PATH_XU+_fileSeparator+_p
               case _w=="SOURCE"
                  PATH_SOURCE:=PATH_XU+_fileSeparator+_p
               case _w=="OUTPUT"
                  PATH_OUTPUT:=PATH_XU+_fileSeparator+_p
               case _w=="LOG"
                  PATH_LOG:=PATH_XU+_fileSeparator+_p
               case _w=="DEBUG"
                  PATH_DEBUG:=PATH_XU+_fileSeparator+_p
               case _w=="CLEAR_LOG"
                  if upper(_p)="YES"
                     SW_CLEAR_LOG:=.T.
                  end
               case _w=="DECIMAL_FIX"
                  _GET_FIX:=val(_p)
               case _w=="BSTACK_NORMAL"
                  BSTACK_NORMAL:=val(_p)
               case _w=="BSTACK_RECURSIVE"
                  BSTACK_RECURSIVE:=val(_p)
               case _w=="FILE_SEPARATOR"   
                  _fileSeparator:=_p
            end
         end
      end
   next
end

return nil

procedure _header()
    outstd("XU v1.0.2010-2018 --- XU VM ",_CR)
    outstd(hb_UTF8tostr("Diseño y programación (vintash) Daniel Stuardo (Dr.DaLiEn). Full Spanglish!!"),_CR)
    outstd(hb_UTF8tostr("Verano de 2010 - 27F - Laura no está :( - ¡Copitos! :O - Invierno de 2018."),_CR)
return

procedure _modo_de_uso()
    outstd("  Modo de Uso:",_CR,_CR)
    outstd(hb_UTF8tostr("  XU [-s] <archivo> [parámetros]"),_CR)
    outstd("--------------------------------------------------------------------------------------",_CR)
    outstd("  donde:",_CR)
    outstd(hb_UTF8tostr("     <archivo>        Es el archivo a ejecutar, sin extensión."),_CR)
    outstd(hb_UTF8tostr("     [parametros]     Parámetros, si se requieren."),_CR)
    outstd(hb_UTF8tostr("     -s               Ejecuta binario desde el directorio BINARY. Uselo si"),_CR)
    outstd(hb_UTF8tostr("                      si compiló el programa usando el mismo parámetro."),_CR+_CR)
    outstd("  Bugs, dudas y aportes: daniel.stuardo@gmail.com",_CR,_CR)
return

#include "common.ch"
#include "error.ch"

/*  $DOC$
 *  $FUNCNAME$
 *      ERRORSYS()
 *  $CATEGORY$
 *      Error recovery
 *  $ONELINER$
 *      Install default error handler
 *  $SYNTAX$
 *      ERRORSYS() --> NIL
 *  $ARGUMENTS$
 *      none.
 *  $RETURNS$
 *      ERRORSYS() always return NIL.
 *  $DESCRIPTION$
 *      ERRORSYS() is called upon startup by Harbour and install the default
 *      error handler. Normally you should not call this function directly,
 *      instead use ERRORBLOCK() to install your own error handler.
 *  $EXAMPLES$
 *  $TESTS$
 *  $STATUS$
 *      R
 *  $COMPLIANCE$
 *      ERRORSYS() works exactly like CA-Clipper's ERRORSYS().
 *  $SEEALSO$
 *      ERRORBLOCK(),Error class
 *  $END$
 */

PROCEDURE ErrorSys

   ErrorBlock( { | oError | DefError( oError ) } )

   RETURN

STATIC FUNCTION DefError( oError )
   LOCAL cMessage
   LOCAL cDOSError

   LOCAL aOptions
   LOCAL nChoice

   LOCAL n

   // By default, division by zero results in zero
   IF oError:genCode == EG_ZERODIV
      RETURN 0
   ENDIF

   // Set NetErr() of there was a database open error
   IF oError:genCode == EG_OPEN .AND. ;
      oError:osCode == 32 .AND. ;
      oError:canDefault
      NetErr( .T. )
      RETURN .F.
   ENDIF

   // Set NetErr() if there was a lock error on dbAppend()
   IF oError:genCode == EG_APPENDLOCK .AND. ;
      oError:canDefault
      NetErr( .T. )
      RETURN .F.
   ENDIF

   cMessage := ErrorMessage( oError )
   IF ! Empty( oError:osCode )
      cDOSError := "(DOS Error " + LTrim( Str( oError:osCode ) ) + ")"
   ENDIF

   IF ! Empty( oError:osCode )
      cMessage += " " + cDOSError
   ENDIF
   setcolor ("15/4")
   QOut( "UNDER-XU SYSTEM MESSAGE: "+cMessage )
   setcolor ("")
   n := 2
   WHILE ! Empty( ProcName( n ) )
      QOut("Called from " + ProcName( n ) + ;
               "(" + AllTrim( Str( ProcLine( n++ ) ) ) + ")")
   ENDDO
   _ErrorSys ("UNKNOWLEDGE GARRAFAL ERROR Excepción que te mandó a la mierda!! 8=D",0, CP+254)
   QUIT

   RETURN .F.

// [vszel]

STATIC FUNCTION ErrorMessage( oError )
   LOCAL cMessage

   // start error message
   cMessage := iif( oError:severity > ES_WARNING, "Error", "Warning" ) + " "

   // add subsystem name if available
   IF ISCHARACTER( oError:subsystem )
      cMessage += oError:subsystem()
   ELSE
      cMessage += "???"
   ENDIF

   // add subsystem's error code if available
   IF ISNUMBER( oError:subCode )
      cMessage += "/" + LTrim( Str( oError:subCode ) )
   ELSE
      cMessage += "/???"
   ENDIF

   // add error description if available
   IF ISCHARACTER( oError:description )
      cMessage += "  " + oError:description
   ENDIF

   // add either filename or operation
   DO CASE
   CASE !Empty( oError:filename )
      cMessage += ": " + oError:filename
   CASE !Empty( oError:operation )
      cMessage += ": " + oError:operation
   ENDCASE

   RETURN cMessage


/** codigo C **/
#pragma BEGINDUMP
#include "hbapi.h"
#include "hbstack.h"
#include "hbapiitm.h"
#include "hbapierr.h"
#include "hbapigt.h"
#include "hbset.h"
#include "hbdate.h"

//  #define _MAC64_
//  #define _LINUX32_
#define _LINUX64_


#ifdef _LINUX32_
  #include "ct.h"
  #include "ctmath.h"
#endif

#ifdef _MAC64_ 
  #include "ct.h"
  #include "ctmath.h"
#endif

#ifdef _LINUX64_ 
  #include "ct.h"
  #include "ctmath.h" 
/*  #include "../contrib/hbct/ct.h"
  #include "../contrib/hbct/ctmath.h" */
#endif

#include "hbmather.h"
#include "hbdate.h"
#include "hbset.h"
#include "hbmath.h"
#include <ctype.h>
#include <extend.h>
#include <math.h>
#include <stdint.h>
#include <inttypes.h>
#include <string.h>
#include <stdlib.h>
#include <unistd.h>

/*
#ifdef _MAC64_
   #include "/Users/danielstuardo/VirtualFold/Proyectos/XUESP/MACOSX-64b/definiciones.h"
#endif

#ifdef _LINUX64_
   #include "/home/xu/Harbour-3.0.0/LINUX-64bits/definiciones.h"
#endif

#ifdef _LINUX32_
   #include "/home/xu/Proyectos/xuesp/definiciones.h"
#endif
*/


int xu_funIsnotation(const char * AX){
  int DX;
  short int SW_E=0,SW_P=0,SW_S=0,retorne=1;

  DX=*AX;
  if (DX=='-') ++AX; 
  
  while( (DX=*AX)!='\0'){
    if(toupper(DX)=='E'){
       if (!SW_E) SW_E=1;
       else {retorne=0;break;}
    }else if (DX=='.'){
       if (!SW_P) SW_P=1;
       else {retorne=0;break;}
    }else if (DX=='+' || DX=='-') {
       if (!SW_S) SW_S=1;
       else {retorne=0;break;}
    }else if (!isdigit(DX)) {retorne=0;break;}
    ++AX;
  }
  if (!SW_E || !SW_P) retorne=0;
  return retorne;
}

HB_FUNC( ISNOTATION )  // esto debe ir!! llevar otros codigos semejante a "C"
{
  PHB_ITEM pText = hb_param(1,HB_IT_STRING);
 
  const char *AX = hb_itemGetCPtr( pText );
 // int LX = hb_itemGetCLen( pText );

  int retorne = xu_funIsnotation( AX );
  hb_retnint(retorne);
}

double xu_funE2D( const char * linea ){
   
   const char *buf;
   char *sMant;
   double nMant;
   int nExp,mant=0,signo;
   buf=linea;
   while(*buf!='E') {
      mant++;
      ++buf;
   }
   nExp = atoi(++buf);
   sMant = (char *)calloc(mant+1,1);
   strncpy(sMant,linea,mant);
   sMant[mant]='\0';
   if (sMant[0]=='-') {
      signo=(-1); 
      sMant++;
   } else signo=1;
   nMant = atof(sMant);
   free ( sMant );
  /// printf("\n--> %f, %d, %d\n%f\n",nMant,nExp,signo, nMant * pow( (double)10, (double)nExp)*signo);
   return ((double) nMant * (double)pow( (double)10, (double)nExp)*(double)signo );
}

HB_FUNC ( E2D )
{
   const char *linea = hb_parc(1);
   double retorno = xu_funE2D( linea );
   hb_retnd ( retorno );
}

HB_FUNC( GETLINEAS )
{
   PHB_ITEM pSTRING = hb_param( 1, HB_IT_STRING );
   const char * Sep = hb_parc( 2 );   // caracter separador. uno solo.
   unsigned int nDim = hb_parni( 3 );
   long nTotal  = hb_parnl( 4 );   // filas
   long nCol    = hb_parnl( 5 );   // columnas 
   long nTotCar  = hb_parnl( 6 );  // total de caracteres en el string
   unsigned int Typ = hb_parni ( 7 );  // tipo de dato.
   const char * CONTEXT = hb_parc( 8 );  // contexto de verdad. string
   long nMax  = hb_parnl( 9 );

   PHB_ITEM pCWM = hb_itemArrayNew( nTotal ); // CWM
   int matOk=1;
   
   switch( nDim )
   {
      case 1:  // 1D
      {
         switch ( Typ )
         {
            case 0:   // string
            {
               const char * STRING = hb_itemGetCPtr( pSTRING );
               long i;
               long totalCar = 0;
               for(i=0;i<nTotal;i++){
                  char * cBuff = (char *)calloc(nMax+5,1);
                  long j=0;
                  while( totalCar <= nTotCar ) {
                     if ( *STRING == '\n' ) { ++STRING; ++totalCar; break; }
                     if ( *STRING !=  Sep[0] ){
                        cBuff[j++] = *STRING;
                        ++totalCar;
                        ++STRING;
                     }else{
                        ++totalCar;
                        ++STRING;  // nos saltamos '\n'
                        break;
                     }
                     if (j>nMax+1){
                        matOk=0;
                        free ( cBuff );
                        break;
                     }
                  }
                  if ( !matOk ) {
                     break;
                  }
                  cBuff[j]='\0';
                  const char * pBuffer = cBuff;
                  hb_arraySetC( pCWM, i+1, (const char *) pBuffer );
                  free ( cBuff );
                  if ( !matOk ) break;
               }
               break;
            }
            case 1:   // numero
            {
               const char * STRING = hb_itemGetCPtr( pSTRING );
               long i;
               long totalCar = 0;
               for(i=0;i<nTotal;i++){
                  char * cBuff = (char *)calloc(nMax+5,1);
                  long j=0;
                  while( totalCar <= nTotCar ) {
                     if ( *STRING == '\n' ) { ++STRING; ++totalCar; break; }
                     if ( *STRING !=  Sep[0] ){
                        cBuff[j++] = *STRING;
                        ++totalCar;
                        ++STRING;
                     }else{
                        ++totalCar;
                        ++STRING;  // nos saltamos '\n'
                        break;
                     }
                     if (j>nMax+1){
                        matOk=0;
                        free ( cBuff );
                        break;
                     }
                  }
                  if ( !matOk ) {
                     break;
                  }
                  cBuff[j]='\0';
                  const char * pBuffer = cBuff;
                  double nBuff=0;
                  if ( xu_funIsnotation( pBuffer ) == 1 ){
                     nBuff = xu_funE2D( pBuffer );
                  }else{
                     if ( strlen(pBuffer)<=64){
                        sscanf(pBuffer, "%lf", &nBuff);
                     }else{
                        matOk=0;
                        free ( cBuff );
                        break;
                     }
                  }
                  hb_arraySetND( pCWM, i+1, (double) nBuff );
                  free ( cBuff );
               }
               break;
            }
            case 2:   // logico
            {
               const char * STRING = hb_itemGetCPtr( pSTRING );
               long i;
               long totalCar = 0;
               for(i=0;i<nTotal;i++){
                  char * cBuff = (char *)calloc(nMax+5,1);
                  long j=0;
                  while( totalCar <= nTotCar ) {
                     if ( *STRING == '\n' ) { ++STRING; ++totalCar; break; }
                     if ( *STRING !=  Sep[0] ){
                        cBuff[j++] = *STRING;
                        ++totalCar;
                        ++STRING;
                     }else{
                        ++totalCar;
                        ++STRING;  // nos saltamos '\n'
                        break;
                     }
                     if (j>nMax+1){
                        matOk=0;
                        free ( cBuff );
                        break;
                     }
                  }
                  if ( !matOk ) {
                     break;
                  }
                  cBuff[j]='\0';
                  const char * pBuffer = cBuff;
                  if ( strcmp( pBuffer, CONTEXT ) == 0)
                     hb_arraySetL( pCWM, i+1,(HB_BOOL) HB_TRUE );
                  else
                     hb_arraySetL( pCWM, i+1,(HB_BOOL) HB_FALSE );

                  free ( cBuff );
               }
               break;
            }
            break;
         }
         break;
      }
      case 2:  // 2D
      {
         switch ( Typ )
         {
            case 0:   // string
            {
               const char * STRING = hb_itemGetCPtr( pSTRING );
               long i,k;
               long totalCar = 0;
               for(i=0;i<nTotal;i++){
                  PHB_ITEM pC = hb_itemArrayNew( nCol ); // CWM
                  for(k=0;k<nCol;k++){
                     char * cBuff = (char *)calloc(nMax+5,1);
                     long j=0;
                     while( totalCar <= nTotCar ) {
                        if ( *STRING == '\n' ) { ++STRING; ++totalCar; break; }
                        if ( *STRING !=  Sep[0] ){
                           cBuff[j++] = *STRING;
                           ++totalCar;
                           ++STRING;
                        }else{
                           ++totalCar;
                           ++STRING;  // nos saltamos ','
                           break;
                        }
                        if (j>nMax+1){
                           matOk=0;
                           free ( cBuff );
                           break;
                        }
                     }
                     if ( !matOk ) break;
                     cBuff[j]='\0';
                     const char * pBuffer = cBuff;
                     hb_arraySetC( pC, k+1, (const char *) pBuffer );
                     free ( cBuff );
                  }
                  if ( !matOk ) {
                     hb_itemRelease(pC);
                     break;
                  }
                  hb_arraySet( pCWM, i+1, pC );
                  hb_itemRelease(pC);
               }
               break;
            }
            case 1:   // numero
            {
               const char * STRING = hb_itemGetCPtr( pSTRING );
               long i,k;
               long totalCar = 0;
               for(i=0;i<nTotal;i++){
                  PHB_ITEM pC = hb_itemArrayNew( nCol ); // CWM
                  for(k=0;k<nCol;k++){
                     char * cBuff = (char *)calloc(nMax+5,1);
                     long j=0;
                     while( totalCar <= nTotCar ) {
                        if ( *STRING == '\n' ) { ++STRING; ++totalCar; break; }
                        if ( *STRING !=  Sep[0] ){
                           cBuff[j++] = *STRING;
                           ++totalCar;
                           ++STRING;
                        }else{
                           ++totalCar;
                           ++STRING;  // nos saltamos ','
                           break;
                        }
                        if (j>nMax+1){
                           matOk=0;
                           free ( cBuff );
                           break;
                        }
                     }
                     if ( !matOk ) break;
                     cBuff[j]='\0';
                     const char * pBuffer = cBuff;
                     double nBuff=0;
                     if ( xu_funIsnotation( pBuffer ) == 1 ){
                        nBuff = xu_funE2D( pBuffer );
                     }else{
                        if ( strlen(pBuffer)<=64){
                           sscanf(pBuffer, "%lf", &nBuff);
                        }else{
                           matOk=0;
                           free ( cBuff );
                           break;
                        }
                     }
                     hb_arraySetND( pC, k+1, (double) nBuff );
                     free ( cBuff );
                     
                  }
                  if ( !matOk ) {
                     hb_itemRelease(pC);
                     break;
                  }
                  hb_arraySet( pCWM, i+1, pC );
                  hb_itemRelease(pC);
                  
               }
               break;
            }
            case 2:   // logico
            {
               const char * STRING = hb_itemGetCPtr( pSTRING );
               long i,k;
               long totalCar = 0;
               for(i=0;i<nTotal;i++){
                  PHB_ITEM pC = hb_itemArrayNew( nCol ); // CWM
                  for(k=0;k<nCol;k++){
                     char * cBuff = (char *)calloc(nMax+5,1);
                     long j=0;
                     while( totalCar <= nTotCar ) {
                        if ( *STRING == '\n' ) { ++STRING; ++totalCar; break; }
                        if ( *STRING !=  Sep[0] ){
                           cBuff[j++] = *STRING;
                           ++totalCar;
                           ++STRING;
                        }else{
                           ++totalCar;
                           ++STRING;  // nos saltamos ','
                           break;
                        }
                        if (j>nMax+1){
                           matOk=0;
                           free ( cBuff );
                           break;
                        }
                     }
                     if ( !matOk ) break;
                     cBuff[j]='\0';
                     const char * pBuffer = cBuff;
                     if ( strcmp( pBuffer, CONTEXT ) == 0)
                        hb_arraySetL( pC, k+1,(HB_BOOL) HB_TRUE );
                     else
                        hb_arraySetL( pC, k+1,(HB_BOOL) HB_FALSE );
                     free ( cBuff );
                  }
                  if ( !matOk ) {
                     hb_itemRelease(pC);
                     break;
                  }
                  hb_arraySet( pCWM, i+1, pC );
                  hb_itemRelease(pC);
                  
               }
               break;
            }
            break;
         }
         break;
      }
   }
   if ( !matOk ){
      hb_itemRelease(pCWM);
      pCWM = hb_itemArrayNew( 0 ); // CWM
   }
   hb_itemClear( pSTRING );
   hb_itemReturnRelease( pCWM );
}

HB_FUNC( CUENTALINEAS )
{
   const char * pFile = hb_parc( 1 );
   const char * pSep = hb_parc( 2 );
   FILE *fp;
   long nLin=0, nTok=0, nTotTok=0,nTotCar=0,oldTok=0,noldLong=0,nLong=0;
   int sw=0,  sw_Enter=0,sw_Car=0,sw_Sep=0;
   char ch;
   
   fp=fopen(pFile,"r");
   if (fp!=NULL){
      nLin = 0;
      if ( pSep[0]=='\n' ){  // separador es salto de linea
         nTok = 1;
         while ((ch = fgetc(fp)) != EOF){
            if (ch == pSep[0]){
               ++nLin;
               ++nTotTok;
               sw_Enter=1;  // es enter
               sw_Car=0;    // 
               if (noldLong < nLong) { // longitud máxima de la línea
                  noldLong = nLong;
               }
               nLong=0;
            }else{
               ++nLong;
            }
            nTotCar++;
         }
      }else{  // separador es diferente al salto de linea.
         while ((ch = fgetc(fp)) != EOF){
            if (ch == pSep[0]){
               ++nTok;
               ++nTotTok;
               
               sw_Car=0;    // es otro caracter
               sw_Enter=0;
               sw_Sep=1;
               if (noldLong < nLong) { // longitud máxima de la línea
                  noldLong = nLong;
               }
               nLong=0;
            }else if ( ch == '\n' ){
               sw=1;   // encontró un salto de línea
               ++nLin;
               ++nTok;
               ++nTotTok;
               
               sw_Car=0;    // es otro caracter
               sw_Enter=1;
               sw_Sep=0;
               
               if (noldLong < nLong) { // longitud máxima de la línea
                  noldLong = nLong;
               }
               nLong=0;
               if ( nLin == 1 ) {
                  oldTok=nTok;
                  nTok=0;
               }else{
                  if ( nTok != oldTok ){
                    /// printf("\nTOK=%ld, OLDTOK=%ld\n",nTok,oldTok);
                     nTotTok = oldTok;  // respaldo los tokens que debiera haber.
                     oldTok=0;  // resetea para calculo de error
                     nTotCar=-1;   // indicador de error
                     break;  // error. queda línea de error y tokens
                  }
                  nTok=0;  // reinicia conteo
               }
            }else{
               ++nLong;
               sw_Car=1;    // es otro caracter
               sw_Enter=0;
               sw_Sep=0;
            }
            nTotCar++;
         }

         if ( sw && nTotCar > 0 )
            nTok = oldTok;

         if ( sw_Car && !sw_Enter && !sw_Sep ){
            if ( sw ){ ++nLin; }
            else     { ++nTotTok; ++nTok; }
         }else if( !sw_Car && !sw_Enter && sw_Sep ){
            nTotCar = -2;  // termina con separador distinto de NL
         }else if( !sw_Car && sw_Enter && !sw_Sep ){
            ;   // ok
         }
      }
      fclose(fp);
   }
   PHB_ITEM pCWM = hb_itemArrayNew( 5 );
   hb_arraySetNL( pCWM, 1, (long) nLin );  // numero de lineas
   hb_arraySetNL( pCWM, 2, (long) nTok );  // total de tokens por línea
   hb_arraySetNL( pCWM, 3, (long) nTotTok ); // total de tokens
   hb_arraySetNL( pCWM, 4, (long) nTotCar ); // total de caracteres
   hb_arraySetNL( pCWM, 5, (long) noldLong ); // linea más larga
   hb_itemReturnRelease( pCWM );

}
/*
tSIZE:=STRCUENTALINEAS(CX)
       IF AX<=tSIZE[4]
          stk_var_02[CWM]:=GETLINEAUNICA(CX,AX,tSIZE)
*/

HB_FUNC( STRGETLINEAS )
{
   PHB_ITEM pSTRING = hb_param( 1, HB_IT_STRING );
   PHB_ITEM plineas = hb_param( 2, HB_IT_ARRAY );
   long nTotLin     = hb_parnl( 3 );
   
   long n,nLin;
   long uiArrayLen = ( long ) hb_arrayLen( plineas );
   int sw;
   
   const char * STRING = hb_itemGetCPtr( pSTRING );
   char * LINEA = (char *)calloc(2,1);
   long nLen = 0;
   for (n=1; n<=uiArrayLen; n++){
      PHB_ITEM pnLinea = hb_itemArrayGet( plineas, n);
      long nlinea = hb_itemGetNL( pnLinea );
      
      if ( nlinea > nTotLin || nlinea <= 0 ){
         LINEA = (char *) realloc(LINEA, (size_t) (nLen+3));
         LINEA[nLen+1]='\n';
         LINEA[nLen+2]='\0';
         nLen = strlen(LINEA);
      }else if ( nlinea == 1){
         const char * pSTR = STRING;
         do{
            const char * pFin = pSTR;
            while ( *pFin != '\0' ){
               if ( *pFin == '\n') break;
               ++pFin;
            }
            // obtengo linea pedida:
            int nl = pFin - pSTR + 1;
            char * subLin = (char *) calloc(nl+1,1);
            strncpy(subLin, pSTR, nl);
            LINEA = (char *) realloc(LINEA, (size_t) (nLen+nl+2));
            strcat(LINEA,subLin);
            LINEA[strlen(LINEA)+1]='\0';
            nLen = strlen(LINEA);
            free(subLin);
            break;
         }while ( *pSTR != '\0' );
      }else{
         const char * pSTR = STRING;
         nLin = 0;
         sw=0;
         while ( *pSTR != '\0' ){
            if (*pSTR == '\n'){
               ++nLin;
               if ( nLin == nlinea-1 ){  // extraigo
                  const char * pIni = ++pSTR;
                  const char * pFin = pIni;
                  while ( *pFin != '\0' ){
                     if ( *pFin == '\n') break;
                     ++pFin;
                  }
                  // obtengo linea pedida:
                  int nl = pFin - pIni + 1;
                  char * subLin = (char *) calloc(nl+1,1);
                  strncpy(subLin, pIni, nl);
                  LINEA = (char *) realloc(LINEA, (size_t) (nLen+nl+2));
                  strcat(LINEA,subLin);
                  LINEA[strlen(LINEA)+1]='\0';
                  nLen = strlen(LINEA);
                  free(subLin);
                  sw=1;
                  break;
               }
            }
            ++pSTR;
         }
      }
      hb_itemRelease(pnLinea);
      
   }
   hb_itemClear( pSTRING );
   hb_itemClear( plineas );
   hb_retc( LINEA );
   free(LINEA);
}

HB_FUNC( STRCUENTALINEAS )
{
   PHB_ITEM pSTRING = hb_param( 1, HB_IT_STRING );
   
   long nLin=0;
   int sw_Enter=0,sw_Car=0;
   
   nLin = 0;
   const char * STRING = hb_itemGetCPtr( pSTRING );
   
   while ( *STRING != '\0' ){
     if (*STRING == '\n'){
        sw_Enter=1;
        sw_Car=0;
        nLin++;
     }else{
        sw_Enter=0;
        sw_Car=1;
     }
     STRING++;
   }
   if(sw_Enter==0 && sw_Car==1)
     ++nLin;

   hb_itemClear( pSTRING );
   hb_retni ( nLin );
}

HB_FUNC( FT_IDLE )
{
   hb_idleState();
}

HB_FUNC( PUTKEY )
{
   unsigned int pKey  = hb_parni( 1 );
   unsigned int pRep  = hb_parni( 2 );
   unsigned int i;
   for (i=0; i<pRep; i++)
      hb_inkeyPut(pKey);
   
}

HB_FUNC( INDEX3 )
{
    PHB_ITEM params = hb_param( 1, HB_IT_ARRAY ); // PARAMETROS
    long pRow = hb_parnl( 2 );

    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    
    unsigned int x1 = hb_itemGetNI( p1 );   // X1
    unsigned int y1 = hb_itemGetNI( p2 );   // y1
    unsigned int y2 = hb_itemGetNI( p3 );   // y2
    unsigned int z1 = hb_itemGetNI( p4 );   // z1
    unsigned int z2 = hb_itemGetNI( p5 );   // z1
    unsigned int w1 = hb_itemGetNI( p6 );   // w1
    unsigned int w2 = hb_itemGetNI( p7 );   // w1

    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
        
    long n;
    unsigned int fila,col,pag,blk;

    fila = x1;
    col  = y1;
    pag  = z1;
    blk  = w1;
    
    PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM
    
    for( n=1; n<=pRow; n++){
       PHB_ITEM pC = hb_itemArrayNew( 4 );
       hb_arraySetNI( pC, 1, fila );
       hb_arraySetNI( pC, 2, col );
       hb_arraySetNI( pC, 3, pag );
       hb_arraySetNI( pC, 4, blk++ );
       hb_arrayAdd( pCWM, pC );
       if( blk > w2 ){ blk = w1; ++pag; }
       if( pag > z2 ){ pag = z1; ++col; }
       if( col > y2 ){ col = y1; ++fila; }
       hb_itemRelease(pC);
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( INDEX2 )
{
    PHB_ITEM params = hb_param( 1, HB_IT_ARRAY ); // PARAMETROS
    long pRow = hb_parnl( 2 );

    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);

    unsigned int x1 = hb_itemGetNI( p1 );   // X1
    unsigned int y1 = hb_itemGetNI( p2 );   // y1
    unsigned int y2 = hb_itemGetNI( p3 );   // y2
    unsigned int z1 = hb_itemGetNI( p4 );   // z1
    unsigned int z2 = hb_itemGetNI( p5 );   // z1

    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    
    long n;
    unsigned int fila,col,pag;

    fila = x1;
    col  = y1;
    pag  = z1;
    
    PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM
    
    for( n=1; n<=pRow; n++){
       PHB_ITEM pC = hb_itemArrayNew( 3 );
       hb_arraySetNI( pC, 1, fila );
       hb_arraySetNI( pC, 2, col );
       hb_arraySetNI( pC, 3, pag++ );
       hb_arrayAdd( pCWM, pC );
       if( pag > z2 ){ pag = z1; ++col; }
       if( col > y2 ){ col = y1; ++fila; }
       hb_itemRelease(pC);
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( INDEX )
{
    PHB_ITEM params = hb_param( 1, HB_IT_ARRAY ); // PARAMETROS
    long pRow = hb_parnl( 2 );
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    unsigned int x1 = hb_itemGetNI( p1 );   // X1
    unsigned int y1 = hb_itemGetNI( p2 );   // y1
    unsigned int y2 = hb_itemGetNI( p3 );   // y2
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    
    long n;
    unsigned int fila,col;

    fila = x1;
    col  = y1;
    
    PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM

    for( n=1; n<=pRow; n++){
       PHB_ITEM pC = hb_itemArrayNew( 2 );
       hb_arraySetNI( pC, 1, fila );
       hb_arraySetNI( pC, 2, col++ );
       hb_arrayAdd( pCWM, pC );
       if( col > y2 ){ col = y1; ++fila; }
       hb_itemRelease(pC);
    }

    hb_itemReturnRelease( pCWM );
}

/***********************************************************/

HB_FUNC( SEQSP )
{
   double pDesde    = hb_parnd( 1 );
   double pHasta    = hb_parnd( 2 );
   unsigned pTotal  = hb_parni( 3 );
   double inc = (pHasta - pDesde) / ( pTotal - 1);
   long n;
   PHB_ITEM pC = hb_itemArrayNew( pTotal );
   
   hb_arraySetND( pC, 1,     (double) pDesde );
   hb_arraySetND( pC, pTotal,(double) pHasta );
   
   for( n=2; n<=pTotal-1; n++){
      PHB_ITEM pCC = hb_itemArrayGet( pC, n-1);
      hb_arraySetND( pC, n, hb_itemGetND( pCC ) + inc );
      hb_itemRelease(pCC);
   }
    
   hb_itemReturnRelease( pC );
}

HB_FUNC( SEQUENCE )
{
   double pDesde    = hb_parnd( 1 );
   double pInc    = hb_parnd( 2 );
   unsigned pTotal  = hb_parni( 3 );

   long n;
   PHB_ITEM pC = hb_itemArrayNew( pTotal );
   
   hb_arraySetND( pC, 1,     (double) pDesde );
   
   for( n=2; n<=pTotal; n++){
      PHB_ITEM pCC = hb_itemArrayGet( pC, n-1);
      hb_arraySetND( pC, n, hb_itemGetND( pCC ) + pInc );
      hb_itemRelease(pCC);
   }
    
   hb_itemReturnRelease( pC );
}

/********* CLACULOS MATRICIALES ***********/

double FSIN(double param){
   return sin(param);
}
double FCOS(double param){
   return cos(param);
}
double FTAN(double param){
   return tan(param);
}
double FRTOD(double param){
   return ( 180.0 / 3.14159265358979323846 ) * param;
}

double FDTOR(double param){
   return ( 3.14159265358979323846 / 180.0 ) * param;
}
double FFLOOR(double param ){
   return floor( param );
}

double FSIGN(double param ){
   double iResult;
   if( param == 0.00 )
      iResult = 0;
   else
   {
      if( param > 0.00 )
         iResult = 1;
      else
         iResult = -1;
   }
   return iResult;
}

double FLOG10(double param ){
   return (param<=0 ? HUGE_VAL: log10( param ) );
}

double FCELSIUS(double param ){
   return ( 5.0 / 9.0 ) * ( param - 32.0 );
}

double FFAHRENHEIT(double param ){
   return ( ( 9.0 / 5.0 ) * param ) + 32.0;
}

double FCOT(double param )
{
      double dResult;
      dResult = tan( param );
      dResult = dResult ? 1 / dResult : HUGE_VAL;
      return dResult ;
}

double FASIN(double param )
{
   return asin( param );
}

double FACOS(double param )
{
   return acos( param );
}

double FATAN(double param )
{
   return atan( param );
}

double FSINH(double param )
{
   return sinh( param );
}

double FCOSH(double param )
{
   return cosh( param );
}

double FTANH(double param )
{
   return tanh( param );
}
double FLOGN(double param){
   return (param<=0.0 ? HUGE_VAL : log(param)) ;
}
double FABS(double param){
   return abs(param);
}
double FEXP(double param){
   return exp(param);
}
double FSQRT(double param){
   return (param > 0 ? sqrt(param): -1.0);
}


HB_FUNC( XFLOOR )
{
   double dResult, dArg = hb_parnd( 1 );
   dResult = floor( dArg );
   hb_retnlen( dResult, 0, 0 );
}

HB_FUNC( XCEILING )
{
   double dResult, dArg = hb_parnd( 1 );
   dResult = ceil( dArg );
   hb_retnlen( dResult, 0, 0 ); 
}
double FCEILING(double param ){
   return ceil( param );
}



HB_FUNC( XCELSIUS )
{
   double dInput = hb_parnd( 1 );
   double dResult;
   dResult = ( 5.0 / 9.0 ) * ( dInput - 32.0 );
   hb_retnd( dResult );
}

HB_FUNC( XFAHRENHEIT )
{
   double dInput = hb_parnd( 1 );
   double dResult;
   dResult = ( ( 9.0 / 5.0 ) * dInput ) + 32.0;
   hb_retnd( dResult );
}

HB_FUNC( XINFINITY )
{
   hb_retnd( 93786976294838206460.00 );
}

HB_FUNC( XURTOD )
{
   double dInput = hb_parnd( 1 );
   double dResult = ( 180.0 / 3.14159265358979323846 ) * dInput;
   hb_retnd( dResult );
}

HB_FUNC( XUDTOR )
{
   double dInput = hb_parnd( 1 );
   double dResult = ( 3.14159265358979323846 / 180.0 ) * dInput;
   hb_retnd( dResult );
}

double FFACTORIAL(double param){
  double f=1;
  int i,x;
  double tablaf[21]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,
                     87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,
                     121645100408832000,2432902008176640000};
  x = (long)param;
//  if (x<=179){

    if (x<=20){
       f=tablaf[x];
    }else{
       f=tablaf[20];
       i=21;
       do{
         f=f*i;
       }while(++i<=x);
    }
//  }else{
//    f=0.0;
 // }
  return f;
}

HB_FUNC( FACTORIAL )
{
  int x=hb_parni(1);
  double f=1;
  int i;
  double tablaf[21]={1,1,2,6,24,120,720,5040,40320,362880,3628800,39916800,479001600,6227020800,
                     87178291200,1307674368000,20922789888000,355687428096000,6402373705728000,
                     121645100408832000,2432902008176640000};
    if (x<=20){
       f=tablaf[x];
    }else{
       f=tablaf[20];
       i=21;
       do{
         f=f*i;
       }while(++i<=x);
    }
  hb_retnd( f );
}

HB_FUNC( XLCM )
{
  double x=hb_parnd(1);
  double y=hb_parnd(2);
  double w;
  w=x*y;
  while (x!=y){
    if (x>y)   x=x-y;
    else       y=y-x;
  }
  hb_retnd( w/x );
}

HB_FUNC ( XGCD )
{
  double x=hb_parnd(1);
  double y=hb_parnd(2);

  while (x!=y){
    if (x>y) x=x-y;
    else     y=y-x;
  }
  hb_retnd(x);
}


HB_FUNC ( D2E )
{
  double nDec = hb_parnd(1);
  double nPrecision = hb_parnd(2);
  char *buf;
  double nExp;
  int signo;
  signo=nDec<0?-1:1;
  if (signo<0) nDec *= -1;
  if( nDec == 0) nExp = 0;
  else if (fabs( nDec ) < 1)  nExp = (double)(int)( log10( nDec ) ) - 1;
  else
      nExp = (double)(int)( log10( fabs( nDec ) + 0.00001 ) );   /* 0.00001 == kludge */
             /* for imprecise logs */
  nDec /= pow(10, nExp );  //pow(10, nExp);
  if (hb_numRound( fabs( nDec ), nPrecision ) >= 10){
      nDec /= 10;
      nExp++;
  }
  //buf = (char *) calloc(sizeof(char)*19+1,1);
  buf = (char *) calloc(32,1);
  switch((int)nPrecision){
     case 1:case 2:case 3: 
         sprintf(buf,"%1.3fE%d",nDec*signo,(int)nExp); break;
     case 4: sprintf(buf,"%1.4fE%d",nDec*signo,(int)nExp); break;
     case 5: sprintf(buf,"%1.5fE%d",nDec*signo,(int)nExp); break;
     case 6: sprintf(buf,"%1.6fE%d",nDec*signo,(int)nExp); break;
     case 7: sprintf(buf,"%1.7fE%d",nDec*signo,(int)nExp); break; 
     case 8: sprintf(buf,"%1.8fE%d",nDec*signo,(int)nExp); break;
     case 9: sprintf(buf,"%1.9fE%d",nDec*signo,(int)nExp); break; 
     default: sprintf(buf,"%1.10fE%d",nDec*signo,(int)nExp); 
  }
  hb_retc( buf );
  free(buf);
}

HB_FUNC( FROUND )
{
   double param = hb_parnd( 1 );
   unsigned int nPrecision = hb_parnd ( 2 );
   
   hb_retnd( hb_numRound( param, nPrecision ) );
}


HB_FUNC( XUFUNROUND )
{
    PHB_ITEM pA       = hb_param( 1, HB_IT_ARRAY ); // DEC
    unsigned int nPrec= hb_parni( 2 ); // PREC
    unsigned int pDim = hb_parni( 3 );   // dimension de matrices
    unsigned int pRow = hb_parni( 4 );   // rows
    unsigned int pCol = hb_parni( 5 );   // cols
    unsigned int pPag = hb_parni( 6 );   // pags
    unsigned int pBlk = hb_parni( 7 );   // blks
    
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1:{
          unsigned int n;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             double nDec = hb_itemGetND(pAA);
             hb_arraySetND( pCWM, n, (double)hb_numRound( nDec, nPrec ) ); 
             hb_itemRelease( pAA );
          }
          break;
       }
       case 2:{
          unsigned int n=1,m=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                double nDec = hb_itemGetND(pAAA);
                hb_arraySetND( pCC, m, (double)hb_numRound( nDec, nPrec ) );
                hb_itemRelease(pAAA);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 3:{
          unsigned int n=1,m=1,o=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   double nDec = hb_itemGetND(pAAAA);
                   hb_arraySetND( pCCC, o, (double)hb_numRound( nDec, nPrec ) );
                   hb_itemRelease(pAAAA);   
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 4:{
          unsigned int n=1,m=1,o=1,p=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      double nDec = hb_itemGetND(pAAAAA);
                      hb_arraySetND( pCCCC, p, (double)hb_numRound( nDec, nPrec ) );
                      hb_itemRelease(pAAAAA);
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pCCCC);   
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);   
          }
          break;
       }
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( XMATHCOMPUTE )
{
  struct {
     double (*h)(double);
  } oFunMath[23]={{FSIN},  {FCOS},    {FTAN},       {FRTOD},{FDTOR},{FSIGN},{FFLOOR},    {FCEILING},
                  {FLOG10},{FCELSIUS},{FFAHRENHEIT},{FCOT}, {FASIN},{FACOS},{FATAN},     {FSINH},
                  {FCOSH}, {FTANH},   {FLOGN},      {FABS}, {FEXP}, {FSQRT},{FFACTORIAL} };

  PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY );
  int codfun  = hb_parni( 2 );
  unsigned int pDim = hb_parni( 3 );   // dimension de matrices
  unsigned int pRow = hb_parni( 4 );   // rows
  unsigned int pCol = hb_parni( 5 );   // cols
  unsigned int pPag = hb_parni( 6 );   // pags
  unsigned int pBlk = hb_parni( 7 );   // blks

  PHB_ITEM pCWM = NULL;
  
  switch( pDim ){
  case 1 :
  {   
     switch( codfun ){
        case 5 :  // FSIGN 
        {
          unsigned int n;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetNI( pCWM, n,(int)(*oFunMath[codfun].h)(hb_itemGetND( pAA )) );
             hb_itemRelease( pAA );
          }
          break;
        }
        case 50 : // FINT
        {
          unsigned int n;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetNL( pCWM, n,(long)hb_itemGetND( pAA ) );
             hb_itemRelease( pAA );
          }
          break;
        }
        case 22 : // FFACTORIAL
        {
          unsigned int n;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             double nFacto = hb_itemGetND( pAA );
             hb_itemRelease( pAA );
             if ( nFacto > 0.0 )
                hb_arraySetND( pCWM, n,(double)(*oFunMath[codfun].h)( nFacto ));
             else
                hb_arraySetNI( pCWM, n, (int)0 );
          }
          break;
        }
        default :  // RESTO DE LA HUEA
        {
          unsigned int n;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetND( pCWM, n,(double)(*oFunMath[codfun].h)(hb_itemGetND( pAA )) );
             hb_itemRelease( pAA );
          }
          break;
        }
     }
     break;
  }
  case 2 :
  {
       unsigned int n=1,m=1;
       pCWM = hb_itemArrayNew( pRow ); // CWM 
       for( n=1; n<=pRow; n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
          for( m=1; m<=pCol; m++){
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
             switch( codfun ){
                case 5 :  // FSIGN
                {
                  hb_arraySetNI( pCC, m,(int)(*oFunMath[codfun].h)(hb_itemGetND( pAAA )) );
                  break;
                }
                case 50 : // FINT
                {
                  hb_arraySetNL( pCC, m,(long)hb_itemGetND( pAAA ) );
                  break;
                }
                case 22 : // FFACTORIAL
                {
                  double nFacto = hb_itemGetND( pAAA );
                  if ( nFacto > 0.0 )
                     hb_arraySetND( pCC, m,(double)(*oFunMath[codfun].h)( nFacto ));
                  else
                     hb_arraySetNI( pCC, m,(int) 0 );
                  break;
                }
                default :  // RESTO DE LA HUEA
                {
                  hb_arraySetND( pCC, m,(double)(*oFunMath[codfun].h)(hb_itemGetND( pAAA )) );
                  break;
                }
             }
             hb_itemRelease( pAAA );
          }
          hb_arraySet( pCWM, n, pCC );
          hb_itemRelease(pAA);
          hb_itemRelease(pCC);
       }
       break;
  }
  case 3 :
  {
       unsigned int n=1,m=1,o=1;
       pCWM = hb_itemArrayNew( pRow ); // CWM 
       for( n=1; n<=pRow; n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
          for( m=1; m<=pCol; m++){
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
             for( o=1; o<=pPag; o++){
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                switch( codfun ){
                   case 5 :  // FSIGN
                   {
                     hb_arraySetNI( pCCC, o,(int)(*oFunMath[codfun].h)(hb_itemGetND( pAAAA )) );
                     break;
                   }
                   case 50 : // FINT
                   {
                     hb_arraySetNL( pCCC, o,(long)hb_itemGetND( pAAAA ) );
                     break;
                   }
                   case 22 : // FFACTORIAL
                   {
                     double nFacto = hb_itemGetND( pAAAA );
                     if ( nFacto > 0.0 )
                        hb_arraySetND( pCCC, o,(double)(*oFunMath[codfun].h)( nFacto ));
                     else
                        hb_arraySetNI( pCCC, o,(int) 0 );
                     break; 
                   }
                   default :  // RESTO DE LA HUEA
                   {
                     hb_arraySetND( pCCC, o,(double)(*oFunMath[codfun].h)(hb_itemGetND( pAAAA )) );
                     break;
                   }
                }
                hb_itemRelease( pAAAA );
             }
             hb_arraySet( pCC, m, pCCC );
             hb_itemRelease(pAAA);
             hb_itemRelease(pCCC);
          }
          hb_arraySet( pCWM, n, pCC );
          hb_itemRelease(pAA);
          hb_itemRelease(pCC);
       }
       break;
  }
  case 4 :
  {
       unsigned int n=1,m=1,o=1,p=1;
       pCWM = hb_itemArrayNew( pRow ); // CWM 
       for( n=1; n<=pRow; n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
          for( m=1; m<=pCol; m++){
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
             for( o=1; o<=pPag; o++){
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                for( p=1; p<=pBlk; p++){
                   PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                   switch( codfun ){
                      case 5 :  // FSIGN
                      {
                        hb_arraySetNI( pCCCC, p,(int)(*oFunMath[codfun].h)(hb_itemGetND( pAAAAA )) );
                        break;
                      }
                      case 50 : // FINT
                      {
                        hb_arraySetNL( pCCCC, p,(long)hb_itemGetND( pAAAAA ) );
                        break;
                      }
                      case 22 : // FFACTORIAL
                      {
                        double nFacto = hb_itemGetND( pAAAAA );
                        if ( nFacto > 0.0 )
                           hb_arraySetND( pCCCC, p,(double)(*oFunMath[codfun].h)( nFacto ));
                        else
                           hb_arraySetNI( pCCCC, p,(int) 0 );
                        break;
                      }
                      default :  // RESTO DE LA HUEA
                      {
                        hb_arraySetND( pCCCC, p,(double)(*oFunMath[codfun].h)(hb_itemGetND( pAAAAA )) );
                        break;
                      }
                   }
                   hb_itemRelease( pAAAAA );
                }
                hb_arraySet( pCCC, o, pCCCC );
                hb_itemRelease(pAAAA);
                hb_itemRelease(pCCCC);
             }
             hb_arraySet( pCC, m, pCCC );
             hb_itemRelease(pAAA);
             hb_itemRelease(pCCC);
          }
          hb_arraySet( pCWM, n, pCC );
          hb_itemRelease(pAA);
          hb_itemRelease(pCC);
       }
  }
  }  // switch principal
  hb_itemReturnRelease( pCWM );
}

HB_FUNC( XMATHNANINF )
{
  PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY );
  int codfun  = hb_parni( 2 );
  unsigned int pDim = hb_parni( 3 );   // dimension de matrices
  unsigned int pRow = hb_parni( 4 );   // rows
  unsigned int pCol = hb_parni( 5 );   // cols
  unsigned int pPag = hb_parni( 6 );   // pags
  unsigned int pBlk = hb_parni( 7 );   // blks

  HB_BOOL retVal = HB_FALSE;
  
  switch( pDim ){
  case 1 :
  {
     unsigned int n;
     switch( codfun ){
        case 1 :  // ISNAN
        {
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             double nDATO = hb_itemGetND( pAA);
             hb_itemRelease(pAA);
             if( isnan ( nDATO ) ){
                retVal = HB_TRUE;
                break;
             }
          }
          break;
        }
        case 2 : // ISINF
        {
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             double nDATO = hb_itemGetND( pAA);
             hb_itemRelease(pAA);
             if( isinf ( nDATO ) ){
                retVal = HB_TRUE;
                break;
             }
          }
          break;
        }
     }
     break;
  }
  case 2 :
  {    
       unsigned int n=1,m=1;
       for( n=1; n<=pRow; n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          for( m=1; m<=pCol; m++){
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
             double nDATO = hb_itemGetND( pAAA );
             hb_itemRelease(pAAA);
             switch( codfun ){
                case 1 :  // ISNAN
                {
                      if( isnan ( nDATO ) ){
                         retVal = HB_TRUE;
                      }
                      break;
                }
                case 2 : // ISINF
                {
                      if( isinf ( nDATO ) ){
                         retVal = HB_TRUE;
                      }
                      break;
                }
             }
             if( retVal ) break;
          }
          hb_itemRelease(pAA);
          if( retVal ) break;
       }
       break;
  }
  case 3 :
  {
       unsigned int n=1,m=1,o=1;
       for( n=1; n<=pRow; n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          for( m=1; m<=pCol; m++){
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
             for( o=1; o<=pPag; o++){
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                double nDATO = hb_itemGetND( pAAAA );
                hb_itemRelease(pAAAA);
                switch( codfun ){
                   case 1 :  // ISNAN
                   {
                      if( isnan ( nDATO ) ){
                         retVal = HB_TRUE;
                      }
                      break;
                   }
                   case 2 : // ISINF
                   {
                      if( isinf ( nDATO ) ){
                         retVal = HB_TRUE;
                      }
                      break;
                   }
                }
                if( retVal ) break;
             }
             hb_itemRelease(pAAA);
             if( retVal ) break;
          }
          hb_itemRelease(pAA);
          if( retVal ) break;
       }
       break;
  }
  case 4 :
  {
       unsigned int n=1,m=1,o=1,p=1;
       for( n=1; n<=pRow; n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          for( m=1; m<=pCol; m++){
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
             for( o=1; o<=pPag; o++){
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                for( p=1; p<=pBlk; p++){
                   PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                   double nDATO = hb_itemGetND( pAAAAA );
                   hb_itemRelease(pAAAAA);
                   switch( codfun ){
                      case 1 :  // ISNAN
                      {
                         if( isnan ( nDATO ) ){
                            retVal = HB_TRUE;
                         }
                         break;
                      }
                      case 2 : // ISINF
                      {
                         if( isinf ( nDATO ) ){
                            retVal = HB_TRUE;
                         }
                         break;
                      }
                   }
                   if( retVal ) break;
                }
                hb_itemRelease(pAAAA);
                if( retVal ) break;
             }
             hb_itemRelease(pAAA);
             if( retVal ) break;
          }
          hb_itemRelease(pAA);
          if( retVal ) break;
       }
  }
  } // switch
  hb_retl( retVal );
}

HB_FUNC( XMATHBASIC )
{
  PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY );
  int codfun  = hb_parni( 2 );
  unsigned int pDim = hb_parni( 3 );   // dimension de matrices
  unsigned int pRow = hb_parni( 4 );   // rows
  unsigned int pCol = hb_parni( 5 );   // cols
  unsigned int pPag = hb_parni( 6 );   // pags
  unsigned int pBlk = hb_parni( 7 );   // blks

  PHB_ITEM pCWM = NULL;

  switch( pDim ){
  case 1 : {
     switch( codfun ){
        case 1 : { // INC
          unsigned int n;
          PHB_ITEM pSource = hb_itemArrayGet( pA, 1);
          if (HB_IS_NUMINT(pSource)){
             HB_MAXINT nItem;
             hb_itemRelease(pSource);
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                nItem = hb_itemGetNInt( pAA );
                hb_arraySetNInt( pCWM, n,(HB_MAXINT) (nItem + 1));
                hb_itemRelease(pAA);
             }
          }else if (HB_IS_NUMERIC(pSource)){
             double nItem;
             hb_itemRelease(pSource);
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                nItem = hb_itemGetND( pAA );
                hb_arraySetND( pCWM, n,(double) (nItem + 1));
                hb_itemRelease(pAA);
             }
          }else{
             long nItem;
             hb_itemRelease(pSource);
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                nItem = hb_itemGetNL( pAA );
                hb_arraySetNL( pCWM, n,(long) (nItem + 1));
                hb_itemRelease(pAA);
             }
          }
          
          break;
        }
        case 2 : { // DEC
          unsigned int n; 
          PHB_ITEM pSource = hb_itemArrayGet( pA, 1);
          if (HB_IS_NUMINT(pSource)){
             HB_MAXINT nItem;
             hb_itemRelease(pSource);
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                nItem = hb_itemGetNInt( pAA );
                hb_arraySetNInt( pCWM, n,(HB_MAXINT) (nItem - 1));
                hb_itemRelease(pAA);
             }
          }else if (HB_IS_NUMERIC(pSource)){
             double nItem;
             hb_itemRelease(pSource);
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                nItem = hb_itemGetND( pAA );
                hb_arraySetND( pCWM, n,(double) (nItem - 1));
                hb_itemRelease(pAA);
             }
          }else{
             long nItem;
             hb_itemRelease(pSource);
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                nItem = hb_itemGetNL( pAA );
                hb_arraySetNL( pCWM, n,(long) (nItem - 1));
                hb_itemRelease(pAA);
             }
          }
          break;
        }
        case 3 : {// NOT
          unsigned int n; 
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetL( pCWM, n,(HB_BOOL)( hb_itemGetL( pAA ) ? HB_FALSE:HB_TRUE ) );
             hb_itemRelease(pAA);
          }
          break;
        }
     }
     break;
  }
  case 2 : {
       unsigned int n=1,m=1;

       switch( codfun ){
          case 1 : { // INC
             PHB_ITEM pS = hb_itemArrayGet( pA, 1);
             PHB_ITEM pSource = hb_itemArrayGet( pS, 1);
             if (HB_IS_NUMINT(pSource)){
                hb_itemRelease(pSource);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetNInt( pCC, m,(HB_MAXINT) (hb_itemGetND( pAAA ) + 1));
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else if (HB_IS_NUMERIC(pSource)){
                hb_itemRelease(pSource);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetND( pCC, m,(double) (hb_itemGetND( pAAA ) + 1));
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else{
                hb_itemRelease(pSource);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetNL( pCC, m,(long) (hb_itemGetND( pAAA ) + 1));
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          case 2 :{ // DEC
             PHB_ITEM pS = hb_itemArrayGet( pA, 1);
             PHB_ITEM pSource = hb_itemArrayGet( pS, 1);
             if (HB_IS_NUMINT(pSource)){ 
                HB_MAXINT nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      nItem = hb_itemGetND( pAAA );
                      hb_arraySetNInt( pCC, m,(HB_MAXINT) (nItem - 1));
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else if (HB_IS_NUMERIC(pSource)){
                double nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      nItem = hb_itemGetND( pAAA );
                      hb_arraySetND( pCC, m,(double) (nItem - 1));
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else{
                long nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      nItem = hb_itemGetND( pAAA );
                      hb_arraySetNL( pCC, m,(long) (nItem - 1));
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          case 3 : { // NOT
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetL( pCC, m,(HB_BOOL)( hb_itemGetL( pAAA ) ? HB_FALSE:HB_TRUE ) );
                   hb_itemRelease(pAAA);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
             break;
          }
       }
       break;
  }
  case 3 : {
       unsigned int n=1,m=1,o=1;

       switch( codfun ){
          case 1 : { // INC
             PHB_ITEM pS = hb_itemArrayGet( pA, 1);
             PHB_ITEM pSS = hb_itemArrayGet( pS, 1);
             PHB_ITEM pSource = hb_itemArrayGet( pSS, 1);
             if (HB_IS_NUMINT(pSource)){ 
                HB_MAXINT nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         nItem = hb_itemGetNInt( pAAAA );
                         hb_arraySetNInt( pCCC, o,(HB_MAXINT) (nItem + 1 ));
                         hb_itemRelease(pAAAA);
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else if (HB_IS_NUMERIC(pSource)){
                double nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         nItem = hb_itemGetND( pAAAA );
                         hb_arraySetND( pCCC, o,(double) (nItem + 1 ));
                         hb_itemRelease(pAAAA);
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else{
                long nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         nItem = hb_itemGetNL( pAAAA );
                         hb_arraySetNL( pCCC, o,(long) (nItem + 1 ));
                         hb_itemRelease(pAAAA);
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          case 2 : { // DEC
             PHB_ITEM pS = hb_itemArrayGet( pA, 1);
             PHB_ITEM pSS = hb_itemArrayGet( pS, 1);
             PHB_ITEM pSource = hb_itemArrayGet( pSS, 1);
             if (HB_IS_NUMINT(pSource)){ 
                HB_MAXINT nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         nItem = hb_itemGetNInt( pAAAA );
                         hb_arraySetNInt( pCCC, o,(HB_MAXINT) (nItem - 1 ));
                         hb_itemRelease(pAAAA);
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else if (HB_IS_NUMERIC(pSource)){
                double nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         nItem = hb_itemGetND( pAAAA );
                         hb_arraySetND( pCCC, o,(double) (nItem - 1 ));
                         hb_itemRelease(pAAAA);
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else{
                long nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         nItem = hb_itemGetNL( pAAAA );
                         hb_arraySetNL( pCCC, o,(long) (nItem - 1 ));
                         hb_itemRelease(pAAAA);
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          case 3 : { // NOT
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      hb_arraySetL( pCCC, o,(HB_BOOL)( hb_itemGetL( pAAAA ) ? HB_FALSE:HB_TRUE ) );
                      hb_itemRelease(pAAAA);
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease(pAAA);
                   hb_itemRelease(pCCC);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
             break;
          }
       }
       break;
  }
  case 4 : {
       unsigned int n=1,m=1,o=1,p=1;

       switch( codfun ){
          case 1 : { // INC
             PHB_ITEM pS = hb_itemArrayGet( pA, 1);
             PHB_ITEM pSS = hb_itemArrayGet( pS, 1);
             PHB_ITEM pSSS = hb_itemArrayGet( pSS, 1);
             PHB_ITEM pSource = hb_itemArrayGet( pSSS, 1);
             if (HB_IS_NUMINT(pSource)){ 
                HB_MAXINT nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSSS);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            nItem = hb_itemGetNInt( pAAAAA );
                            hb_arraySetNInt( pCCCC, p,(HB_MAXINT) (nItem + 1) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else if (HB_IS_NUMERIC(pSource)){
                double nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSSS);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            nItem = hb_itemGetND( pAAAAA );
                            hb_arraySetND( pCCCC, p,(double) (nItem + 1) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else{
                long nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSSS);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            nItem = hb_itemGetNL( pAAAAA );
                            hb_arraySetNL( pCCCC, p,(long) (nItem + 1) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          case 2 : { // DEC
             PHB_ITEM pS = hb_itemArrayGet( pA, 1);
             PHB_ITEM pSS = hb_itemArrayGet( pS, 1);
             PHB_ITEM pSSS = hb_itemArrayGet( pSS, 1);
             PHB_ITEM pSource = hb_itemArrayGet( pSSS, 1);
             if (HB_IS_NUMINT(pSource)){ 
                HB_MAXINT nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSSS);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            nItem = hb_itemGetNInt( pAAAAA );
                            hb_arraySetNInt( pCCCC, p,(HB_MAXINT) (nItem - 1) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else if (HB_IS_NUMERIC(pSource)){
                double nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSSS);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            nItem = hb_itemGetND( pAAAAA );
                            hb_arraySetND( pCCCC, p,(double) (nItem - 1) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }else{
                long nItem;
                hb_itemRelease(pSource);
                hb_itemRelease(pSSS);
                hb_itemRelease(pSS);
                hb_itemRelease(pS);
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            nItem = hb_itemGetNL( pAAAAA );
                            hb_arraySetNL( pCCCC, p,(long) (nItem - 1) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          case 3 : { // NOT
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                         hb_arraySetL( pCCCC, p,(HB_BOOL)( hb_itemGetL( pAAAAA ) ? HB_FALSE:HB_TRUE ) );
                         hb_itemRelease(pAAAAA);
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pCCCC);   
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease(pAAA);
                   hb_itemRelease(pCCC);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
             break;
          }
       }
  }
  } // switch principal
  hb_itemReturnRelease( pCWM );
}

HB_FUNC( XMMATMULT )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // EBX
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // EAX
    unsigned int pRow = hb_parni( 3 );   // rows
    unsigned int pCol1 = hb_parni( 4 );   // cols1
    unsigned int pCol2 = hb_parni( 5 );   // cols2

    unsigned int ehx,eix,ejx;

    double ESX;
    
    PHB_ITEM pCWM = hb_itemArrayNew( pRow ); // CWM
    for( ehx=1; ehx<=pRow; ehx++){
       PHB_ITEM pAA = hb_itemArrayGet( pA, ehx);
       
       PHB_ITEM pCC = hb_itemArrayNew( pCol2 ); // CWM
       
       for( ejx=1; ejx<=pCol2; ejx++){
          
          ESX = 0;
          for( eix=1; eix<=pCol1; eix++){
             PHB_ITEM pA2 = hb_itemArrayGet( pAA, eix);
             PHB_ITEM pBB = hb_itemArrayGet( pB, eix);
             PHB_ITEM pB2 = hb_itemArrayGet( pBB, ejx );
             
             ESX = ESX + hb_itemGetND( pA2 ) *
                         hb_itemGetND( pB2 );
             hb_itemRelease( pA2 );
             hb_itemRelease( pB2 );
             hb_itemRelease( pBB );
          } 
          hb_arraySetND( pCC, ejx, ESX );  
       }
       hb_arraySet( pCWM, ehx, pCC );
       hb_itemRelease(pCC);
       hb_itemRelease(pAA);
    }
    hb_itemReturnRelease( pCWM );
}

/**** STRTRAN Y FUNCIONES AUXILIARES ****/
uint16_t fun_tokens(const char *linea, const char *buscar, uint16_t lb) {
   const char *t,*r; // son solo punteros apuntando a la cadena s.

   uint16_t n=0;

   r = linea;  // rescato primera posición
   t = strstr(r,buscar);
   while (t!=NULL) {
      r = t + lb;
      ++n;
      t = strstr(r,buscar);
   }

   return n;
}


char *FUNSTRTRAN(const char *linea,
               const char *buscar,
               const char *reempl,
               int ignore,
               int limite ){
   int ntoken;
   size_t llinea=strlen(linea);
   size_t lbuscar=strlen(buscar);
   size_t lreempl=strlen(reempl);
   if ((ntoken = fun_tokens(linea,buscar,lbuscar))==0){
      char * Retorno = (char *)calloc(llinea+1,1);
      strcpy(Retorno, linea);
      return Retorno;  // para qué voy a calcular.
   }
   if (limite==0) limite = ntoken;

   const char *t;
   char *r;
   size_t l=0;
   size_t size;

   // cálculo del espacio con excedente a reservar
   size = llinea + (lreempl + lbuscar)*ntoken;
   const char *u;
   u = (const char *)linea;
   
   r=(char *)calloc(size+1,1);

   if (r==NULL) return NULL;

   int i=0;
   
   do{
      t = strstr(u,buscar);
      l = t - u;
      if (l>0){
         while(l--){
            r[i] = *u ; 
            ++i; u++;
         }
         r[i]='\0';
      }
      if (ignore > 0) {
/////         printf("\ni = %d\n",i);
         int LB = lbuscar;
         //const char * pLB = buscar;
         while(LB--){
            r[i] = *u; //*pLB;
            ++i; ++u; //++pLB;
         }
         r[i]='\0';
         ignore--;
      } else {
         if (limite > 0){ // porque si limite==0, limite=ntoken
            int LR = lreempl;
            const char * pLR = reempl;
            while(LR--){
               r[i] = *pLR;
               ++i; ++pLR;
            }
            r[i]='\0';
            limite--;
         } else {
            int LB = lbuscar;
            const char * pLB = buscar;
            while(LB--){
               r[i] = *pLB;
               ++i; ++pLB;
            }
            r[i]='\0';
         }
      }
      t += lbuscar;
      u = t;
   }while(--ntoken);

   while(*u){
     r[i] = *u ; 
     ++i; ++u;
   }
   r[i]='\0';
   
   char * Retorno = (char *)calloc(i+1,1);
   strcpy(Retorno,r);
   free(r);

   return Retorno;
}

short int fun_istnumber(const char * AX){
  int DX;
  short int SW_M=0,SW_N=0,SW_P=0,retorne=1;

  while( (DX=*AX)!='\0'){
    if(DX=='-'){
       if (SW_N || SW_P || SW_M) {retorne=0;break;}
       SW_M=1;
    }else if (DX=='.'){
       if (!SW_N || SW_P) {retorne=0;break;}
       SW_P=1;
    }else if (isdigit(DX)) {SW_N=1;
    }else {retorne=0;break;}
    ++AX;
  }
  return retorne;
}

HB_FUNC( ISTNUMBER )  // esto debe ir!! llevar otros codigos semejante a "C"
{
  PHB_ITEM pText = hb_param(1,HB_IT_STRING);
  const char *AX = hb_itemGetCPtr( pText );
  
  hb_retnint(fun_istnumber(AX));
}

HB_SIZE hb_striAt( const char * szSub, HB_SIZE nSubLen, const char * szText, HB_SIZE nLen )
{

   if( nSubLen > 0 && nLen >= nSubLen )
   {
      HB_SIZE nPos = 0;
      nLen -= nSubLen;
      do
      {
         if( HB_TOUPPER(szText[ nPos ]) == HB_TOUPPER(*szSub) )
         {
            HB_SIZE nSubPos = nSubLen;
            do
            {
               if( --nSubPos == 0 )
                  return nPos + 1;
            }
            while( HB_TOUPPER(szText[ nPos + nSubPos ]) == HB_TOUPPER(szSub[ nSubPos ]) );
         }
      }
      while( nPos++ < nLen );
   }

   return 0;
}

HB_FUNC( XU_TYPENUM )
{
   double pNum = hb_parnd( 1 );
   int numTyp=0;
   
   if( isnan(pNum) ) numTyp=1;
   else if( isinf(pNum) ) numTyp=2;
   
   hb_retni( numTyp );
}


HB_FUNC( SETDIFF )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = ARRAY 1
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B = ARRAY 2
    unsigned int pRowA = hb_parni( 3 );   // rowsA
    unsigned int pRowB = hb_parni( 4 );   // rowsB
    unsigned int pTyp = hb_parni( 5 );   // tipo. 1=num, 0=string
    
    // Creo el array, después ajusto. Siempre será menor o igual a tamaño original.
    PHB_ITEM pCWM = hb_itemArrayNew( pRowA>pRowB?pRowA:pRowB );
    unsigned n,m,sw,piv;
    
    if ( pTyp ){   // number
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=pRowA;n++){
          sw = 1;
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          double npA=hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=pRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pB, m);
             double npB=hb_itemGetND(pBB);
             hb_itemRelease( pBB );
             if( npA == npB ){
                sw = 0;
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if ( npA < npB ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
          if( sw ){
             hb_arraySetND( pCWM, ++nSize, (double) npA );
          }
       }
       hb_arraySize( pCWM, nSize ); // ajusto array final
    }else{   // string
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=pRowA;n++){
          sw = 1;

          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          const char * npA = hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=pRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pB, m);
             const char * npB = hb_itemGetCPtr(pBB);
             hb_itemRelease( pBB );
             if( strcmp ( npA, npB ) == 0 ){
                sw = 0;
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if( strcmp( npA, npB ) < 0 ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
          if( sw ){
             hb_arraySetC( pCWM, ++nSize, (const char *) npA );
          }
       }
       hb_arraySize( pCWM, nSize ); // ajusto array final    
    }
    hb_itemReturnRelease( pCWM );  // pongo en pila de devolucion
}

HB_FUNC( UNIQUE )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = ARRAY 1
    unsigned int pRowA = hb_parni( 2 );   // rows
    unsigned int pTyp = hb_parni( 3 );   // tipo. 1=num, 0=string
    
    // Creo el array, después ajusto. Siempre será menor o igual a tamaño original.
    PHB_ITEM pCWM = hb_itemArrayNew( pRowA );
    unsigned n;
    
    // EL ARRAY DEBE ESTAR ORDENADO.
    if ( pTyp ){   // number
       HB_MAXINT nSize=1;

       PHB_ITEM pAA = hb_itemArrayGet( pA, 1); 
       double npA = hb_itemGetND(pAA);
       hb_itemRelease( pAA );
       hb_arraySetND( pCWM, 1, (double) npA );
       for(n=2;n<=pRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          double npAA = hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          if( npAA != npA ){
             hb_arraySetND( pCWM, ++nSize, (double) npAA );
          }
          npA = npAA;
       }
       hb_arraySize( pCWM, nSize ); // ajusto array final
    }else{  // string
       HB_MAXINT nSize=1;
       PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
       const char * npA = hb_itemGetCPtr(pAA);
       hb_itemRelease( pAA );
       hb_arraySetC( pCWM, 1, (const char *) npA );
       for(n=2;n<=pRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          const char * npAA = hb_itemGetCPtr(pAA);
          if( strcmp ( npA, npAA ) != 0 ){
             hb_arraySetC( pCWM, ++nSize, (const char *) npAA );
          }
          npA = hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
       }
       hb_arraySize( pCWM, nSize ); // ajusto array final
    }
    hb_itemReturnRelease( pCWM );  // pongo en pila de devolucion
}

HB_FUNC( SETUNION )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = ARRAY 1
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B = ARRAY 2
    unsigned int pRowA = hb_parni( 3 );   // rows
    unsigned int pRowB = hb_parni( 4 );   // cols
    unsigned int pTyp = hb_parni( 5 );   // tipo. 1=num, 0=string
    
    // creo un array con la suma total de elementos. Despues ajusto con UNIQUE:
    PHB_ITEM pCWM = hb_itemArrayNew( pRowA + pRowB );
    
    unsigned n;
    
    if ( pTyp ){   // number
       HB_MAXINT nSize=0;
       // RELLENO EL ARRAY INICIAL
       for(n=1;n<=pRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          hb_arraySetND( pCWM, ++nSize, (double) hb_itemGetND(pAA) );
          hb_itemRelease( pAA );
       }
       for(n=1;n<=pRowB;n++){
          PHB_ITEM pBB = hb_itemArrayGet( pB, n);
          hb_arraySetND( pCWM, ++nSize, (double) hb_itemGetND(pBB) );
          hb_itemRelease( pBB );
       }    
    }else{  // sting
       HB_MAXINT nSize=0;
       for(n=1;n<=pRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          hb_arraySetC( pCWM, ++nSize, (const char*) hb_itemGetCPtr(pAA) );
          hb_itemRelease( pAA );
       }
       for(n=1;n<=pRowB;n++){
          PHB_ITEM pBB = hb_itemArrayGet( pB, n);
          hb_arraySetC( pCWM, ++nSize, (const char*) hb_itemGetCPtr(pBB) );
          hb_itemRelease( pBB );
       }
    }
    ///hb_arraySort( pCWM,NULL,NULL,NULL);
    hb_itemReturnRelease( pCWM );  // pongo en pila de devolucion
}

HB_FUNC( SETINTERSECTION )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = ARRAY 1
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B = ARRAY 2
    unsigned int pRowA = hb_parni( 3 );   // rows
    unsigned int pRowB = hb_parni( 4 );   // cols
    unsigned int pTyp = hb_parni( 5 );   // tipo. 1=num, 0=string
    
    // tamaño estimado: no puede ser mayor que el mayor de los conjuntos.
    PHB_ITEM pCWM = hb_itemArrayNew( pRowA>pRowB?pRowA:pRowB );
    
    unsigned m,n,piv;
    
    if ( pTyp ){   // number
       HB_MAXINT nSize=0;
       piv=1;  //con esto evito que busque en los datos que ya buscó.
       for(n=1;n<=pRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          double npA=hb_itemGetND(pAA);
          hb_itemRelease( pAA );
          for(m=piv;m<=pRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pB, m);
             double npB=hb_itemGetND(pBB);
             hb_itemRelease( pBB );
             if( npA == npB ){
/////                hb_arraySize( pCWM, ++nSize );
                hb_arraySetND( pCWM, ++nSize, (double) npA );
                piv=m+1;  // empiece desde el último analizado +1.
                break;
             }else if ( npA < npB ){  //con datos ordenados, no tiene sentido que
                                      // busque cuando npB es mayor.
                piv=m;  // el ultimo no encajó, debo mantenerlo para el sig. npA
                break;
             }
          }
       }
       hb_arraySize( pCWM, nSize ); // ajusto array final
    }else{  // string

       HB_MAXINT nSize=0;
       for(n=1;n<=pRowA;n++){
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          const char * npA=hb_itemGetCPtr(pAA);
          hb_itemRelease( pAA );
          for(m=1;m<=pRowB;m++){
             PHB_ITEM pBB = hb_itemArrayGet( pB, m);
             const char * npB=hb_itemGetCPtr(pBB);
             hb_itemRelease( pBB );
             if( strcmp ( npA, npB ) == 0 ){
                hb_arraySetC( pCWM, ++nSize, (const char*) npA );
                break;
             }
          }
       }
       hb_arraySize( pCWM, nSize ); // ajusto array final
    }
    hb_itemReturnRelease( pCWM );
}

///X2FINDSTK(TEMPORAL,AX,CX,{DIM,DIMR,DIMC,DIMP,DIMB,DIM1R,OPE,FVWITH,TYP})
HB_FUNC( X2FINDSTK )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = ARRAY FUENTE
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B = ARRAY A COMPARAR
    PHB_ITEM params   = hb_param( 3, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    PHB_ITEM p8 = hb_itemArrayGet( params, 8);
    PHB_ITEM p9 = hb_itemArrayGet( params, 9);
    PHB_ITEM p10 = hb_itemArrayGet( params, 10);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    unsigned int cRow = hb_itemGetNI( p6 );   // rows array de comparacion
    int codfun        = hb_itemGetNI( p7 );   // cod funcion
    int pCaseSen      = hb_itemGetNI( p8 );   // Case sensitive
    int pTyp          = hb_itemGetNI( p9 );   // tipo de la mat 
    int pCaracter     = hb_itemGetNI( p10 );  // 0=comparacionn suave; 1=fuerte 
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
    hb_itemRelease(p8);
    hb_itemRelease(p9);
    hb_itemRelease(p10);
    
    PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM
    
    long nSize=0;
    
    switch( pDim ){
      case 1 :
      {
        unsigned int n;
        unsigned int pCom;
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {
               switch( pTyp ){   // tipos a comparar. Aqui no vale la cmoparacion fuerte
                  case 1 : // string
                  {
                     const char * pNeutro;
                     for(n=1;n<=pRow;n++){
                        PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                        pNeutro=hb_itemGetCPtr(pAA);
                        hb_itemRelease( pAA );
                        for(pCom=1; pCom<=cRow; pCom++){
                           PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                           const char * DATO = hb_itemGetCPtr( pBB);
                           hb_itemRelease( pBB );
                           if( !pCaseSen ){
                              if( strcmp( pNeutro, DATO ) == 0 ){
                                 hb_arraySize( pCWM, ++nSize );
                                 hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                 break;  // encontró al menos uno.
                              }
                           }else{
                              if( hb_stricmp( pNeutro, DATO ) == 0 ){
                                 hb_arraySize( pCWM, ++nSize );
                                 hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                 break;
                              }
                           }
                           
                        }
                     }
                     break;
                  }
                  case 2 : // number. Aqui no vale la comparacion fuerte
                  {
                     double nNeutro;
                     for(n=1;n<=pRow;n++){
                        PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                        nNeutro=hb_itemGetND(pAA);
                        hb_itemRelease( pAA );
                        for(pCom=1; pCom<=cRow; pCom++){
                           PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                           double nDATO=hb_itemGetND( pBB);
                           hb_itemRelease( pBB );
                           if( nNeutro == nDATO ){
                              hb_arraySize( pCWM, ++nSize );
                              hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                              break;
                           }
                           
                        }
                     }
                     break;
                  }
                  default :
                     break;
               }
               break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>". Aqui vale comparacion fuerte
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                double nNeutro;

                switch( codfun ){
                   case 2 : // ">"
                   {
                      if( !pCaracter ){  // comparacion suave
                         for(n=1;n<=pRow;n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro > nDATO ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                  break;
                               }
                               
                            }
                         }
                      }else{  // comparacion fuerte
                         for(n=1;n<=pRow;n++){
                            int swTodos=1;
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro <= nDATO ){
                                  swTodos=0;
                                  break;
                               }
                               
                            }
                            if( swTodos ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                   case 3 : // "<"
                   {
                      if( !pCaracter ){  // comparacion suave
                         for(n=1;n<=pRow;n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro < nDATO ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                  break;
                               }
                               
                            }
                         }
                      }else{  // comparacion fuerte
                         for(n=1;n<=pRow;n++){
                            int swTodos=1;
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro >= nDATO ){
                                  swTodos=0;
                                  break;
                               }
                               
                            }
                            if( swTodos ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                   case 4 : // ">="
                   {
                      if( !pCaracter ){  // comparacion suave
                         for(n=1;n<=pRow;n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro >= nDATO ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                  break;
                               }
                               
                            }
                         }
                      }else{  // comparacion fuerte
                         for(n=1;n<=pRow;n++){
                            int swTodos=1;
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro < nDATO ){
                                  swTodos=0;
                                  break;
                               }
                               
                            }
                            if( swTodos ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                   case 5 : // "<="
                   {
                      if( !pCaracter ){  // comparacion suave
                         for(n=1;n<=pRow;n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro <= nDATO ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                  break;
                               }
                               
                            }
                         }
                      }else{  // comparacion fuerte
                         for(n=1;n<=pRow;n++){
                            int swTodos=1;
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            nNeutro=hb_itemGetND(pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO=hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro > nDATO ){
                                  swTodos=0;
                                  break;
                               }
                            }
                            if( swTodos ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                   case 6 : // "<>"
                   {
                      if( pTyp == 1 ){  // string
                         const char * pNeutro;
                         if( !pCaracter ){  // comparacion suave: al menos uno.
                            for(n=1;n<=pRow;n++){
                               PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                               pNeutro=hb_itemGetCPtr(pAA);
                               hb_itemRelease( pAA );
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  const char * DATO =  hb_itemGetCPtr( pBB);
                                  hb_itemRelease( pBB );
                                  if( !pCaseSen ){
                                     if( strcmp( pNeutro, DATO ) != 0 ){
                                        hb_arraySize( pCWM, ++nSize );
                                        hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                        break;
                                     }
                                  }else{
                                     if( hb_stricmp( pNeutro, DATO ) != 0 ){
                                        hb_arraySize( pCWM, ++nSize );
                                        hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                        break;
                                     }
                                  }
                                  
                               }
                            }
                         }else{   // comparacion fuerte: todos deben ser distintos
                            for(n=1;n<=pRow;n++){
                               int swTodos=1;
                               PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                               pNeutro=hb_itemGetCPtr(pAA);
                               hb_itemRelease( pAA );
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  const char * DATO = hb_itemGetCPtr( pBB);
                                  hb_itemRelease( pBB );
                                  if( !pCaseSen ){
                                     if( strcmp( pNeutro, DATO ) == 0 ){
                                        swTodos=0;
                                        break;
                                     }
                                  }else{
                                     if( hb_stricmp( pNeutro, DATO ) == 0 ){
                                        swTodos=0;
                                        break;
                                     }
                                  }
                                  
                               }
                               if( swTodos ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                               }
                            }
                         }
                      }else{  // numero "<>"
                         if( !pCaracter ){  // comparacion suave
                            for(n=1;n<=pRow;n++){
                               PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                               nNeutro=hb_itemGetND(pAA);
                               hb_itemRelease( pAA );
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro != nDATO ){
                                     hb_arraySize( pCWM, ++nSize );
                                     hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                     break;
                                  }
                                  
                               }
                            }
                         }else{  // comparacion fuerte
                            for(n=1;n<=pRow;n++){
                               int swTodos=1;
                               PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                               nNeutro=hb_itemGetND(pAA);
                               hb_itemRelease( pAA );
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro == nDATO ){
                                     swTodos=0;
                                     break;
                                  }
                                  
                               }
                               if( swTodos ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                               }
                            }
                         }
                      }
                      break;
                   }
                }
             }
             break;
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pText;
                HB_SIZE nLen, nSubLen;

                switch( codfun ){
                   case 7 : // "@"
                   {
                      if( !pCaracter ) { // comparacion suave
                         for(n=1;n<=pRow;n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            pText = hb_itemGetCPtr( pAA) ;
                            nLen  = hb_itemGetCLen( pAA);
                            hb_itemRelease( pAA );
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               nSubLen = hb_itemGetCLen( pBB);
                               const char * DATO = hb_itemGetCPtr( pBB);
                               hb_itemRelease( pBB );
                               if( pCaseSen ){
                                  if( hb_striAt( DATO,
                                                 nSubLen, pText, nLen ) > 0 ){
                                     hb_arraySize( pCWM, ++nSize );
                                     hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                     
                                     break;
                                  }
                               }else{
                                  if( hb_strAt( DATO,
                                                nSubLen, pText, nLen ) > 0 ){
                                     hb_arraySize( pCWM, ++nSize );
                                     hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                                     break;
                                  }
                               }
                            }
                         }
                      }else{  // comparacion fuerte: todos deben estar contenidos
                         for(n=1;n<=pRow;n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            pText = hb_itemGetCPtr( pAA) ;
                            nLen  = hb_itemGetCLen( pAA);
                            hb_itemRelease( pAA );
                            int swTodos=1;
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               nSubLen = hb_itemGetCLen( pBB);
                               const char * DATO = hb_itemGetCPtr( pBB);
                               hb_itemRelease( pBB );
                               if( pCaseSen ){
                                  if( hb_striAt( DATO,
                                                 nSubLen, pText, nLen ) == 0 ){
                                     swTodos=0;
                                     break;
                                  }
                               }else{
                                  if( hb_strAt( DATO,
                                                nSubLen, pText, nLen ) == 0 ){
                                     swTodos=0;
                                     
                                     break;
                                  }
                               }
                               
                            }
                            if( swTodos ) {
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                   case 8 : // "~@" es comparacion fuerte de por si.
                   {
                      for(n=1;n<=pRow;n++){
                         int swNoEsta=1;
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         pText = hb_itemGetCPtr( pAA);
                         nLen  = hb_itemGetCLen( pAA);
                         hb_itemRelease( pAA );
                         for(pCom=1; pCom<=cRow; pCom++){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                            nSubLen = hb_itemGetCLen( pBB);
                            const char * DATO = hb_itemGetCPtr( pBB);
                            hb_itemRelease( pBB );
                            if( pCaseSen ){
                               if( hb_striAt( DATO, 
                                              nSubLen, pText, nLen ) > 0 ){
                                  swNoEsta=0;
                                  break;
                               }
                            }else{
                               if( hb_strAt( DATO, 
                                             nSubLen, pText, nLen ) > 0 ){
                                  swNoEsta=0;
                                  break;
                               }
                            }
                            
                         }
                         if( swNoEsta ){
                            hb_arraySize( pCWM, ++nSize );
                            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                         }
                      }
                      break;
                   }
                }
             }
             break;
          }
        }
        break;
      }
      case 2 : // 2D
      {
               
        unsigned int n=1,m=1;

        const char * pNeutro;
        double nNeutro;
        unsigned int pCom;
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {  
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   switch( pTyp ){   // tipos a comparar
                      case 1 : // string
                      {
                         pNeutro=hb_itemGetCPtr(pAAA);
                         for(pCom=1; pCom<=cRow; pCom++){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                            const char * DATO = hb_itemGetCPtr( pBB);
                            hb_itemRelease( pBB );
                            if( !pCaseSen ){
                               if( strcmp( pNeutro, DATO ) == 0 ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                                  break;
                               }
                            }else{
                               if( hb_stricmp( pNeutro, DATO ) == 0 ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                                  break;
                               }
                            }
                            
                         }
                         break;
                      }
                      case 2 : // number
                      {
                         nNeutro=hb_itemGetND(hb_itemArrayGet( pAA, m));
                         for(pCom=1; pCom<=cRow; pCom++){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                            double nDATO = hb_itemGetND( pBB);
                            hb_itemRelease( pBB );
                            if( nNeutro == nDATO ){
                               PHB_ITEM pC  = hb_itemArrayNew( 2 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                               break;
                            }
                            
                         }
                         break;
                      }
                      default : 
                         break;
                   }
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      switch( codfun ){
                         case 2 : // ">"
                         {
                            nNeutro=hb_itemGetND(pAAA);
                            if( !pCaracter ){  // compara suavemente
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro > nDATO ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                                  
                               }
                            }else{  // compara fuertemente
                               int swTodos=1;
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro <= nDATO ){
                                     swTodos=0;
                                     break;
                                  }
                               }
                               if( swTodos ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                         case 3 : // "<"
                         {
                            nNeutro=hb_itemGetND(pAAA);
                            if( !pCaracter ){  // suavemente
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro < nDATO ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                                  
                               }
                            }else{  // fuertemente
                               int swTodos=1;
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro >= nDATO ){
                                     swTodos=0;
                                     break;
                                  }
                                  
                               }
                               if( swTodos ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                         case 4 : // ">="
                         {
                            nNeutro=hb_itemGetND(pAAA);
                            if( !pCaracter ){  // suavemente
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro >= nDATO ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                                  
                               }
                            }else{  // fuertemente
                               int swTodos=1;
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro < nDATO ){
                                     swTodos=0;
                                     break;
                                  }
                                  
                               }
                               if( swTodos ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                         case 5 : // "<="
                         {
                            nNeutro=hb_itemGetND(pAAA);
                            if( !pCaracter ){  // suavemente
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro <= nDATO ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                                  
                               }
                            }else{  // fuertemente
                               int swTodos=1;
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro > nDATO ){
                                     swTodos=0;
                                     break;
                                  }
                                  
                               }
                               if( swTodos ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                         case 6 : // "<>"
                         {
                            if( pTyp == 1 ){  // string
                               pNeutro = hb_itemGetCPtr(pAAA);
                               if( !pCaracter ) { // suave
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     const char * DATO = hb_itemGetCPtr( pBB);
                                     hb_itemRelease( pBB );
                                     if( !pCaseSen ){
                                        if( strcmp( pNeutro, DATO ) != 0 ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                     }else{
                                        if( hb_stricmp(pNeutro, DATO ) != 0 ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                     }
                                     
                                  }
                               }else{  // fuerte
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     const char * DATO = hb_itemGetCPtr( pBB);
                                     hb_itemRelease( pBB );
                                     if( !pCaseSen ){
                                        if( strcmp( pNeutro, DATO ) == 0 ){
                                           swTodos=0;
                                           break;
                                        }
                                     }else{
                                        if( hb_stricmp(pNeutro, DATO ) == 0 ){
                                           swTodos=0;
                                           break;
                                        }
                                     }
                                     
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                            }else{  // numero
                               nNeutro=hb_itemGetND(pAAA);
                               if( !pCaracter ){  // suavemente
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro != nDATO ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                     
                                  }
                               }else{  // fuertemente
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro == nDATO ){
                                        swTodos=0;
                                        break;
                                     }
                                     
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                            }
                            break;
                         }
                      }   // switch
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pText;

                HB_SIZE nLen, nSubLen;

                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      pText = hb_itemGetCPtr( pAAA);
                      nLen  = hb_itemGetCLen( pAAA);
                      hb_itemRelease( pAAA );
                      switch( codfun ){
                         case 7 : // "@"
                         {
                            if( !pCaracter ){  // suave
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  nSubLen = hb_itemGetCLen( pBB);
                                  const char * DATO = hb_itemGetCPtr( pBB);
                                  hb_itemRelease( pBB );
                                  if( pCaseSen ){
                                     if( hb_striAt( DATO, 
                                                    nSubLen, pText, nLen ) > 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                  }else{
                                     if( hb_strAt( DATO, 
                                                   nSubLen, pText, nLen ) > 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                  }
                                  
                               }
                            }else{  // fuerte
                               int swTodos=1;
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  nSubLen = hb_itemGetCLen( pBB);
                                  const char * DATO = hb_itemGetCPtr( pBB);
                                  hb_itemRelease( pBB );
                                  if( pCaseSen ){
                                     if( hb_striAt( DATO, 
                                                    nSubLen, pText, nLen ) == 0 ){
                                        swTodos=0;
                                        break;
                                     }
                                  }else{
                                     if( hb_strAt( DATO, 
                                                   nSubLen, pText, nLen ) == 0 ){
                                        swTodos=0;
                                        break;
                                     }
                                  }
                                  
                               }
                               if( swTodos ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                         case 8 : // "~@"
                         {
                            int swTodos=1;
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               nSubLen = hb_itemGetCLen( pBB);
                               const char * DATO = hb_itemGetCPtr( pBB);
                               hb_itemRelease( pBB );
                               if( pCaseSen ){
                                  if( hb_striAt( DATO, 
                                                 nSubLen, pText, nLen ) > 0 ){
                                     swTodos=0;
                                     break;
                                  }
                               }else{
                                  if( hb_strAt( DATO, 
                                                nSubLen, pText, nLen ) > 0 ){
                                     swTodos=0;
                                     break;
                                  }
                               }
                               
                            }
                            if( swTodos ){
                               PHB_ITEM pC  = hb_itemArrayNew( 2 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            break;
                         }
                      }
                   }
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
        }
        break;
      }
      case 3 : // 3D
      {       
               
        unsigned int n=1,m=1,o=1;

        const char * pNeutro;
        double nNeutro;
        unsigned int pCom;

        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {  
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                      switch( pTyp ){   // tipos a comparar
                         case 1 : // string
                         {
                            pNeutro=hb_itemGetCPtr(pAAAA);
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               const char * DATO = hb_itemGetCPtr( pBB);
                               hb_itemRelease( pBB );
                               if( !pCaseSen ){
                                  if( strcmp( pNeutro, DATO ) == 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                               }else{
                                  if( hb_stricmp( pNeutro, DATO ) == 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                               }
                               
                            }
                            break;
                         }
                         case 2 : // number
                         {
                            nNeutro=hb_itemGetND(pAAAA);
                            for(pCom=1; pCom<=cRow; pCom++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                               double nDATO = hb_itemGetND( pBB);
                               hb_itemRelease( pBB );
                               if( nNeutro == nDATO ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                                  break;
                               }
                               
                            }
                            break;
                         }
                         default : 
                            break;
                      } // switch
                      hb_itemRelease( pAAAA );
                   }
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         switch( codfun ){
                            case 2 : // ">"
                            {
                               nNeutro=hb_itemGetND(pAAAA);
                               if( !pCaracter ){  // compara suavemente
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro > nDATO ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                     
                                  }
                               }else{  // compara fuertemente
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro <= nDATO ){
                                        swTodos=0;
                                        break;
                                     }
                                     
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 3 : // "<"
                            {
                               nNeutro=hb_itemGetND(pAAAA);
                               if( !pCaracter ){  // suavemente
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro < nDATO ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                     
                                  }
                               }else{  // fuertemente
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro >= nDATO ){
                                        swTodos=0;
                                        break;
                                     }
                                     
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 4 : // ">="
                            {
                               nNeutro=hb_itemGetND(pAAAA);
                               if( !pCaracter ){  // suavemente
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro >= nDATO ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                     
                                  }
                               }else{  // fuertemente
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro < nDATO ){
                                        swTodos=0;
                                        break;
                                     }
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 5 : // "<="
                            {
                               nNeutro=hb_itemGetND(pAAAA);
                               if( !pCaracter ){  // suavemente
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro <= nDATO ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                  }
                               }else{  // fuertemente
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     double nDATO = hb_itemGetND( pBB);
                                     hb_itemRelease( pBB );
                                     if( nNeutro > nDATO ){
                                        swTodos=0;
                                        break;
                                     }
                                     
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 6 : // "<>"
                            {
                               if( pTyp == 1 ){  // string
                                  pNeutro = hb_itemGetCPtr(pAAAA);
                                  if( !pCaracter ) { // suave
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        const char * DATO = hb_itemGetCPtr( pBB);
                                        hb_itemRelease( pBB );
                                        if( !pCaseSen ){
                                           if( strcmp( pNeutro, DATO ) != 0 ){
                                              PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                              ++nSize;
                                              hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                              hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                              hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                              hb_arrayAdd( pCWM, pC );
                                              hb_itemRelease( pC );
                                              break;
                                           }
                                        }else{
                                           if( hb_stricmp(pNeutro, DATO ) != 0 ){
                                              PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                              ++nSize;
                                              hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                              hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                              hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                              hb_arrayAdd( pCWM, pC );
                                              hb_itemRelease( pC );
                                              break;
                                           }
                                        }
                                        
                                     }
                                  }else{  // fuerte
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        const char * DATO = hb_itemGetCPtr( pBB);
                                        hb_itemRelease( pBB );
                                        if( !pCaseSen ){
                                           if( strcmp( pNeutro, DATO ) == 0 ){
                                              swTodos=0;
                                              break;
                                           }
                                        }else{
                                           if( hb_stricmp(pNeutro, DATO ) == 0 ){
                                              swTodos=0;
                                              break;
                                           }
                                        }
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                               }else{  // numero
                                  nNeutro=hb_itemGetND(pAAAA);
                                  if( !pCaracter ){  // suavemente
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro != nDATO ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                     }
                                  }else{  // fuertemente
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro == nDATO ){
                                           swTodos=0;
                                           break;
                                        }
                                        
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                               }
                               break;
                            }
                         }// switch
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ) {
                const char * pText;

                HB_SIZE nLen, nSubLen;

                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         pText = hb_itemGetCPtr( pAAAA);
                         nLen  = hb_itemGetCLen( pAAAA);
                         hb_itemRelease( pAAAA );
                         switch( codfun ){
                            case 7 : // "@"
                            {
                               if( !pCaracter ){  // suave
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     nSubLen = hb_itemGetCLen( pBB);
                                     const char * DATO = hb_itemGetCPtr( pBB);
                                     hb_itemRelease( pBB );
                                     if( pCaseSen ){
                                        if( hb_striAt( DATO, 
                                                       nSubLen, pText, nLen ) > 0 ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                     }else{
                                        if( hb_strAt( DATO, 
                                                      nSubLen, pText, nLen ) > 0 ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                     }
                                     
                                  }
                               }else{  // fuerte
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     nSubLen = hb_itemGetCLen( pBB);
                                     const char * DATO = hb_itemGetCPtr( pBB);
                                     hb_itemRelease( pBB );
                                     if( pCaseSen ){
                                        if( hb_striAt( DATO , 
                                                       nSubLen, pText, nLen ) == 0 ){
                                           swTodos=0;
                                           break;
                                        }
                                     }else{
                                        if( hb_strAt( DATO , 
                                                      nSubLen, pText, nLen ) == 0 ){
                                           swTodos=0;
                                           break;
                                        }
                                     }
                                     
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 8 : // "~@"
                            {
                               int swTodos=1;
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  nSubLen = hb_itemGetCLen( pBB);
                                  const char * DATO = hb_itemGetCPtr( pBB);
                                  hb_itemRelease( pBB );
                                  if( pCaseSen ){
                                     if( hb_striAt( DATO, 
                                                    nSubLen, pText, nLen ) > 0 ){
                                        swTodos=0;
                                        break;
                                     }
                                  }else{
                                     if( hb_strAt( DATO, 
                                                   nSubLen, pText, nLen ) > 0 ){
                                        swTodos=0;
                                        break;
                                     }
                                  }
                                  
                               }
                               if( swTodos ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                               break;
                            }
                         }  // switch
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
        }
        break;
      }
      case 4 : // 4D
      {
               
        unsigned int n=1,m=1,o=1,p=1;

        const char * pNeutro;
        double nNeutro;
        unsigned int pCom;
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {  
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                         switch( pTyp ){   // tipos a comparar
                            case 1 : // string
                            {
                               pNeutro=hb_itemGetCPtr(pAAAAA);
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  const char * DATO = hb_itemGetCPtr( pBB);
                                  hb_itemRelease( pBB );
                                  if( !pCaseSen ){
                                     if( strcmp( pNeutro, DATO ) == 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                  }else{
                                     if( hb_stricmp( pNeutro, DATO ) == 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                        break;
                                     }
                                  }
                                  
                               }
                               break;
                            }
                            case 2 : // number
                            {
                               nNeutro=hb_itemGetND(pAAAAA);
                               for(pCom=1; pCom<=cRow; pCom++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                  double nDATO = hb_itemGetND( pBB);
                                  hb_itemRelease( pBB );
                                  if( nNeutro == nDATO ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                     break;
                                  }
                                  
                               }
                               break;
                            }
                            default : 
                               break;
                         } // switch
                         hb_itemRelease( pAAAAA );
                      }
                      hb_itemRelease( pAAAA );
                   }
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                            switch( codfun ){
                               case 2 : // ">"
                               {
                                  nNeutro=hb_itemGetND(pAAAAA);
                                  if( !pCaracter ){  // compara suavemente
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro > nDATO ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                        
                                     }
                                  }else{  // compara fuertemente
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro <= nDATO ){
                                           swTodos=0;
                                           break;
                                        }
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                               case 3 : // "<"
                               {
                                  nNeutro=hb_itemGetND(pAAAAA);
                                  if( !pCaracter ){  // suavemente
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro < nDATO ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                     }
                                  }else{  // fuertemente
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro >= nDATO ){
                                           swTodos=0;
                                           break;
                                        }
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                               case 4 : // ">="
                               {
                                  nNeutro=hb_itemGetND(pAAAAA);
                                  if( !pCaracter ){  // suavemente
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro >= nDATO ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                        
                                     }
                                  }else{  // fuertemente
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro < nDATO ){
                                           swTodos=0;
                                           break;
                                        }
                                        
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                               case 5 : // "<="
                               {
                                  nNeutro=hb_itemGetND(pAAAAA);
                                  if( !pCaracter ){  // suavemente
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro <= nDATO ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                           break;
                                        }
                                        
                                     }
                                  }else{  // fuertemente
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        double nDATO = hb_itemGetND( pBB);
                                        hb_itemRelease( pBB );
                                        if( nNeutro > nDATO ){
                                           swTodos=0;
                                           break;
                                        }
                                        
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                               case 6 : // "<>"
                               {
                                  if( pTyp == 1 ){  // string
                                     pNeutro = hb_itemGetCPtr(pAAAAA);
                                     if( !pCaracter ) { // suave
                                        for(pCom=1; pCom<=cRow; pCom++){
                                           PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                           const char * DATO = hb_itemGetCPtr( pBB);
                                           hb_itemRelease( pBB );
                                           if( !pCaseSen ){
                                              if( strcmp( pNeutro, DATO ) != 0 ){
                                                 PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                                 ++nSize;
                                                 hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                                 hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                                 hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                                 hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                                 hb_arrayAdd( pCWM, pC );
                                                 hb_itemRelease( pC );
                                                 break;
                                              }
                                           }else{
                                              if( hb_stricmp(pNeutro, DATO ) != 0 ){
                                                 PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                                 ++nSize;
                                                 hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                                 hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                                 hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                                 hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                                 hb_arrayAdd( pCWM, pC );
                                                 hb_itemRelease( pC );
                                                 break;
                                              }
                                           }
                                        }
                                     }else{  // fuerte
                                        int swTodos=1;
                                        for(pCom=1; pCom<=cRow; pCom++){
                                           PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                           const char * DATO = hb_itemGetCPtr( pBB);
                                           hb_itemRelease( pBB );
                                           if( !pCaseSen ){
                                              if( strcmp( pNeutro, DATO ) == 0 ){
                                                 swTodos=0;
                                                 break;
                                              }
                                           }else{
                                              if( hb_stricmp(pNeutro, DATO ) == 0 ){
                                                 swTodos=0;
                                                 break;
                                              }
                                           }
                                           
                                        }
                                        if( swTodos ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                        }
                                     }
                                  }else{  // numero
                                     nNeutro=hb_itemGetND(pAAAAA);
                                     if( !pCaracter ){  // suavemente
                                        for(pCom=1; pCom<=cRow; pCom++){
                                           PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                           double nDATO = hb_itemGetND( pBB);
                                           hb_itemRelease( pBB );
                                           if( nNeutro != nDATO ){
                                              PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                              ++nSize;
                                              hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                              hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                              hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                              hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                              hb_arrayAdd( pCWM, pC );
                                              hb_itemRelease( pC );
                                              break;
                                           }
                                           
                                        }
                                     }else{  // fuertemente
                                        int swTodos=1;
                                        for(pCom=1; pCom<=cRow; pCom++){
                                           PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                           double nDATO = hb_itemGetND( pBB);
                                           hb_itemRelease( pBB );
                                           if( nNeutro == nDATO ){
                                              swTodos=0;
                                              break;
                                           }
                                           
                                        }
                                        if( swTodos ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                        }
                                     }
                                  }
                                  break;
                               }
                            }  // switch
                            hb_itemRelease( pAAAAA );
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pText;

                HB_SIZE nLen, nSubLen;

                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);

                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);

                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );

                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                            pText = hb_itemGetCPtr( pAAAAA);
                            nLen  = hb_itemGetCLen( pAAAAA);
                            hb_itemRelease( pAAAAA );
                            switch( codfun ){
                               case 7 : // "@"
                               {
                                  if( !pCaracter ){  // suave
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        nSubLen = hb_itemGetCLen( pBB);
                                        const char * DATO = hb_itemGetCPtr( pBB);
                                        hb_itemRelease( pBB );
                                        if( pCaseSen ){
                                           if( hb_striAt( DATO, 
                                                          nSubLen, pText, nLen ) > 0 ){
                                              PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                              ++nSize;
                                              hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                              hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                              hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                              hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                              hb_arrayAdd( pCWM, pC );
                                              hb_itemRelease( pC );
                                              break;
                                           }
                                        }else{
                                           if( hb_strAt( DATO, 
                                                         nSubLen, pText, nLen ) > 0 ){
                                              PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                              ++nSize;
                                              hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                              hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                              hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                              hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                              hb_arrayAdd( pCWM, pC );
                                              hb_itemRelease( pC );
                                              break;
                                           }
                                        }
                                        
                                     }
                                  }else{  // fuerte
                                     int swTodos=1;
                                     for(pCom=1; pCom<=cRow; pCom++){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                        nSubLen = hb_itemGetCLen( pBB);
                                        const char * DATO = hb_itemGetCPtr( pBB);
                                        hb_itemRelease( pBB );
                                        if( pCaseSen ){
                                           if( hb_striAt( DATO , 
                                                          nSubLen, pText, nLen ) == 0 ){
                                              swTodos=0;
                                              break;
                                           }
                                        }else{
                                           if( hb_strAt( DATO, 
                                                         nSubLen, pText, nLen ) == 0 ){
                                              swTodos=0;
                                              break;
                                           }
                                        }
                                     }
                                     if( swTodos ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                               case 8 : // "~@"
                               {
                                  int swTodos=1;
                                  for(pCom=1; pCom<=cRow; pCom++){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pCom);
                                     nSubLen = hb_itemGetCLen( hb_itemArrayGet( pB, pCom ));
                                     const char * DATO = hb_itemGetCPtr( pBB);
                                     hb_itemRelease( pBB );
                                     if( pCaseSen ){
                                        if( hb_striAt( DATO, 
                                                       nSubLen, pText, nLen ) > 0 ){
                                           swTodos=0;
                                           break;
                                        }
                                     }else{
                                        if( hb_strAt( DATO, 
                                                      nSubLen, pText, nLen ) > 0 ){
                                           swTodos=0;
                                           break;
                                        }
                                     }
                                  }
                                  if( swTodos ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                                  break;
                               }
                            }
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
        }
        break;
      }
    }
    hb_itemReturnRelease( pCWM );
}

///XFINDSTK1(TEMPORAL,AX,CX,{DIM,DIMR,DIMC,DIMP,DIMB,OPE,FVWITH,TYP,PCARACTER})
HB_FUNC( XFINDSTK1 )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = ARRAY FUENTE
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = ARRAY O SINGLE A COMPARAR
    PHB_ITEM params   = hb_param( 3, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    PHB_ITEM p8 = hb_itemArrayGet( params, 8);
    PHB_ITEM p9 = hb_itemArrayGet( params, 9);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    int codfun        = hb_itemGetNI( p6 );   // cod funcion
    int pCaseSen      = hb_itemGetNI( p7 );   // Case sensitive
    int pTyp          = hb_itemGetNI( p8 );   // tipo de la mat 
    int pCaracter     = hb_itemGetNI( p9 );   // 1=pB es array, 2=pB es single
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
    hb_itemRelease(p8);
    hb_itemRelease(p9);
    
    PHB_ITEM pCWM = hb_itemArrayNew( 0 ); // CWM
    
    long nSize=0;
    
    switch( pDim ){
      case 1 :
      {
        unsigned int n;
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {
               const char * pNeutro;
               double nNeutro;
               if( pCaracter == 2 ) {
                  if( pTyp == 1){
                     pNeutro = hb_itemGetCPtr( pB );
                  }else{
                     nNeutro = hb_itemGetND( pB );
                  }
               }
               switch( pTyp ){   // tipos a comparar
                  case 1 : // string
                  {
                     for(n=1;n<=pRow;n++){
                        if( pCaracter == 1 ){
                           PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                           pNeutro = hb_itemGetCPtr( pBB );
                           hb_itemRelease( pBB );
                        }
                        if( !pCaseSen ){
                           PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                           if( strcmp(hb_itemGetCPtr(pAA), pNeutro ) == 0 ){
                              hb_arraySize( pCWM, ++nSize );
                              hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                           }
                           hb_itemRelease( pAA );
                        }else{
                           PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                           
                           if( hb_stricmp(hb_itemGetCPtr(pAA), pNeutro ) == 0 ){
                              hb_arraySize( pCWM, ++nSize );
                              hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                           }
                           hb_itemRelease( pAA );
                        }
                     }
                     break;
                  }
                  case 2 : // number
                  {
                     for(n=1;n<=pRow;n++){
                        if( pCaracter == 1 ){
                           PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                           nNeutro = hb_itemGetND( pBB );
                           hb_itemRelease( pBB );
                        }
                        PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       /// printf("\nELEMENTO = %f, NEUTRO=%f \n",hb_itemGetND(pAA),nNeutro);
                        if( hb_itemGetND(pAA) == nNeutro ){
                          /// printf("\nMATCH!!!\n");
                           hb_arraySize( pCWM, ++nSize );
                           hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                        }
                        hb_itemRelease( pAA );
                     }
                     break;
                  }
                  default :{
                     break;
                  }
               }
               break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                const char * pNeutro;
                double nNeutro;
                if( pCaracter == 2 ) {
                   if( pTyp == 1){
                      pNeutro = hb_itemGetCPtr( pB );
                   }else{
                      nNeutro = hb_itemGetND( pB );
                   }
                }
                switch( codfun ){
                   case 2 : // ">"
                   {
                      for(n=1;n<=pRow;n++){
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            nNeutro = hb_itemGetND( pBB );
                            hb_itemRelease( pBB );
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         if( hb_itemGetND(hb_itemArrayGet( pA, n)) > nNeutro ){
                            hb_arraySize( pCWM, ++nSize );
                            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 3 : // "<"
                   {
                      for(n=1;n<=pRow;n++){
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            nNeutro = hb_itemGetND( pBB );
                            hb_itemRelease( pBB );
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         if( hb_itemGetND(pAA) < nNeutro ){
                            hb_arraySize( pCWM, ++nSize );
                            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 4 : // ">="
                   {
                      for(n=1;n<=pRow;n++){
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            nNeutro = hb_itemGetND( pBB );
                            hb_itemRelease( pBB );
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         if( hb_itemGetND(pAA) >= nNeutro ){
                            hb_arraySize( pCWM, ++nSize );
                            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 5 : // "<="
                   {
                      for(n=1;n<=pRow;n++){
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            nNeutro = hb_itemGetND( pBB );
                            hb_itemRelease( pBB );
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         if( hb_itemGetND(pAA) <= nNeutro ){
                            hb_arraySize( pCWM, ++nSize );
                            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 6 : // "<>"
                   {
                      if( pTyp == 1 ){  // string
                         for(n=1;n<=pRow;n++){
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               pNeutro = hb_itemGetCPtr( pBB );
                               hb_itemRelease( pBB );
                            }
                            if( !pCaseSen ){
                               PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                               if( strcmp(hb_itemGetCPtr(pAA), pNeutro ) != 0 ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                               }
                               hb_itemRelease( pAA );
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                               if( hb_stricmp(hb_itemGetCPtr(pAA), pNeutro ) != 0 ){
                                  hb_arraySize( pCWM, ++nSize );
                                  hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                               }
                               hb_itemRelease( pAA );
                            }
                         }
                      }else{  // numero
                         for(n=1;n<=pRow;n++){
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               nNeutro = hb_itemGetND( pBB );
                               hb_itemRelease( pBB );
                            }
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            if( hb_itemGetND(pAA) != nNeutro ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                            hb_itemRelease( pAA );
                         }
                      }
                   }
                }
             }
             break;
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pNeutro, * pText;

                HB_SIZE nLen, nSubLen;
                if( pCaracter == 2 ){
                   pNeutro = hb_itemGetCPtr( pB );
                   nSubLen = hb_itemGetCLen( pB );
                }
                switch( codfun ){
                   case 7 : // "@"
                   {
                      for(n=1;n<=pRow;n++){
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            pNeutro = hb_itemGetCPtr( pBB );
                            nSubLen = hb_itemGetCLen( pBB );
                            hb_itemRelease( pBB );
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         pText = hb_itemGetCPtr( pAA );
                         nLen  = hb_itemGetCLen( pAA );
                         hb_itemRelease( pAA );
                         if( pCaseSen ){
                            if( hb_striAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }else{
                            if( hb_strAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                   case 8 : // "~@"
                   {
                      for(n=1;n<=pRow;n++){
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            pNeutro = hb_itemGetCPtr( pBB );
                            nSubLen = hb_itemGetCLen( pBB );
                            hb_itemRelease( pBB );
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         pText = hb_itemGetCPtr( pAA );
                         nLen  = hb_itemGetCLen( pAA );
                         hb_itemRelease( pAA );
                         if( pCaseSen ){
                            if( hb_striAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }else{
                            if( hb_strAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                               hb_arraySize( pCWM, ++nSize );
                               hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                            }
                         }
                      }
                      break;
                   }
                }
             }
             break;
          }
          case 9 : //"IS" para valores logicos, solo para matriz full y para caracter
          {
             if( pTyp == 3 ) {
                HB_BOOL pValue;
                if( pCaracter == 2 ){
                   pValue = hb_itemGetL( pB );
                }
                for(n=1;n<=pRow;n++){
                   if( pCaracter == 1 ){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      pValue = hb_itemGetL( pBB );
                      hb_itemRelease( pBB );
                   }
                   if( pValue ){ // es true?
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      if( hb_itemGetL(pAA) ){
                         hb_arraySize( pCWM, ++nSize );
                         hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                      }
                      hb_itemRelease( pAA );
                   }else{
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      if( !hb_itemGetL(pAA) ){
                         hb_arraySize( pCWM, ++nSize );
                         hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                      }
                      hb_itemRelease( pAA );
                   }
                }
             }
             break;
          }
          case 10 : case 11: // "nan", "inf"
          {
             if( pTyp == 2 ) {
                if( codfun == 10 ){
                   for(n=1;n<=pRow;n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      if( isnan(hb_itemGetND( pAA )) ){
                         hb_arraySize( pCWM, ++nSize );
                         hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                      }
                      hb_itemRelease( pAA );
                   }
                }else{
                   for(n=1;n<=pRow;n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      if( isinf(hb_itemGetND( pAA )) ){
                         hb_arraySize( pCWM, ++nSize );
                         hb_arraySetNI( pCWM, nSize, (HB_MAXINT) n );
                      }
                      hb_itemRelease( pAA );
                   }
                }
             }
          }
        }
        break;
      }
      case 2 : // 2D
      {

        unsigned int n=1,m=1;

        const char * pNeutro;
        double nNeutro;
        if( pCaracter == 2 ) {
           if( pTyp == 1){
              pNeutro = hb_itemGetCPtr( pB );
           }else{
              nNeutro = hb_itemGetND( pB );
           }
        }
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {  
               switch( pTyp ){   // tipos a comparar
                  case 1 : // string
                  {
                     for( n=1; n<=pRow; n++){
                        PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                        for( m=1; m<=pCol; m++){
                           PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                           
                           if( pCaracter == 1 ){
                              PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                              PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                              pNeutro = hb_itemGetCPtr( pBBB );
                              hb_itemRelease( pBBB );
                              hb_itemRelease( pBB );
                           }
                           if( !pCaseSen ){
                              if( strcmp(hb_itemGetCPtr(pAAA), pNeutro ) == 0 ){
                                 PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                 ++nSize;
                                 hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                 hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                 hb_arrayAdd( pCWM, pC );
                                 hb_itemRelease( pC );
                              }
                           }else{
                              if( hb_stricmp(hb_itemGetCPtr(pAAA), pNeutro ) == 0 ){
                                 PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                 ++nSize;
                                 hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                 hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                 hb_arrayAdd( pCWM, pC );
                                 hb_itemRelease( pC );
                              }
                           }
                           hb_itemRelease( pAAA );
                        }
                        hb_itemRelease( pAA );
                     }
                     break;
                  }
                  case 2 : // number
                  {
                     for( n=1; n<=pRow; n++){
                        PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                        for( m=1; m<=pCol; m++){
                           PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                           if( pCaracter == 1 ){
                              PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                              PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                              nNeutro = hb_itemGetND( pBBB );
                              hb_itemRelease( pBBB );
                              hb_itemRelease( pBB );
                           }
                           
                           if( hb_itemGetND(pAAA) == nNeutro ){
                              PHB_ITEM pC  = hb_itemArrayNew( 2 );
                              ++nSize;
                              hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                              hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                              hb_arrayAdd( pCWM, pC );
                              hb_itemRelease( pC );
                           }
                           hb_itemRelease( pAAA );
                        }
                        hb_itemRelease( pAA );
                     }
                     break;
                  }
                  default :
                  {
                     break;
                  }
               }
               break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                switch( codfun ){
                   case 2 : // ">"
                   {
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         for( m=1; m<=pCol; m++){
                            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               nNeutro = hb_itemGetND( pBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAA) > nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 2 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            hb_itemRelease( pAAA );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 3 : // "<"
                   {
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         for( m=1; m<=pCol; m++){
                            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               nNeutro = hb_itemGetND( pBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAA) < nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 2 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            hb_itemRelease( pAAA );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 4 : // ">="
                   {
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         for( m=1; m<=pCol; m++){
                            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               nNeutro = hb_itemGetND( pBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAA) >= nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 2 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            hb_itemRelease( pAAA );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 5 : // "<="
                   {
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         for( m=1; m<=pCol; m++){
                            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               nNeutro = hb_itemGetND( pBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAA) <= nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 2 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            hb_itemRelease( pAAA );
                         }
                         hb_itemRelease( pAA );
                      }
                      break;
                   }
                   case 6 : // "<>"
                   {
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         for( m=1; m<=pCol; m++){
                            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                            if( pTyp == 1 ){  // string
                               if( pCaracter == 1 ){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                  PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                  pNeutro = hb_itemGetCPtr( pBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                               }
                               if( !pCaseSen ){
                                  if( strcmp(hb_itemGetCPtr(pAAA), pNeutro ) != 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }else{
                                  if( hb_stricmp(hb_itemGetCPtr(pAAA), pNeutro ) != 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                            }else{  // numero
                               if( pCaracter == 1 ){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                  PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                  nNeutro = hb_itemGetND( pBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                               }
                               if( hb_itemGetND(pAAA) != nNeutro ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            hb_itemRelease( pAAA );
                         }
                         hb_itemRelease( pAA );
                      }
                   }
                }
             }
             break;
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pText;

                HB_SIZE nLen, nSubLen;
                if( pCaracter == 2 ){
                   pNeutro = hb_itemGetCPtr( pB );
                   nSubLen = hb_itemGetCLen( pB );
                }
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      
                      if( pCaracter == 1 ){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         pNeutro = hb_itemGetCPtr( pBBB );
                         nSubLen = hb_itemGetCLen( pBBB );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pBB );
                      }
                      pText = hb_itemGetCPtr( pAAA );
                      nLen  = hb_itemGetCLen( pAAA );
                      switch( codfun ){
                         case 7 : // "@"
                         {
                            if( pCaseSen ){
                               if( hb_striAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }else{
                               if( hb_strAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                         case 8 : // "~@"
                         {
                            if( pCaseSen ){
                               if( hb_striAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }else{
                               if( hb_strAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 2 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                      }  // switch
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 9 : //"IS" para valores logicos, solo para matriz full y para caracter
          {
             if( pTyp == 3 ){
                HB_BOOL pValue;
                
                if( pCaracter == 2 ){
                   pValue = hb_itemGetL( pB );
                }
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      
                      if( pCaracter == 1 ){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         pValue = hb_itemGetL( pBBB );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pBB );
                      }
                      if( pValue ){ // es true?
                         if( hb_itemGetL(pAAA) ){
                            PHB_ITEM pC  = hb_itemArrayNew( 2 );
                            ++nSize;
                            hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                            hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                            hb_arrayAdd( pCWM, pC );
                            hb_itemRelease( pC );
                         }
                      }else{
                         if( !hb_itemGetL(pAAA) ){
                            PHB_ITEM pC  = hb_itemArrayNew( 2 );
                            ++nSize;
                            hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                            hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                            hb_arrayAdd( pCWM, pC );
                            hb_itemRelease( pC );
                         }
                      }
                      hb_itemRelease( pAAA );
                      
                   }
                   hb_itemRelease( pAA );
                   
                }
             }
             break;
          }
          case 10 : case 11: // "nan", "inf"
          {
             if( pTyp == 2 ){
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      if( codfun == 10 ){
                         if( isnan(hb_itemGetND( pAAA )) ){
                            PHB_ITEM pC  = hb_itemArrayNew( 2 );
                            ++nSize;
                            hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                            hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                            hb_arrayAdd( pCWM, pC );
                            hb_itemRelease( pC );
                         }
                      }else{
                         if( isinf(hb_itemGetND( pAAA )) ){
                            PHB_ITEM pC  = hb_itemArrayNew( 2 );
                            ++nSize;
                            hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                            hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                            hb_arrayAdd( pCWM, pC );
                            hb_itemRelease( pC );
                         }
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
          }
        }
        break;
      }
      case 3 : // 3D
      {       
               
        unsigned int n=1,m=1,o=1;

        const char * pNeutro;
        double nNeutro;
        if( pCaracter == 2 ) {
           if( pTyp == 1){
              pNeutro = hb_itemGetCPtr( pB );
           }else{
              nNeutro = hb_itemGetND( pB );
           }
        }
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {  
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                      
                      switch( pTyp ){   // tipos a comparar
                         case 1 : // string
                         {
                            if( pCaracter == 1 ){
                                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                pNeutro = hb_itemGetCPtr( pBBBB );
                                hb_itemRelease( pBBBB );
                                hb_itemRelease( pBBB );
                                hb_itemRelease( pBB );
                            }
                            if( !pCaseSen ){
                              if( strcmp(hb_itemGetCPtr(pAAAA), pNeutro ) == 0 ){
                                 PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                 ++nSize;
                                 hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                 hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                 hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                 hb_arrayAdd( pCWM, pC );
                                 hb_itemRelease( pC );
                              }
                            }else{
                              if( hb_stricmp(hb_itemGetCPtr(pAAAA), pNeutro ) == 0 ){
                                 PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                 ++nSize;
                                 hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                 hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                 hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                 hb_arrayAdd( pCWM, pC );
                                 hb_itemRelease( pC );
                              }
                            }
                            break;
                         }
                         case 2 : // number
                         {
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               nNeutro = hb_itemGetND( pBBBB );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAAA) == nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            break;
                         }
                         default : {
                            break;
                         }
                      }
                      hb_itemRelease( pAAAA );
                   }
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                      switch( codfun ){
                         case 2 : // ">"
                         {
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               nNeutro = hb_itemGetND( pBBBB);
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAAA) > nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            break;
                         }
                         case 3 : // "<"
                         {
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               nNeutro = hb_itemGetND( pBBBB );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            
                            if( hb_itemGetND(pAAAA) < nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            break;
                         }
                         case 4 : // ">="
                         {
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               nNeutro = hb_itemGetND( pBBBB);
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAAA) >= nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            break;
                         }
                         case 5 : // "<="
                         {
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               nNeutro = hb_itemGetND( pBBBB );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( hb_itemGetND(pAAAA) <= nNeutro ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                            break;
                         }
                         case 6 : // "<>"
                         {
                            if( pTyp == 1 ){  // string
                               if( pCaracter == 1 ){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                  PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                  PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                  pNeutro = hb_itemGetCPtr( pBBBB );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                               }
                               if( !pCaseSen ){
                                  if( strcmp(hb_itemGetCPtr(pAAAA), pNeutro ) != 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }else{
                                  if( hb_stricmp(hb_itemGetCPtr(pAAAA), pNeutro ) != 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                            }else{  // numero
                               if( pCaracter == 1 ){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                  PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                  PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                  nNeutro = hb_itemGetND( pBBBB );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                               }
                               if( hb_itemGetND(pAAAA) != nNeutro ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            break;
                         }
                      }
                      hb_itemRelease( pAAAA );
                   }
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pText;

                HB_SIZE nLen, nSubLen;
                if( pCaracter == 2 ){
                   pNeutro = hb_itemGetCPtr( pB );
                   nSubLen = hb_itemGetCLen( pB );
                }
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                            pNeutro = hb_itemGetCPtr( pBBBB );
                            nSubLen = hb_itemGetCLen( pBBBB );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pBB );
                         }
                         pText = hb_itemGetCPtr( pAAAA );
                         nLen  = hb_itemGetCLen( pAAAA );
                         switch( codfun ){
                            case 7 : // "@"
                            {
                               if( pCaseSen ){
                                  if( hb_striAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }else{
                                  if( hb_strAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 8 : // "~@"
                            {
                               if( pCaseSen ){
                                  if( hb_striAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }else{
                                  if( hb_strAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 3 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 9 : //"IS" para valores logicos, solo para matriz full y para caracter
          {
             if( pTyp == 3 ){
                HB_BOOL pValue;
                
                if( pCaracter == 2 ){
                   pValue = hb_itemGetL( pB );
                }
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         if( pCaracter == 1 ){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                            PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                            pValue = hb_itemGetL( pBBBB );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pBB );
                         }
                         if( pValue ){ // es true?
                            if( hb_itemGetL(pAAAA) ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                         }else{
                            if( !hb_itemGetL(pAAAA) ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 10 : case 11: // "nan", "inf"
          {
             if( pTyp == 2 ){
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         if( codfun == 10 ){
                            if( isnan(hb_itemGetND( pAAAA )) ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                         }else{
                            if( isinf(hb_itemGetND( pAAAA )) ){
                               PHB_ITEM pC  = hb_itemArrayNew( 3 );
                               ++nSize;
                               hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                               hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                               hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                               hb_arrayAdd( pCWM, pC );
                               hb_itemRelease( pC );
                            }
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
          }
        }
        break;
      }
      case 4 : // 4D
      {
               
        unsigned int n=1,m=1,o=1,p=1;

        const char * pNeutro;
        double nNeutro;
        if( pCaracter == 2 ) {
           if( pTyp == 1){
              pNeutro = hb_itemGetCPtr( pB );
           }else{
              nNeutro = hb_itemGetND( pB );
           }
        }
        
        switch( codfun ){  // operaciones de comparacion
          case 1 : // "="
          {  
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                         switch( pTyp ){   // tipos a comparar
                            case 1 : // string
                            {
                               if( pCaracter == 1 ){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                  PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                  PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                  PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                  pNeutro = hb_itemGetCPtr( pBBBBB );
                                  hb_itemRelease( pBBBBB );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                               }
                               if( !pCaseSen ){
                                  if( strcmp(hb_itemGetCPtr(pAAAAA), pNeutro ) == 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }else{
                                  if( hb_stricmp(hb_itemGetCPtr(pAAAAA), pNeutro ) == 0 ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                               }
                               break;
                            }
                            case 2 : // number
                            {
                               if( pCaracter == 1 ){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                  PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                  PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                  PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                  nNeutro = hb_itemGetND( pBBBBB );
                                  hb_itemRelease( pBBBBB );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                               }
                               if( hb_itemGetND(pAAAAA) == nNeutro ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                               break;
                            }
                            default : {
                               break;
                            }
                         }
                         hb_itemRelease( pAAAAA );
                      }
                      hb_itemRelease( pAAAA );
                   }
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 : case 3 : case 4 : case 5 : case 6 : // ">,<,>=,<=,<>"
          {
             if( pTyp==3 || (pTyp == 1 && codfun != 6) ) nSize = 0;  // deben ser numeros.
             else{
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                            switch( codfun ){
                               case 2 : // ">"
                               {
                                  if( pCaracter == 1 ){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                     PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                     PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                     PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                     nNeutro = hb_itemGetND( pBBBBB );
                                     hb_itemRelease( pBBBBB );
                                     hb_itemRelease( pBBBB );
                                     hb_itemRelease( pBBB );
                                     hb_itemRelease( pBB );
                                  }
                                  if( hb_itemGetND(pAAAAA) > nNeutro ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                                  break;
                               }
                               case 3 : // "<"
                               {
                                  if( pCaracter == 1 ){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                     PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                     PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                     PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                     nNeutro = hb_itemGetND( pBBBBB );
                                     hb_itemRelease( pBBBBB );
                                     hb_itemRelease( pBBBB );
                                     hb_itemRelease( pBBB );
                                     hb_itemRelease( pBB );
                                  }
                                  if( hb_itemGetND(pAAAAA) < nNeutro ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                                  break;
                               }
                               case 4 : // ">="
                               {
                                  if( pCaracter == 1 ){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                     PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                     PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                     PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                     nNeutro = hb_itemGetND( pBBBBB );
                                     hb_itemRelease( pBBBBB );
                                     hb_itemRelease( pBBBB );
                                     hb_itemRelease( pBBB );
                                     hb_itemRelease( pBB );
                                  }
                                  if( hb_itemGetND(pAAAAA) >= nNeutro ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                                  break;
                               }
                               case 5 : // "<="
                               {
                                  if( pCaracter == 1 ){
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                     PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                     PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                     PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                     nNeutro = hb_itemGetND( pBBBBB );
                                     hb_itemRelease( pBBBBB );
                                     hb_itemRelease( pBBBB );
                                     hb_itemRelease( pBBB );
                                     hb_itemRelease( pBB );
                                  }
                                  if( hb_itemGetND(pAAAAA) <= nNeutro ){
                                     PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                     ++nSize;
                                     hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                     hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                     hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                     hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                     hb_arrayAdd( pCWM, pC );
                                     hb_itemRelease( pC );
                                  }
                                  break;
                               }
                               case 6 : // "<>"
                               {
                                  if( pTyp == 1 ){  // string
                                     if( pCaracter == 1 ){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                        PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                        PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                        PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                        pNeutro = hb_itemGetCPtr( pBBBBB );
                                        hb_itemRelease( pBBBBB );
                                        hb_itemRelease( pBBBB );
                                        hb_itemRelease( pBBB );
                                        hb_itemRelease( pBB );
                                     }
                                     if( !pCaseSen ){
                                        if( strcmp(hb_itemGetCPtr(pAAAAA), pNeutro ) != 0 ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                        }
                                     }else{
                                        if( hb_stricmp(hb_itemGetCPtr(pAAAAA), pNeutro ) != 0 ){
                                           PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                           ++nSize;
                                           hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                           hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                           hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                           hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                           hb_arrayAdd( pCWM, pC );
                                           hb_itemRelease( pC );
                                        }
                                     }
                                  }else{  // numero
                                     if( pCaracter == 1 ){
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                                        PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                                        PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                                        PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                                        nNeutro = hb_itemGetND( pBBBBB );
                                        hb_itemRelease( pBBBBB );
                                        hb_itemRelease( pBBBB );
                                        hb_itemRelease( pBBB );
                                        hb_itemRelease( pBB );
                                     }
                                     if( hb_itemGetND(pAAAAA) != nNeutro ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                               }
                            }
                            hb_itemRelease( pAAAAA );
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 7 : case 8 : // "@", "~@"
          {
             if( pTyp == 1 ){
                const char * pText;

                HB_SIZE nLen, nSubLen;
                if( pCaracter == 2 ){
                   pNeutro = hb_itemGetCPtr( pB );
                   nSubLen = hb_itemGetCLen( pB );
                }
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                               pNeutro = hb_itemGetCPtr( pBBBBB );
                               nSubLen = hb_itemGetCLen( pBBBBB );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            pText = hb_itemGetCPtr( pAAAAA );
                            nLen  = hb_itemGetCLen( pAAAAA );
                            switch( codfun ){
                               case 7 : // "@"
                               {
                                  if( pCaseSen ){
                                     if( hb_striAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }else{
                                     if( hb_strAt( pNeutro, nSubLen, pText, nLen ) > 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                               case 8 : // "~@"
                               {
                                  if( pCaseSen ){
                                     if( hb_striAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }else{
                                     if( hb_strAt( pNeutro, nSubLen, pText, nLen ) == 0 ){
                                        PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                        ++nSize;
                                        hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                        hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                        hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                        hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                        hb_arrayAdd( pCWM, pC );
                                        hb_itemRelease( pC );
                                     }
                                  }
                                  break;
                               }
                            }
                            hb_itemRelease( pAAAAA );
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 9 : //"IS" para valores logicos, solo para matriz full y para caracter
          {
             if( pTyp == 3 ){
                HB_BOOL pValue;
                
                if( pCaracter == 2 ){
                   pValue = hb_itemGetL( pB );
                }
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                            if( pCaracter == 1 ){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                               PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                               PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o );
                               PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p );
                               pValue = hb_itemGetL( pBBBBB );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pBB );
                            }
                            if( pValue ){ // es true?
                               if( hb_itemGetL(pAAAAA) ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }else{
                               if( !hb_itemGetL(pAAAAA) ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            hb_itemRelease( pAAAAA );
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 10 : case 11: // "nan", "inf"
          {
             if( pTyp == 2 ){
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o );
                         
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p );
                            if( codfun == 10 ){
                               if( isnan(hb_itemGetND( pAAAAA )) ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }else{
                               if( isinf(hb_itemGetND( pAAAAA )) ){
                                  PHB_ITEM pC  = hb_itemArrayNew( 4 );
                                  ++nSize;
                                  hb_arraySetNI( pC, 1, (HB_MAXINT) n );
                                  hb_arraySetNI( pC, 2, (HB_MAXINT) m );
                                  hb_arraySetNI( pC, 3, (HB_MAXINT) o );
                                  hb_arraySetNI( pC, 4, (HB_MAXINT) p );
                                  hb_arrayAdd( pCWM, pC );
                                  hb_itemRelease( pC );
                               }
                            }
                            hb_itemRelease( pAAAAA );
                         }
                         hb_itemRelease( pAAAA );
                      }
                      hb_itemRelease( pAAA );
                   }
                   hb_itemRelease( pAA );
                }
             }
          }
        }
      }
    }
    hb_itemReturnRelease( pCWM );
}

int xu_minimo(int m1, int m2){
   
   return m1<=m2?m1:m2;
}

/* WIKIPEDIA */
int Levenshtein(const char *s1, const char *s2)
{   int t1,t2,i,j,*m,costo,res,ancho;

// Calcula tamanios strings 
    t1=strlen(s1); t2=strlen(s2);

// Verifica que exista algo que comparar
    if (t1==0) return(t2);
    if (t2==0) return(t1);
    ancho=t1+1;

// Reserva matriz con malloc                     m[i,j] = m[j*ancho+i] !!
    m=(int*)malloc(sizeof(int)*(t1+1)*(t2+1));
    if (m==NULL) return(-1); // ERROR!!

// Rellena primera fila y primera columna
    for (i=0;i<=t1;i++) m[i]=i;
    for (j=0;j<=t2;j++) m[j*ancho]=j;

// Recorremos resto de la matriz llenando pesos
    for (i=1;i<=t1;i++) 
       for (j=1;j<=t2;j++)
       { if (s1[i-1]==s2[j-1]) costo=0; else costo=1;
         m[j*ancho+i]=xu_minimo(xu_minimo(m[j*ancho+i-1]+1,     // Eliminacion 
                        m[(j-1)*ancho+i]+1),              // Insercion   
                        m[(j-1)*ancho+i-1]+costo); }      // Sustitucion 

// Devolvemos esquina final de la matriz
    res=m[t2*ancho+t1];
    free(m);
    return(res);
}

// XU_STRDIFF(DX,CX,BX)
HB_FUNC( XU_STRDIFF )
{
   const char * pSTRING = hb_parc( 1 );  // string a comparar
   const char * pSTRBIG = hb_parc( 2 );  // gran string
   unsigned int pOffset = hb_parni( 3 );   // desplazamiento
   
   PHB_ITEM pCWM = NULL;
   long nSize=0;
   unsigned int i=0;
   const char * t, * r; 
   
   t = pSTRBIG;
   r = pSTRBIG;
   unsigned long lf = strlen(pSTRING);
   unsigned long ln = strlen(pSTRBIG);
   pOffset = ( pOffset>0 ? pOffset : 1 );
   if (lf <= ln){
      unsigned int offset = (int) (ln / pOffset);
      pCWM = hb_itemArrayNew( 0 ); // CWM
      for(i=1;i<=offset; i++){
         
         if(lf <= strlen(t) ){
            char * pTEXTO = (char *) calloc(lf+1,1);
            unsigned long j=0;
            while(j < lf) {
               pTEXTO[j++] = *r; r++;
            }
            pTEXTO[lf]='\0';
            int nLev = Levenshtein(pSTRING, pTEXTO);
            //
            
            hb_arraySize( pCWM, ++nSize );
            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) nLev );
            //
            free(pTEXTO);
            t = t + pOffset;
            r = t;
         }else {
            hb_arraySize( pCWM, ++nSize );
            hb_arraySetNI( pCWM, nSize, (HB_MAXINT) ( lf-(lf-strlen(t)) ) );
            break;
         }
      }
   }
   hb_itemReturnRelease( pCWM );
}

char * fun_xmask(const char *formato, const char *car, const char *numero) {
   char *buffer, *pBuf;

   int16_t lf = strlen(formato);
   int16_t ln = strlen(numero); 

   pBuf = (char *)calloc(lf+1,1); //sizeof(char)*(lf+1));
   if (pBuf==NULL) return NULL;

   buffer = pBuf;
   int16_t i=lf, k=lf; 

   char c; 
   --lf; --ln; --k;
   while (lf>=0 && ln>=0) {
      c = formato[lf];
      if (c=='#') buffer[k] = numero[ln--]; 
      else buffer[k] = c;
      --k;
      --lf;
   }
   while (lf>=0) {
      c = formato[lf];
      if (*car) {
         if (c=='#') buffer[k] = *car;
         else buffer[k] = c;
      } else {
         buffer[k] = ' ';
      }
      --lf;
      --k;
   }
   buffer[i]='\0';
  
   return pBuf;
}

char *fun_xmoney (double numero, const char *tipo, const char *cblanc, uint16_t decimales, uint16_t pad){
   char *buf,*buffer,*cnum,*Retnum;
   const char * d, * s;
   uint16_t isize=0, ipart=0, iresto=0, tpad=0, swSign=0, swDec=0;

   buffer = (char *)calloc (32,1); //sizeof(char *) * 24);
   if (buffer==NULL) return NULL;

   buf = buffer;
   
   if( numero < 0 ) {
   	   swSign=1;
   	   numero *= -1;
   }

   uint16_t size = sprintf(buf,"%.*lf",decimales, numero);

   if (decimales>0) {
      d = strstr(buf,".");
      if (d!=NULL) {
         isize = d - buf;  // obtengo parte entera.
         d++;   // tendrá el decimal
         swDec=1;
      } else isize = size;
   } else isize = size;

   int limite = swDec?size-(decimales+1):size;
   iresto = limite > 3 ? isize % 3:0;   // cuantos dígitos sobran
   ipart = (uint16_t) isize / 3; // cuántas particiones debo efectuar; ipart-1=núm de sep
   tpad = isize+(ipart-1)+decimales+2+strlen(tipo)+swSign;

 //  printf("\n**** [%s],len=%lu,size=%d, limite=%d, tpad=%d ****\n",buf,strlen(buf),size,limite,tpad);

   uint16_t blancos=0;

   if (pad < tpad) {
       pad = tpad;
   } else {
       blancos = pad - tpad;
      // if (isize%2!=0) ++blancos;
       if (decimales==0) ++blancos; // por el punto decimal
   }

   Retnum = (char *)calloc(pad+1,1); //sizeof(char *)*(pad+1));
   if (Retnum==NULL) return NULL;
   cnum = Retnum;
   
   strcpy(cnum,tipo);
   uint16_t i;

   for (i=0;i<blancos;i++) strncat(cnum,cblanc,strlen(cblanc));

   if( swSign ) strcat(cnum,"-");

   s = buf;

   // agrego el resto, de existir
   if (iresto>0) {
      strncat(cnum,s,iresto);
      strcat(cnum,",");
      s += iresto;  // avanza el puntero
   }
   // agrego la parte entera
   if (limite >= 3){
      for (i=0;i<ipart; i++) {
         strncat(cnum,s,3);
         if (i<ipart-1) strcat(cnum,",");
         s += 3;
      }
   }else{
      strncat(cnum,s,limite);
      s += limite;
   }
   if (decimales>0) {
      strcat(cnum,".");
      strncat(cnum,d,strlen(d));
   }
   cnum[strlen(cnum)]='\0';
   free(buf);

   return Retnum;
}

HB_FUNC( XFUNMONEY )
{
    double pA = hb_parnd( 1 ); // A = DOUBLE
    PHB_ITEM pB = hb_param( 2, HB_IT_STRING ); // B = TIPO MONEDA
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = RELLENO
    int pE = hb_parni( 4 ); // E = DECIMALES
    int pF = hb_parni( 5 ); // F = ANCHO PAD
    
    char * pBuffer, * pRet;
    pBuffer = (char *)fun_xmoney(pA, hb_itemGetCPtr( pB ), 
                                 hb_itemGetCPtr( pD ), pE, pF);
    if( pBuffer != NULL ){
       hb_retc( pBuffer );
    }else{
       pRet = (char*)calloc(2,1);
       strcpy(pRet,"0");
       hb_retc( pRet );
       free(pRet);
    }
    free(pBuffer);
}

HB_FUNC( XFUNMASK )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_STRING ); // A = STRING 
    PHB_ITEM pB = hb_param( 2, HB_IT_STRING ); // B = MASCARA
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = CARACTER DE RELLENO
    
    char * pBuffer;
    pBuffer = (char *)fun_xmask(hb_itemGetCPtr( pB ), hb_itemGetCPtr( pD ), 
                               hb_itemGetCPtr( pA ) );
    if( pBuffer != NULL ){
       hb_retc( pBuffer );
    }else{
       // si no hay memoria, devuelve el mismo string
       hb_retc( hb_itemGetCPtr( pA ) );
    }
    free(pBuffer);
}

HB_FUNC( XMONEY )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // ARRAY  
    PHB_ITEM pB = hb_param( 2, HB_IT_STRING ); // B = TIPO MONEDA
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = RELLENO
    int pE = hb_parni( 4 ); // E = DECIMALES
    int pF = hb_parni( 5 ); // F = ANCHO PAD
    PHB_ITEM params   = hb_param( 6, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    
    PHB_ITEM pCWM = NULL;
        
    int strOk=1;
    
    const char * pTipo, * pCar; 
    
    pTipo = hb_itemGetCPtr( pB );
    pCar  = hb_itemGetCPtr( pD );
    switch( pDim ){
       case 1 : 
       {
          unsigned int n=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             char * pBuffer = (char *)fun_xmoney(hb_itemGetND( pAA ), pTipo, 
                              pCar, pE, pF);
             hb_itemRelease(pAA);
             const char * buff=pBuffer;
             if( buff != NULL ){
                hb_arraySetC( pCWM, n, buff );
             }else{
                strOk = 0;
                break;
             }
             free(pBuffer);
          }
          break;
       }
       case 2 : 
       {
          unsigned int n=1,m=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                char * pBuffer = (char *)fun_xmoney(hb_itemGetND( pAAA), pTipo, 
                                          pCar, pE, pF);
                hb_itemRelease(pAAA);
                const char * buff=pBuffer;
                if ( buff != NULL ){ 
                   hb_arraySetC( pCC, m, (const char *) buff );
                }else{
                   strOk = 0;
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                   break;
                }
                free(pBuffer);
             }
             if( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 3:
       {
          unsigned int n=1,m=1,o=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   char * pBuffer = (char *)fun_xmoney(hb_itemGetND( pAAAA ), pTipo, 
                                          pCar, pE, pF);
                   hb_itemRelease(pAAAA);
                   const char * buff=pBuffer;
                   if ( buff != NULL ){ 
                      hb_arraySetC( pCCC, o, (const char *) buff );
                   }else{
                      strOk = 0;
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                      break;
                   }
                   free(pBuffer);
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);   
          }
          break;
       }
       case 4:
       {
          unsigned int n=1,m=1,o=1,p=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      char * pBuffer = (char *)fun_xmoney(hb_itemGetND( pAAAAA ), pTipo, 
                                          pCar, pE, pF);
                      hb_itemRelease(pAAAAA);
                      const char * buff=pBuffer;
                      if ( buff != NULL ){ 
                         hb_arraySetC( pCCCC, p, (const char *) buff );
                      }else{
                         strOk = 0;
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                         hb_itemRelease(pAA);
                         hb_itemRelease(pCC);
                         break;
                      }
                      free(pBuffer);
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pCCCC);   
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

/*
  DESPLIEGUE CON PRECISION. FUNCION INTERNA DE WRITE Y SHOW
*/
char * xu_num2string(double dNum, int Dec){
  char *buf;
  int size;
  buf=(char *)calloc(64,1);
  size = sprintf(buf,"%.*lf",Dec, dNum);
  return(buf);
}

HB_FUNC( XFUNNUM2STRING )
{
  double numero = hb_parnd( 1 );
  int    decimal= hb_parni( 2 );
  char * Retorno = (char*)calloc(64,1);
  char * nDev=xu_num2string(numero,decimal);
  strcpy(Retorno, nDev );
  hb_retc( Retorno );
  free(Retorno);
  free(nDev);
}

/*
  PRECISION NUMERICA. HARBOUR MANEJA ESTO, PERO SOLO A NIVEL DE VARIABLE SIMPLE
*/
double xu_funprecision(double dNum, int Dec){
  char *buf; //*t;
  int size;
  double m;
  buf=(char *)calloc(64,1);
  size = sprintf(buf,"%.*lf",Dec, dNum);
  
  sscanf(buf, "%lf", &m);
  //m=strtod(buf,&t);
  free(buf);
  return(m);
}

// PRESICION EN ARRAYS
HB_FUNC( XFUNMATPREC )
{
    PHB_ITEM pA   = hb_param( 1, HB_IT_ARRAY ); // ARRAY
    int    decimal= hb_parni( 2 ); // precision
    PHB_ITEM params   = hb_param( 3, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    
    PHB_ITEM pCWM = NULL;

    //xu_funprecision(numero, decimal)
    
    switch( pDim ){
       case 1 : 
       {
          unsigned int n=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetND( pCWM, n, 
                  (double) xu_funprecision(hb_itemGetND( pAA ),decimal) );
             hb_itemRelease(pAA);
          }
          break;
       }
       case 2 : 
       {
          unsigned int n=1,m=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                hb_arraySetND( pCC, m, 
                  (double) xu_funprecision(hb_itemGetND( pAAA ),decimal) );
                hb_itemRelease(pAAA);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 3:
       {
          unsigned int n=1,m=1,o=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   hb_arraySetND( pCCC, o, 
                      (double) xu_funprecision(hb_itemGetND( pAAAA ),decimal) );
                   hb_itemRelease(pAAAA);
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 4:
       {
          unsigned int n=1,m=1,o=1,p=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      hb_arraySetND( pCCCC, p, 
                         (double) xu_funprecision(hb_itemGetND( pAAAAA ),decimal) );
                      hb_itemRelease(pAAAAA);
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pCCCC);   
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
    }
    hb_itemReturnRelease( pCWM );
}

// PRECISION EN ESCALAR
HB_FUNC( XFUNEPREC )
{
  double numero = hb_parnd( 1 );
  int    decimal= hb_parni( 2 );
  
  hb_retnd(xu_funprecision(numero, decimal));  
}


/// XMASK(TEMPORAL, BX, AX,{ DIM1R,DIM1C,DIM1P,DIM1B})
HB_FUNC( XMASK )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = STRING O ARRAY DE STRING
    PHB_ITEM pB = hb_param( 2, HB_IT_STRING ); // B = MASCARA
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = CARACTER DE RELLENO
    PHB_ITEM params   = hb_param( 4, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    
    int strOk=1;

    PHB_ITEM pCWM = NULL;
    
    const char * pMask, * pCar; 
    
    pMask = hb_itemGetCPtr( pB );
    pCar  = hb_itemGetCPtr( pD );
    switch( pDim ){
       case 1 : 
       {
          unsigned int n=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             char * pBuffer = (char *)fun_xmask(pMask, pCar, 
                               hb_itemGetCPtr( pAA ) );
             hb_itemRelease(pAA);
             if( pBuffer != NULL ){
                hb_arraySetC( pCWM, n, (const char *) pBuffer );
                free(pBuffer);
             }else{
                strOk = 0;
                break;
             }
          }
          break;
       }
       case 2 : 
       {
          unsigned int n=1,m=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                char * pBuffer = (char *)fun_xmask(pMask, pCar,
                               hb_itemGetCPtr( pAAA ) );
                hb_itemRelease(pAAA);
                if ( pBuffer != NULL ){ 
                   hb_arraySetC( pCC, m, (const char *) pBuffer );
                   free(pBuffer);
                }else{
                   strOk = 0;
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                   break;
                }
             }
             if( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 3:
       {
          unsigned int n=1,m=1,o=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   char * pBuffer = (char *)fun_xmask(pMask, pCar,
                               hb_itemGetCPtr( pAAAA ) );
                   hb_itemRelease(pAAAA);
                   if ( pBuffer != NULL ){ 
                      hb_arraySetC( pCCC, o, (const char *) pBuffer );
                      free(pBuffer);
                   }else{
                      strOk = 0;
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                      break;
                   }
                }
                if( !strOk ) break;
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             if( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 4:
       {
          unsigned int n=1,m=1,o=1,p=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      char * pBuffer = (char *)fun_xmask(pMask, pCar,
                               hb_itemGetCPtr( pAAAAA ) );
                      hb_itemRelease(pAAAAA);
                      if ( pBuffer != NULL ){ 
                         hb_arraySetC( pCCCC, p, (const char *) pBuffer );
                         free(pBuffer);
                      }else{
                         strOk = 0;
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                         hb_itemRelease(pAA);
                         hb_itemRelease(pCC);
                         break;
                      }
                   }
                   if( !strOk ) break;
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pCCCC);
                } 
                if( !strOk ) break;
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             if( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
} 


/*
 * CT3 Date & Time functions: - BoM() / EoM()
 *                              - BoQ() / EoQ()
 *                              - BoY() / EoY()
 *                              - WoM()
 *
 * Copyright 2005 Pavel Tsarenko <tpe2@mail.ru>
 */

static HB_BOOL ct_isleap( int iYear )
{
   return iYear != 0 && ( ( ( iYear & 3 ) == 0 && iYear % 100 != 0 ) ||
                          iYear % 400 == 0 );
}

static int ct_daystomonth( int iMonth, HB_BOOL bLeap )
{
   static const int sc_iMonths[] = {
      0, 31, 59, 90, 120, 151, 181, 212, 243, 273, 304, 334 };

   return ( iMonth < 1 || iMonth > 12 ) ? 0 : sc_iMonths[ iMonth - 1 ] +
          ( ( bLeap && iMonth > 2 ) ? 1 : 0 );
}

static int ct_doy( long lDate )
{
   int iYear, iMonth, iDay;
   long lFirst;

   hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
   lFirst = hb_dateEncode( iYear, 1, 1 );
   return ( int ) ( lDate - lFirst + 1 );
}

HB_FUNC( QUARTER )
{
   int iYear, iMonth, iDay;

   if( HB_ISDATETIME( 1 ) )
      hb_dateDecode( hb_pardl( 1 ), &iYear, &iMonth, &iDay );
   else
      hb_dateToday( &iYear, &iMonth, &iDay );

   hb_retni( ( iMonth + 2 ) / 3 );
}

HB_FUNC( XBOQ )
{
   long lDate;
   int iYear, iMonth, iDay;

   if( HB_ISNIL( 1 ) )
   {
      hb_dateToday( &iYear, &iMonth, &iDay );
      lDate = hb_dateEncode( iYear, iMonth, iDay );
   }
   else
      lDate = hb_pardl( 1 );

   if( lDate != 0 )
   {
      hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
      iMonth -= ( iMonth - 1 ) % 3;

      hb_retd( iYear, iMonth, 1 );
   }
   else
      hb_retdl( 0 );
}

HB_FUNC( XEOQ )
{
   long lDate;
   int iYear, iMonth, iDay;

   if( HB_ISNIL( 1 ) )
   {
      hb_dateToday( &iYear, &iMonth, &iDay );
      lDate = hb_dateEncode( iYear, iMonth, iDay );
   }
   else
      lDate = hb_pardl( 1 );

   if( lDate != 0 )
   {
      hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
      iMonth += 3 - ( ( iMonth - 1 ) % 3 );
      if( iMonth > 12 )
      {
         iMonth = 1;
         iYear++;
      }
      hb_retdl( hb_dateEncode( iYear, iMonth, 1 ) - 1 );
   }
   else
      hb_retdl( 0 );
}

HB_FUNC( XDOY )
{
   long lDate;

   if( HB_ISDATETIME( 1 ) )
      lDate = hb_pardl( 1 );
   else
   {
      int iYear, iMonth, iDay;

      hb_dateToday( &iYear, &iMonth, &iDay );
      lDate = hb_dateEncode( iYear, iMonth, iDay );
   }

   hb_retni( ct_doy( lDate ) );
}

static int ct_daysinmonth( int iMonth, HB_BOOL bLeap )
{
   if( iMonth == 2 )
      return bLeap ? 29 : 28;
   else if( iMonth == 4 || iMonth == 6 || iMonth == 9 || iMonth == 11 )
      return 30;
   else
      return 31;
}

HB_FUNC( XDAYSINMONTH )
{
   int iMonth = hb_parni( 1 );
   HB_BOOL bLeap = hb_parl( 2 );

   hb_retni( ct_daysinmonth( iMonth, bLeap ) );
}

HB_FUNC( XWEEK )
{
   int iYear, iMonth, iDay, iWeek;
   long lDate;
   HB_BOOL bSWN = hb_parl( 2 );

   if( HB_ISDATETIME( 1 ) )
   {
      lDate = hb_pardl( 1 );
      hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
   }
   else
   {
      hb_dateToday( &iYear, &iMonth, &iDay );
      lDate = hb_dateEncode( iYear, iMonth, iDay );
   }

   if( ! lDate )
   {
      iWeek = 0;
   }
   else if( bSWN )
   {
      int iDays = ct_daystomonth( iMonth, ct_isleap( iYear ) ) + iDay;
      int iPart = ( iDays % 7 );

      iWeek = iDays / 7;
      if( iPart > 0 )
         iWeek++;
   }
   else
   {
      long lDate2;

      if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
         lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
      else
         lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );

      iWeek = ( ct_doy( lDate2 ) - 1 ) / 7 + 1;
   }

   hb_retni( iWeek );
}

static HB_BOOL _hb_timeValid( const char * szTime, HB_SIZE nLen, int * piDecode )
{
   HB_BOOL fValid = HB_FALSE;

   if( nLen == 2 || nLen == 5 || nLen == 8 || nLen == 11 )
   {
      static const int sc_iMax[] = { 23, 59, 59, 99 };
      int     i, iVal;
      HB_SIZE ul;

      fValid = HB_TRUE;
      for( ul = 0; fValid && ul < nLen; ++ul )
      {
         fValid = ul % 3 == 2 ? szTime[ ul ] == ':' :
                  ( szTime[ ul ] >= '0' && szTime[ ul ] <= '9' );
      }
      for( ul = 0, i = 0; fValid && ul < nLen; ul += 3, ++i )
      {
         iVal   = 10 * ( szTime[ ul ] - '0' ) + ( szTime[ ul + 1 ] - '0' );
         fValid = iVal <= sc_iMax[ i ];
         if( piDecode )
            piDecode[ i ] = iVal;
      }
   }

   return fValid;
}

HB_FUNC( XTIMEVALID )
{
   hb_retl( _hb_timeValid( hb_parc( 1 ), hb_parclen( 1 ), NULL ) );
}


/*
 * Additional date functions
 *
 * Copyright 1999 Jose Lalin <dezac@corevia.com>
 */

static HB_BOOL hb_isleapyear( int iYear )
{
 //  HB_TRACE( HB_TR_DEBUG, ( "hb_isleapyear(%d)", iYear ) );

   return ( iYear % 4 == 0 && iYear % 100 != 0 ) || ( iYear % 400 == 0 );
}

HB_FUNC( XISLEAPYEAR )
{
   //PHB_ITEM pDate = hb_param( 1, HB_IT_DATETIME );
   PHB_ITEM pDate = hb_param( 1, HB_IT_ANY );
   if( HB_IS_DATETIME ( pDate ) )
   {
      int iYear, iMonth, iDay;

      hb_dateDecode( hb_itemGetDL( pDate ), &iYear, &iMonth, &iDay );
      hb_retl( hb_isleapyear( iYear ) );
   }
   else 
      hb_retl( hb_isleapyear( hb_itemGetNL( pDate ) ) );
      //hb_retl( HB_FALSE );
}

//XGETDATE(TEMPORAL,AX,0,DIM1,DIM1R,DIM1C,DIM1P,DIM1B)
HB_FUNC( XGETDATE )
{
  PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // CWM
  int codfun  = hb_parni( 2 );
  unsigned int pDim = hb_parni( 3 );   // dimension de matrices
  unsigned int pRow = hb_parni( 4 );   // rows
  unsigned int pCol = hb_parni( 5 );   // cols
  unsigned int pPag = hb_parni( 6 );   // pags
  unsigned int pBlk = hb_parni( 7 );   // blks

  static char * XU_SEMANA[8]={"","Domingo","Lunes","Martes","Miercoles","Jueves","Viernes","Sabado"};
  static char * XU_ANO[13]={"","Enero","Febrero","Marzo","Abril","Mayo","Junio","Julio",
                            "Agosto","Septiembre","Octubre","Noviembre","Diciembre"};

  PHB_ITEM pCWM = NULL;
  
 /****
    CTOD() ==> hb_dateUnformat( pDate, hb_setGetDateFormat() ) ==> long
    DTOS() ==> hb_dateDecStr( szDate, 0 ) donde "0" es un long.
    DOW()  ==> hb_dateJulianDOW( hb_itemGetDL( pDate ) )
    MONTH() ==> 
      int iYear, iMonth, iDay;
      hb_dateDecode( hb_itemGetDL( pDate ), &iYear, &iMonth, &iDay );
    DAY() ==> 
      int iYear, iMonth, iDay;
      hb_dateDecode( hb_itemGetDL( pDate ), &iYear, &iMonth, &iDay );
    WEEK() ==>
      hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
      long lDate2;
      if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
         lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
      else
         lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
      iWeek = ( ct_doy( lDate2 ) - 1 ) / 7 + 1;
    Date es una fecha en string: "10/10/1990"
    ****/

  switch( pDim ){
     case 1:{
        switch( codfun ){
           case 0:{
             // stk_var_02[CWM]:=DTOS(CTOD(AX))
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 char szDate[9];
                 hb_arraySetC( pCWM, n, hb_dateDecStr( szDate, hb_dateUnformat( pDate, hb_setGetDateFormat() ) ) );
              }
              break;
           }
           case 1:{
              // CX:=CTOD(AX[EHX])
              //    if DOW(CX)>0
              //       TEMPORAL[EHX]:=_XU_SEMANA[DOW(CX)]
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int nDow = hb_dateJulianDOW( 
                            hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                 if( nDow > 0){
                    const char * semana = XU_SEMANA[ nDow ];
                    hb_arraySetC( pCWM, n, semana );
                 }else{
                    hb_arraySetC( pCWM, n, pDate );
                 }
              }
              break;
           }
           case 2:{
              //  CX:=MONTH(CTOD(AX[EHX]))
              //    if CX>0
              //       TEMPORAL[EHX]:=_XU_ANO[CX]
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int iYear, iMonth, iDay;
                 hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                 if( iMonth > 0){
                    const char * mes = XU_ANO[ iMonth ];
                    hb_arraySetC( pCWM, n, mes );
                 }else{
                    hb_arraySetC( pCWM, n, pDate );
                 }
              }
              break;
           }
           case 3:{
              // TEMPORAL[EHX]:=DAY( CTOD(AX[EHX]) )
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int iYear, iMonth, iDay;
                 hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                 hb_arraySetNI( pCWM, n, iDay );
              }
              break;
           }
           case 4:{
              // TEMPORAL[EHX]:=MONTH( CTOD(AX[EHX]) )
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int iYear, iMonth, iDay;
                 hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                 hb_arraySetNI( pCWM, n, iMonth );
              }
              break;
           }
           case 5:{
              // TEMPORAL[EHX]:=YEAR( CTOD(AX[EHX]) )
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int iYear, iMonth, iDay;
                 hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                 hb_arraySetNI( pCWM, n, iYear );
              }
              break;
           }
           case 6:{
             // TEMPORAL[EHX]:=DOW( CTOD(AX[EHX]) )
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int nDow = hb_dateJulianDOW( 
                            hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                 hb_arraySetNI( pCWM, n, nDow );
              }
              break;
           }
           case 7:{
              // TEMPORAL[EHX]:=XDOY( CTOD(AX[EHX]) )
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int ndiadelYear = ct_doy( hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                 hb_arraySetNI( pCWM, n, ndiadelYear );
              }
              break;
           }
           case 8:{
              // TEMPORAL[EHX]:=XWEEK( CTOD(AX[EHX]) )
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int iYear, iMonth, iDay;
                 long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                 hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
                 long lDate2;
                 if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
                    lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
                 else
                    lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
                 hb_arraySetNI( pCWM, n, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
              }
              break;
           }
           case 9:{
              //TEMPORAL[EHX]:=XISLEAPYEAR(ANIO)
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 int iYear = hb_itemGetNI( pAA );
                 hb_itemRelease( pAA );
                 hb_arraySetL( pCWM, n, (HB_BOOL) hb_isleapyear( iYear ) );
              }
              break;
           }
           case 10:{
              // CX:=MONTH( CTOD(AX) )
              // stk_var_02[CWM]:=XDAYSINMONTH(CX,XISLEAPYEAR(CTOD(AX)))
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 hb_itemRelease( pAA );
                 int iYear, iMonth, iDay;
                 hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                 HB_BOOL bLeap = hb_isleapyear( iYear );
                 hb_arraySetNI( pCWM, n, ct_daysinmonth( iMonth, bLeap ) );
              }
              break;
           }
           case 11:{
              //hb_itemGetDL( pItem1 ) + hb_itemGetNL( pItem2 ) 
              //TEMPORAL[EHX]:=dtoc(CTOD(CX[EHX])+AX)
              unsigned int n;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pAA = hb_itemArrayGet( pA, 2);
              long pAdd = hb_itemGetNL( pAA );
              hb_itemRelease( pAA );
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pFdate = hb_itemArrayGet( pF, n);
                 const char * pDate = hb_itemGetCPtr( pFdate );
                 hb_itemRelease( pFdate );
                 long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                 char szDate[ 9 ];
                 char szFormatted[ 11 ];
                 
                 hb_arraySetC(pCWM, n, hb_dateFormat(hb_dateDecStr( szDate, lDate + pAdd ),
                    szFormatted, hb_setGetDateFormat() ) );
              }
              hb_itemRelease( pF );
              break;
           }
           case 12:{
              //TEMPORAL[EHX]:=dtoc(CTOD(CX[EHX])+AX[EHX])
              unsigned int n;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pD = hb_itemArrayGet( pA, 2);
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                 const char * pDate = hb_itemGetCPtr( pFF );
                 long nTime = hb_itemGetNI( pDD );
                 hb_itemRelease( pFF );
                 hb_itemRelease( pDD );
                 long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                 char szDate[ 9 ];
                 char szFormatted[ 11 ];
                 const char * pResult = hb_dateFormat(hb_dateDecStr( szDate, lDate + 
                    nTime ), szFormatted, hb_setGetDateFormat() );
                 hb_arraySetC(pCWM, n, pResult );
                 
              }
              hb_itemRelease( pF );
              hb_itemRelease( pD );
              break;
           }
           case 14:{
              // TEMPORAL[EHX]:=XTIMEVALID(AX[EHX])
              unsigned int n;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 const char * pDate = hb_itemGetCPtr( pAA );
                 long lDate = hb_itemGetCLen( pAA );
                 hb_itemRelease( pAA );
                 hb_arraySetL(pCWM, n, (HB_BOOL) _hb_timeValid( pDate, lDate, NULL ) );
              }
           }
        }
        break;
     }
     case 2:
     {  
        switch( codfun ){
           case 0:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    char szDate[9];
                    hb_arraySetC( pCC, m, hb_dateDecStr( szDate, hb_dateUnformat( pDate, hb_setGetDateFormat() ) ) );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 1:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int nDow = hb_dateJulianDOW( 
                            hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                    if( nDow > 0){
                       const char * semana = XU_SEMANA[ nDow ];
                       hb_arraySetC( pCC, m, semana );
                    }else{
                       hb_arraySetC( pCC, m, pDate );
                    }
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 2:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int iYear, iMonth, iDay;
                    hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                    if( iMonth > 0){
                       const char * mes = XU_ANO[ iMonth ];
                       hb_arraySetC( pCC, m, mes );
                    }else{
                       hb_arraySetC( pCC, m, pDate );
                    }
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 3:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int iYear, iMonth, iDay;
                    hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                    hb_arraySetNI( pCC, m, iDay );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 4:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int iYear, iMonth, iDay;
                    hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                    hb_arraySetNI( pCC, m, iMonth );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 5:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int iYear, iMonth, iDay;
                    hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                    hb_arraySetNI( pCC, m, iYear );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 6:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int nDow = hb_dateJulianDOW( 
                            hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                    hb_arraySetNI( pCC, m, nDow );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 7:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int ndiadelYear = ct_doy( hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                    hb_arraySetNI( pCC, m, ndiadelYear );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 8:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int iYear, iMonth, iDay;
                    long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                    hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
                    long lDate2;
                    if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
                       lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
                    else
                       lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
                    hb_arraySetNI( pCC, m, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 9:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    int iYear = hb_itemGetNI( pAAA );
                    hb_itemRelease( pAAA );
                    hb_arraySetL( pCC, m, (HB_BOOL) hb_isleapyear( iYear ) );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 10:
           {
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    hb_itemRelease( pAAA );
                    int iYear, iMonth, iDay;
                    hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                    HB_BOOL bLeap = hb_isleapyear( iYear );
                    hb_arraySetNI( pCC, m, ct_daysinmonth( iMonth, bLeap ) );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 11:
           {
              unsigned int n,m;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pAA = hb_itemArrayGet( pA, 2);
              long pAdd = hb_itemGetNL( pAA );
              hb_itemRelease( pAA );
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pFdate = hb_itemArrayGet( pFF, m);
                    const char * pDate = hb_itemGetCPtr( pFdate );
                    hb_itemRelease( pFdate );
                    long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                    char szDate[ 9 ];
                    char szFormatted[ 11 ];
                 
                    hb_arraySetC(pCC, m, hb_dateFormat(hb_dateDecStr( szDate, lDate + pAdd ),
                       szFormatted, hb_setGetDateFormat() ) );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pFF);
                 hb_itemRelease(pCC);
              }
              hb_itemRelease( pF );
              break;
           }
           case 12:
           {
              //TEMPORAL[EHX]:=dtoc(CTOD(CX[EHX])+AX[EHX])
              unsigned int n,m;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pD = hb_itemArrayGet( pA, 2);
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pFFF = hb_itemArrayGet( pFF, m);
                    PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                    const char * pDate = hb_itemGetCPtr( pFFF );
                    long nTime = hb_itemGetNI( pDDD );
                    hb_itemRelease( pFFF );
                    hb_itemRelease( pDDD );
                    long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                    char szDate[ 9 ];
                    char szFormatted[ 11 ];
                    const char * pResult = hb_dateFormat(hb_dateDecStr( szDate, lDate + 
                         nTime ), szFormatted, hb_setGetDateFormat() );
                    hb_arraySetC(pCC, m, pResult );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pFF);
                 hb_itemRelease(pDD);
                 hb_itemRelease(pCC);
              }
              hb_itemRelease( pF );
              hb_itemRelease( pD );
              break;
           }
           case 14:
           {
              // TEMPORAL[EHX]:=XTIMEVALID(AX[EHX])
              unsigned int n,m;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, n);
                    const char * pDate = hb_itemGetCPtr( pAAA );
                    long lDate = hb_itemGetCLen( pAAA );
                    hb_itemRelease( pAAA );
                    hb_arraySetL(pCC, m, (HB_BOOL) _hb_timeValid( pDate, lDate, NULL ) );
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
           }
        }
        break;
     }
     case 3:
     {
        switch( codfun ){
           case 0:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       char szDate[9];
                       hb_arraySetC( pCCC, o, hb_dateDecStr( szDate, hb_dateUnformat( pDate, hb_setGetDateFormat() ) ) );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 1:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int nDow = hb_dateJulianDOW( 
                             hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                       if( nDow > 0){
                          const char * semana = XU_SEMANA[ nDow ];
                          hb_arraySetC( pCCC, o, semana );
                       }else{
                          hb_arraySetC( pCCC, o, pDate );
                       }
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 2:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int iYear, iMonth, iDay;
                       hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                       if( iMonth > 0){
                          const char * mes = XU_ANO[ iMonth ];
                          hb_arraySetC( pCCC, o, mes );
                       }else{
                          hb_arraySetC( pCCC, o, pDate );
                       }
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 3:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int iYear, iMonth, iDay;
                       hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                       hb_arraySetNI( pCCC, o, iDay );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 4:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int iYear, iMonth, iDay;
                       hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                       hb_arraySetNI( pCCC, o, iMonth );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 5:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int iYear, iMonth, iDay;
                       hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                       hb_arraySetNI( pCCC, o, iYear );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 6:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int nDow = hb_dateJulianDOW( 
                            hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                       hb_arraySetNI( pCCC, o, nDow );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 7:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int ndiadelYear = ct_doy( hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                       hb_arraySetNI( pCCC, o, ndiadelYear );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 8:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int iYear, iMonth, iDay;
                       long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                       hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
                       long lDate2;
                       if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
                          lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
                       else
                          lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
                       hb_arraySetNI( pCCC, o, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 9:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       int iYear = hb_itemGetNI( pAAAA );
                       hb_itemRelease( pAAAA );
                       hb_arraySetL( pCCC, o, (HB_BOOL) hb_isleapyear( iYear ) );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 10:
           {
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       hb_itemRelease( pAAAA );
                       int iYear, iMonth, iDay;
                       hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                       HB_BOOL bLeap = hb_isleapyear( iYear );
                       hb_arraySetNI( pCCC, o, ct_daysinmonth( iMonth, bLeap ) );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 11:
           {
              unsigned int n,m,o;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pAA = hb_itemArrayGet( pA, 2);
              long pAdd = hb_itemGetNL( pAA );
              hb_itemRelease( pAA );
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pFFF = hb_itemArrayGet( pFF, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pFdate = hb_itemArrayGet( pFFF, o);
                       const char * pDate = hb_itemGetCPtr( pFdate );
                       hb_itemRelease( pFdate );
                       long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                       char szDate[ 9 ];
                       char szFormatted[ 11 ];
                 
                       hb_arraySetC(pCCC, o, hb_dateFormat(hb_dateDecStr( szDate, lDate + pAdd ),
                           szFormatted, hb_setGetDateFormat() ) );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pFFF);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pFF);
                 hb_itemRelease(pCC);
              }
              hb_itemRelease( pF );
              break;
           }
           case 12:
           {
              //TEMPORAL[EHX]:=dtoc(CTOD(CX[EHX])+AX[EHX])
              unsigned int n,m,o;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pD = hb_itemArrayGet( pA, 2);
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pFFF = hb_itemArrayGet( pFF, m);
                    PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pFFFF = hb_itemArrayGet( pFFF, o);
                       PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                       const char * pDate = hb_itemGetCPtr( pFFFF );
                       long nTime = hb_itemGetNI( pDDDD );
                       hb_itemRelease( pFFFF );
                       hb_itemRelease( pDDDD );
                       long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                       char szDate[ 9 ];
                       char szFormatted[ 11 ];
                       const char * pResult = hb_dateFormat(hb_dateDecStr( szDate, lDate + 
                             nTime ), szFormatted, hb_setGetDateFormat() );
                       hb_arraySetC(pCCC, o, pResult );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pFFF);
                    hb_itemRelease(pDDD);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pFF);
                 hb_itemRelease(pDD);
                 hb_itemRelease(pCC);
              }
              hb_itemRelease( pF );
              hb_itemRelease( pD );
              break;
           }
           case 14:
           {
              // TEMPORAL[EHX]:=XTIMEVALID(AX[EHX])
              unsigned int n,m,o;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       const char * pDate = hb_itemGetCPtr( pAAAA );
                       long lDate = hb_itemGetCLen( pAAAA );
                       hb_itemRelease( pAAA );
                       hb_arraySetL(pCCC, o, (HB_BOOL) _hb_timeValid( pDate, lDate, NULL ) );
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
           }
        }
        break;
     }
     case 4:{
        switch( codfun ){
           case 0:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          char szDate[9];
                          hb_arraySetC( pCCCC, p, hb_dateDecStr( szDate, hb_dateUnformat( pDate, hb_setGetDateFormat() ) ) );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 1:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int nDow = hb_dateJulianDOW( 
                             hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                          if( nDow > 0){
                             const char * semana = XU_SEMANA[ nDow ];
                             hb_arraySetC( pCCCC, p, semana );
                          }else{
                             hb_arraySetC( pCCCC, p, pDate );
                          }
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 2:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int iYear, iMonth, iDay;
                          hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                          if( iMonth > 0){
                             const char * mes = XU_ANO[ iMonth ];
                             hb_arraySetC( pCCCC, p, mes );
                          }else{
                             hb_arraySetC( pCCCC, p, pDate );
                          }
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 3:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int iYear, iMonth, iDay;
                          hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                          hb_arraySetNI( pCCCC, p, iDay );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 4:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int iYear, iMonth, iDay;
                          hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                          hb_arraySetNI( pCCCC, p, iMonth );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 5:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int iYear, iMonth, iDay;
                          hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                          hb_arraySetNI( pCCCC, p, iYear );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 6:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int nDow = hb_dateJulianDOW( 
                              hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                          hb_arraySetNI( pCCCC, p, nDow );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 7:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int ndiadelYear = ct_doy( hb_dateUnformat( pDate, hb_setGetDateFormat() ) );
                          hb_arraySetNI( pCCCC, p, ndiadelYear );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 8:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int iYear, iMonth, iDay;
                          long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                          hb_dateDecode( lDate, &iYear, &iMonth, &iDay );
                          long lDate2;
                          if( hb_setGetCPtr( HB_SET_DATEFORMAT ) && ( hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'd' ||
                                                  hb_setGetCPtr( HB_SET_DATEFORMAT )[ 0 ] == 'D' ) )
                             lDate2 = lDate + 3 - ( hb_dateDOW( iYear, iMonth, iDay ) + 5 ) % 7;
                          else
                             lDate2 = lDate + 4 - hb_dateDOW( iYear, iMonth, iDay );
                          hb_arraySetNI( pCCCC, p, ( ct_doy( lDate2 ) - 1 ) / 7 + 1 );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 9:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          int iYear = hb_itemGetNI( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          hb_arraySetL( pCCCC, p, (HB_BOOL) hb_isleapyear( iYear ) );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 10:
           {
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          int iYear, iMonth, iDay;
                          hb_dateDecode( hb_dateUnformat( pDate, hb_setGetDateFormat() ), 
                                &iYear, &iMonth, &iDay );
                          HB_BOOL bLeap = hb_isleapyear( iYear );
                          hb_arraySetNI( pCCCC, p, ct_daysinmonth( iMonth, bLeap ) );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
              break;
           }
           case 11:
           {
              unsigned int n,m,o,p;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pAA = hb_itemArrayGet( pA, 2);
              long pAdd = hb_itemGetNL( pAA );
              hb_itemRelease( pAA );
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pFFF = hb_itemArrayGet( pFF, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pFFFF = hb_itemArrayGet( pFFF, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pFdate = hb_itemArrayGet( pFFFF, p);
                          const char * pDate = hb_itemGetCPtr( pFdate );
                          hb_itemRelease( pFdate );
                          long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                          char szDate[ 9 ];
                          char szFormatted[ 11 ];
                 
                          hb_arraySetC(pCCCC, p, hb_dateFormat(hb_dateDecStr( szDate, lDate + pAdd ),
                               szFormatted, hb_setGetDateFormat() ) );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pFFFF);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pFFF);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pFF);
                 hb_itemRelease(pCC);
              }
              hb_itemRelease( pF );
              break;
           }
           case 12:
           {
              //TEMPORAL[EHX]:=dtoc(CTOD(CX[EHX])+AX[EHX])
              unsigned int n,m,o,p;
              PHB_ITEM pF = hb_itemArrayGet( pA, 1);   // Matriz a sumar
              PHB_ITEM pD = hb_itemArrayGet( pA, 2);
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 PHB_ITEM pFF = hb_itemArrayGet( pF, n);
                 PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pFFF = hb_itemArrayGet( pFF, m);
                    PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pFFFF = hb_itemArrayGet( pFFF, o);
                       PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pFFFFF = hb_itemArrayGet( pFFFF, p);
                          PHB_ITEM pDDDDD = hb_itemArrayGet( pDDDD, p);
                          const char * pDate = hb_itemGetCPtr( pFFFFF );
                          long nTime = hb_itemGetNI( pDDDDD );
                          hb_itemRelease( pFFFFF );
                          hb_itemRelease( pDDDDD );
                          long lDate = hb_dateUnformat( pDate, hb_setGetDateFormat() );
                          char szDate[ 9 ];
                          char szFormatted[ 11 ];
                          const char * pResult = hb_dateFormat(hb_dateDecStr( szDate, lDate + 
                                nTime ), szFormatted, hb_setGetDateFormat() );
                          hb_arraySetC(pCCCC, p, pResult );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pFFFF);
                       hb_itemRelease(pDDDD);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pFFF);
                    hb_itemRelease(pDDD);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pFF);
                 hb_itemRelease(pDD);
                 hb_itemRelease(pCC);
              }
              hb_itemRelease( pF );
              hb_itemRelease( pD );
              break;
           }
           case 14:
           {
              // TEMPORAL[EHX]:=XTIMEVALID(AX[EHX])
              unsigned int n,m,o,p;
              pCWM = hb_itemArrayNew( pRow ); // CWM 
              for( n=1; n<=pRow; n++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                 for( m=1; m<=pCol; m++){
                    PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                    PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                    for( o=1; o<=pPag; o++){
                       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                       PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                       for( p=1; p<=pBlk; p++){
                          PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                          const char * pDate = hb_itemGetCPtr( pAAAAA );
                          long lDate = hb_itemGetCLen( pAAAAA );
                          hb_itemRelease( pAAAAA );
                          hb_arraySetL(pCCCC, p, (HB_BOOL) _hb_timeValid( pDate, lDate, NULL ) );
                       }
                       hb_arraySet( pCCC, o, pCCCC );
                       hb_itemRelease(pAAAA);
                       hb_itemRelease(pCCCC);
                    }
                    hb_arraySet( pCC, m, pCCC );
                    hb_itemRelease(pAAA);
                    hb_itemRelease(pCCC);
                 }
                 hb_arraySet( pCWM, n, pCC );
                 hb_itemRelease(pAA);
                 hb_itemRelease(pCC);
              }
           }
        }
        break;
     }
  }
  hb_itemReturnRelease( pCWM );
}

char *strpad (const char *linea, uint16_t size, uint16_t sizel, uint16_t codeFun){
   char *t,*buffer;
   const char *s, *r;
   uint16_t tsize,l1,l2,ts, lsizel;
   int i,p,q;
   
  // acoto el string a padear, por ambos lados (evito llamar a TRIM).
 // printf("\nLinea  %s\n",linea);

 //   printf("ENTRA AQUI\n");
   r = linea;
   if (*r=='\t' || *r=='\r' || *r=='\n' || *r==' '){
      while ((*r=='\t' || *r=='\r' || *r=='\n' || *r==' ') && *r) r++; 
      if (!*r) return NULL;  // no hay texto, sólo puras weás! 
   }
   s = linea + (sizel-1);
   if (*s=='\t' || *s=='\r' || *s=='\n' || *s==' '){
      while ((*s=='\t' || *s=='\r' || *s=='\n' || *s==' ') && s!=linea) s--;     
      if (s==linea) return NULL;  // no hay texto, sólo puras weás!
   }
   tsize = s - r + 1;  // longitud del texto.
 //  printf("\nS= %s, R=%s, TSIZE=%d CPAD=%d SIZECAMPO=%d\n",s,r,tsize,size,sizel);
   if (tsize>sizel) return NULL;
 //  printf("\nPASO... con %s\n",linea);
   lsizel = sizel - strlen(linea);


   l1 = ( (size - tsize) + lsizel ) / 2;
   l2 = l1;

   if (l1+l2+tsize < size+lsizel) l2++;   // por si el pad es impar
   ts = l1+l2+tsize;
// asigno espacio (size) para nueva cadena:
   buffer = (char *) calloc(ts+1,1); //sizeof(char));
   t = buffer;
   if (t==NULL) return NULL;    // todo termina si no hay memoria.
   
   switch( codeFun ){
      case 0: { // centrado
      	p=0;
        while (l1--){
      	  //strcat(t," ");
      	  t[p++] = ' ';
        }
        //strncat(t,r,tsize);
        q=0;
        while (tsize--){
        	 t[p++] = r[q++];
        } 
        while (l2--){
      	 // strcat(t," ");
      	   t[p++] = ' ';
        }
        t[p] = '\0';
        break;
      }
      case 1: {  // Left
      	p=0;
        //strncat(t,r,tsize);
        q=0;
        while (tsize--){
        	 t[p++] = r[q++];
        }
        i = l1 + l2;
        while (i--){
      	  //strcat(t," ");
      	  t[p++] = ' ';
        }
        t[p] = '\0';
        break;
      }
      case 2: {    // Right
        i = l1 + l2;
        p = 0;
        while (i--){
      	  //strcat(t," ");
      	  t[p++] = ' ';
        }
        //strncat(t,r,tsize);
        q=0;
        while (tsize--){
        	 t[p++] = r[q++];
        }
        t[p] = '\0';
        break;
      }
   }
   char * Retorno = (char *)calloc(p+1,1);
   char * Ret = Retorno;
   strcpy(Ret,t);
   free(buffer);
   return Retorno;   
}

char *fun_strpad (const char *linea, uint16_t size, uint16_t sizel, const char * fill, uint16_t codeFun){
   char *t,*buffer;
   const char *s, *r;
   uint16_t tsize,l1,l2,ts, lsizel;
   int i,p,q;
   
  // acoto el string a padear, por ambos lados (evito llamar a TRIM).
   r = linea;
   if (*r=='\t' || *r=='\r' || *r=='\n' || *r==' '){
      while ((*r=='\t' || *r=='\r' || *r=='\n' || *r==' ') && *r) r++; 
      if (!*r) return NULL;  // no hay texto, sólo puras weás! 
   }
   s = linea + (sizel-1);
   if (*s=='\t' || *s=='\r' || *s=='\n' || *s==' '){
      while ((*s=='\t' || *s=='\r' || *s=='\n' || *s==' ') && s!=linea) s--;     
      if (s==linea) return NULL;  // no hay texto, sólo puras weás!
   }
   tsize = s - r + 1;  // longitud del texto.
   if (tsize>sizel) return NULL;

   lsizel = sizel - strlen(linea);

   l1 = ( (size - tsize) + lsizel ) / 2;
   l2 = l1;

   if (l1+l2+tsize < size+lsizel) l2++;   // por si el pad es impar
   ts = l1+l2+tsize;
// asigno espacio (size) para nueva cadena:
   buffer = (char *) calloc(ts+1,1); //sizeof(char));
   t = buffer;
   if (t==NULL) return NULL;    // todo termina si no hay memoria.
   
   char pFill = fill[0];
   switch( codeFun ){
      case 0: { // centrado
      	p=0;
        while (l1--){
      	  //strcat(t," ");
      	  t[p++] = pFill;
        }
        //strncat(t,r,tsize);
        q=0;
        while (tsize--){
        	 t[p++] = r[q++];
        } 
        while (l2--){
      	 // strcat(t," ");
      	   t[p++] = pFill;
        }
        t[p] = '\0';
        break;
      }
      case 1: {  // Left
      	p=0;
        //strncat(t,r,tsize);
        q=0;
        while (tsize--){
        	 t[p++] = r[q++];
        }
        i = l1 + l2;
        while (i--){
      	  //strcat(t," ");
      	  t[p++] = pFill;
        }
        t[p] = '\0';
        break;
      }
      case 2: {    // Right
        i = l1 + l2;
        p = 0;
        while (i--){
      	  //strcat(t," ");
      	  t[p++] = pFill;
        }
        //strncat(t,r,tsize);
        q=0;
        while (tsize--){
        	 t[p++] = r[q++];
        }
        t[p] = '\0';
        break;
      }
   }
   char * Retorno = (char *)calloc(p+1,1);
   char * Ret = Retorno;
   strcpy(Ret,t);
   free(buffer);
   return Retorno;   
}

// XSTRPAD(TEMPORAL,AX,PAD,FILL,{DIM1,DIM1R,DIM1C,DIM1P,DIM1B,BX})
HB_FUNC( XSTRPAD )
{
//char *strpad (const char *linea, uint16_t size, uint16_t sizel, uint16_t codeFun){
//cPadToken=strpad(campo,nPad,sizeCampo,0);

    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = STRING o NUMBER
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = PAD
    PHB_ITEM pD = hb_param( 3, HB_IT_ANY ); // D = RELLENO
    PHB_ITEM params   = hb_param( 4, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    int codfun = hb_itemGetNI( p6 );   // cod funcion
    int codPad = hb_itemGetNI( p7 );   // 1=vector, 0=numero
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
    
    PHB_ITEM pCWM = NULL;

    switch( pDim ){
       case 1:
       {
          unsigned int n;
          HB_MAXINT pPad = (codPad)? 0: hb_itemGetNI( pB );
          const char * pFill = hb_itemGetCPtr( pD );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pSource = hb_itemArrayGet( pA, n);
             char * pBuffer;
             if ( codPad ){
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                              hb_itemGetNI( pBB ), 
                              hb_itemGetCLen( pSource ), pFill, codfun );
                hb_itemRelease(pBB);
             }else{
                pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                              pPad, hb_itemGetCLen( pSource ), pFill, codfun );
             }
             const char * buf = pBuffer;
             if( buf != NULL ){
                hb_arraySetC( pCWM, n, buf );
             }else{
                hb_arraySetC( pCWM, n, hb_itemGetCPtr( pSource ) );
             }
             hb_itemRelease(pSource);
             free(pBuffer);
          }
          break;
       }
       case 2:
       {
          HB_MAXINT pPad = (codPad)? 0: hb_itemGetNI( pB );
          const char * pFill = hb_itemGetCPtr( pD );
          unsigned int n=1,m=1;

          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pSource = hb_itemArrayGet( pAA, m);
                char * pBuffer;
                if ( codPad ){
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                              hb_itemGetNI( pBBB ), 
                              hb_itemGetCLen( pSource ), pFill, codfun );
                   hb_itemRelease(pBBB);
                   hb_itemRelease(pBB);
                }else{
                   pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                              pPad, hb_itemGetCLen( pSource ), pFill, codfun );
                }
                
                const char * buf = pBuffer;
                if( buf != NULL ){
                   hb_arraySetC( pCC, m, buf );
                }else{
                   hb_arraySetC( pCC, m, hb_itemGetCPtr( pSource ) );
                }
                hb_itemRelease(pSource);
                free(pBuffer);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 3:
       {
          HB_MAXINT pPad = (codPad)? 0: hb_itemGetNI( pB );
          const char * pFill = hb_itemGetCPtr( pD );
          unsigned int n=1,m=1,o=1;

          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pSource = hb_itemArrayGet( pAAA, o);
                   char * pBuffer;
                   if ( codPad ){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                              hb_itemGetNI( pBBBB ), 
                              hb_itemGetCLen( pSource ), pFill, codfun );
                      hb_itemRelease(pBBBB);
                      hb_itemRelease(pBBB);
                      hb_itemRelease(pBB);
                   }else{
                      pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                              pPad, hb_itemGetCLen( pSource ), pFill, codfun );
                   }
                   const char * buf = pBuffer;
                   if( buf != NULL ){
                      hb_arraySetC( pCCC, o, buf );
                   }else{
                      hb_arraySetC( pCCC, o, hb_itemGetCPtr( pSource ) );
                   }
                   hb_itemRelease(pSource);
                   free(pBuffer);
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 4:
       {
          HB_MAXINT pPad = (codPad)? 0: hb_itemGetNI( pB );
          const char * pFill = hb_itemGetCPtr( pD );
          unsigned int n=1,m=1,o=1,p=1;

          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pSource = hb_itemArrayGet( pAAAA, p);
                      char * pBuffer;
                      if ( codPad ){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
             
                         pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                               hb_itemGetNI( pBBBBB ), 
                               hb_itemGetCLen( pSource ), pFill, codfun );
                         hb_itemRelease(pBBBBB);
                         hb_itemRelease(pBBBB);
                         hb_itemRelease(pBBB);
                         hb_itemRelease(pBB);
                      }else{
                         pBuffer = (char *)fun_strpad(hb_itemGetCPtr( pSource ),
                               pPad, hb_itemGetCLen( pSource ), pFill, codfun );
                      }
                      const char * buf = pBuffer;
                      if( buf != NULL ){
                         hb_arraySetC( pCCCC, p, buf );
                      }else{
                         hb_arraySetC( pCCCC, p, hb_itemGetCPtr( pSource ) );
                      }
                      hb_itemRelease(pSource);
                      free(pBuffer);
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pCCCC);
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
          }
          break;
       }
    }
    hb_itemReturnRelease( pCWM );
}

/// CREAR: XSTRTRAN(TEMPORAL,FUENTE[EHX],BUSCA[EHX],REPLA[EHX],OCURR,NUMRE,{DIM,ROW,COL,PAG,BLK,CODFUN})
HB_FUNC( XSTRTRAN )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = STRING
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = BUSCA
    PHB_ITEM pD = hb_param( 3, HB_IT_ANY ); // D = REEMPLAZA POR
    unsigned int pOcurr = hb_parni( 4 );   // desde donde empieza a reemplazar
    unsigned int pNumre = hb_parni( 5 );   // cuantos reemplaza
    PHB_ITEM params   = hb_param( 6, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    int codfun = hb_itemGetNI( p6 );   // cod funcion
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    
    PHB_ITEM pCWM = NULL;

    int strOk = 1;

    switch( pDim ){
       case 1 : 
       {
          unsigned int n=1;
          
          switch( codfun ){
             case 1 : 
             {
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                if (uiArrayLenB == uiArrayLenD && uiArrayLenB > 0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      const char * pLinea = hb_itemGetCPtr( pAA );
                      hb_itemRelease( pAA );
                      char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                      strcpy(cLinea,pLinea);
                      const char * cFuente = cLinea;
                      
                      for(j=1; j<=uiArrayLenB; j++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                         PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                         
                         char * Str = FUNSTRTRAN((const char *)cFuente, 
                            (const char *) hb_itemGetCPtr( pBB ), 
                            (const char *)hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                         
                         hb_itemRelease(pBB);
                         hb_itemRelease(pDD);
                         
                         const char * Buff = Str;
                         free(cLinea);
                         if (Buff!=NULL){
                           /// printf("\nDATO OBTENIDO: %s\n",Buff);
                            cLinea = (char *)calloc(strlen(Buff)+1,1);
                            strcpy(cLinea,Buff);
                            cFuente = cLinea;
                         }else{
                            strOk=0;
                          //  printf("\nPASO POR NULL\n");
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySetC( pCWM, n, (const char *)cFuente);
                      free(cLinea);
                   }
                } else { 
                   strOk = 0; 
                   break;
                }  // no hace nada. devuelve array vacio.
                break;
             }
             case 2 : 
             { // AC C
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                
                if (uiArrayLenB>0){
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   long j;
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      const char * pLinea = hb_itemGetCPtr( pAA );
                      hb_itemRelease( pAA );
                      char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                      strcpy(cLinea,pLinea);
                      const char * cFuente = cLinea;
                      
                      for(j=1; j<=uiArrayLenB; j++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                         char * Str = FUNSTRTRAN((const char *)cFuente, 
                             (const char *)hb_itemGetCPtr( pBB ), 
                             (const char *)hb_itemGetCPtr( pD ), pOcurr, pNumre);
                         hb_itemRelease(pBB);
                         
                         const char * Buff = Str;
                         free(cLinea);
                         if (Buff!=NULL){
                           /// printf("\nDATO OBTENIDO: %s\n",Buff);
                            cLinea = (char *)calloc(strlen(Buff)+1,1);
                            strcpy(cLinea,Buff);
                            cFuente = cLinea;
                         }else{
                            strOk=0;
                          //  printf("\nPASO POR NULL\n");
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySetC( pCWM, n, (const char *)cFuente);
                      free(cLinea);
                   }
                }else{ 
                   strOk = 0;
                   break;
                }
                break;
             }
             case 3 : { // C y AC
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                
                if (uiArrayLenD>0){
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   long j;
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      const char * pLinea = hb_itemGetCPtr( pAA );
                      hb_itemRelease( pAA );
                      char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                      strcpy(cLinea,pLinea);
                      const char * cFuente = cLinea;
                      
                      for(j=1; j<=uiArrayLenD; j++){
                         PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                         char * Str = FUNSTRTRAN((const char *)cFuente, 
                             (const char *)hb_itemGetCPtr( pB ), 
                             (const char *)hb_itemGetCPtr( pDD ), pOcurr, pNumre); 
                         hb_itemRelease(pDD);
                         
                         const char * Buff = Str;
                         free(cLinea);
                         if (Buff!=NULL){
                           /// printf("\nDATO OBTENIDO: %s\n",Buff);
                            cLinea = (char *)calloc(strlen(Buff)+1,1);
                            strcpy(cLinea,Buff);
                            cFuente = cLinea;
                         }else{
                            strOk=0;
                          //  printf("\nPASO POR NULL\n");
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySetC( pCWM, n, (const char *)cFuente);
                      free(cLinea);
                   }
                } else { strOk = 0; }
                break;
             }
             case 4 : 
             { // mat str str
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   const char * pLinea = hb_itemGetCPtr( pAA );
                   hb_itemRelease( pAA );
                   char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                   strcpy(cLinea,pLinea);
                   const char * cFuente = cLinea;
                    
                   char * Str = FUNSTRTRAN((const char *)cFuente, 
                          (const char *)hb_itemGetCPtr( pB ), 
                          (const char *)hb_itemGetCPtr( pD ), pOcurr, pNumre);
                   const char * Buff = Str;
                   free(cLinea);
                   if (Buff!=NULL){
                      /// printf("\nDATO OBTENIDO: %s\n",Buff);
                      hb_arraySetC( pCWM, n, (const char *)Buff);
                   }else{
                      strOk=0;
                      //  printf("\nPASO POR NULL\n");
                      break;
                   }
                   free(Str);
                }
                break;
             }
          }
          break;
       } 
       case 2 : 
       {
          unsigned int n=1,m=1;
             
          switch( codfun ){
             case 1 : 
             {
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                if (uiArrayLenB == uiArrayLenD && uiArrayLenB > 0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         const char * pLinea = hb_itemGetCPtr( pAAA );
                         hb_itemRelease( pAAA );
                         char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                         strcpy(cLinea,pLinea);
                         const char * cFuente = cLinea;
                      
                         for(j=1; j<=uiArrayLenB; j++){
                            PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                            PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                         
                            char * Str = FUNSTRTRAN((const char *)cFuente, 
                                 (const char *) hb_itemGetCPtr( pBB ), 
                                 (const char *)hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                         
                            hb_itemRelease(pBB);
                            hb_itemRelease(pDD);
                         
                            const char * Buff = Str;
                            free(cLinea);
                            if (Buff!=NULL){
                             ////  printf("\nDATO OBTENIDO: %s\n",Buff);
                               cLinea = (char *)calloc(strlen(Buff)+1,1);
                               strcpy(cLinea,Buff);
                               cFuente = cLinea;
                            }else{
                               strOk=0;
                              //  printf("\nPASO POR NULL\n");
                               hb_itemRelease(pAA);
                               hb_itemRelease(pCC);
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySetC( pCC, m, (const char *)cFuente);
                         free(cLinea);
                      }
                     // printf("\nLEN PCC = %ld\n",(long)hb_arrayLen(pCC));
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                     // printf("\nLEN PCWM = %ld\n",(long)hb_arrayLen(pCWM));
                   }
                } else { 
                   strOk = 0; 
                   break;
                }  // no hace nada. devuelve array vacio.
                break;
             }
             case 2 : 
             { // 
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                
                if (uiArrayLenB>0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         const char * pLinea = hb_itemGetCPtr( pAAA );
                         hb_itemRelease( pAAA );
                         char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                         strcpy(cLinea,pLinea);
                         const char * cFuente = cLinea;
                      
                         for(j=1; j<=uiArrayLenB; j++){ 
                            PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                            char * Str = FUNSTRTRAN((const char *)cFuente, 
                                 hb_itemGetCPtr( pBB ), 
                                 hb_itemGetCPtr( pD ), pOcurr, pNumre);
                            hb_itemRelease(pBB);
                         
                            const char * Buff = Str;
                            free(cLinea);
                            if (Buff!=NULL){
                             ////  printf("\nDATO OBTENIDO: %s\n",Buff);
                               cLinea = (char *)calloc(strlen(Buff)+1,1);
                               strcpy(cLinea,Buff);
                               cFuente = cLinea;
                            }else{
                               strOk=0;
                              //  printf("\nPASO POR NULL\n");
                               hb_itemRelease(pAA);
                               hb_itemRelease(pCC);
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySetC( pCC, m, (const char *)cFuente);
                         free(cLinea);
                      }
                     // printf("\nLEN PCC = %ld\n",(long)hb_arrayLen(pCC));
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                     // printf("\nLEN PCWM = %ld\n",(long)hb_arrayLen(pCWM));
                   }
                } else { strOk = 0; }
                break;
             }
             case 3 : 
             { // AN y AN
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                
                if (uiArrayLenD>0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         const char * pLinea = hb_itemGetCPtr( pAAA );
                         hb_itemRelease( pAAA );
                         char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                         strcpy(cLinea,pLinea);
                         const char * cFuente = cLinea;
                      
                         for(j=1; j<=uiArrayLenD; j++){
                            PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                            char * Str = FUNSTRTRAN((const char *)cFuente, 
                                  hb_itemGetCPtr( pB ), 
                                  hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                            
                            hb_itemRelease(pDD);
                         
                            const char * Buff = Str;
                            free(cLinea);
                            if (Buff!=NULL){
                             ////  printf("\nDATO OBTENIDO: %s\n",Buff);
                               cLinea = (char *)calloc(strlen(Buff)+1,1);
                               strcpy(cLinea,Buff);
                               cFuente = cLinea;
                            }else{
                               strOk=0;
                              //  printf("\nPASO POR NULL\n");
                               hb_itemRelease(pAA);
                               hb_itemRelease(pCC);
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySetC( pCC, m, (const char *)cFuente);
                         free(cLinea);
                      }
                     // printf("\nLEN PCC = %ld\n",(long)hb_arrayLen(pCC));
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0; }
                break;
             }
             case 4 : 
             { // AN y AN
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      const char * pLinea = hb_itemGetCPtr( pAAA );
                      hb_itemRelease( pAAA );
                      char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                      strcpy(cLinea,pLinea);
                      const char * cFuente = cLinea;
                
                      char * Str = FUNSTRTRAN((const char *)cFuente, 
                           hb_itemGetCPtr( pB ), 
                           hb_itemGetCPtr( pD ), pOcurr, pNumre);
                           
                      const char * Buff = Str;
                      free(cLinea);
                      if (Buff!=NULL){
                         hb_arraySetC( pCC, m, (const char *)Buff);
                      }else{
                         strOk=0;
                         //  printf("\nPASO POR NULL\n");
                         hb_itemRelease(pAA);
                         hb_itemRelease(pCC);
                         break;
                      }
                      free(Str);
                   }
                   if ( !strOk ) {break;}
                   hb_arraySet( pCWM, n, pCC);
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          } 
          break;
       } 
       case 3 : 
       {
          unsigned int n=1,m=1,o=1;

          switch( codfun ){
             case 1 : 
             {
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                if (uiArrayLenB == uiArrayLenD && uiArrayLenB > 0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            const char * pLinea = hb_itemGetCPtr( pAAAA );
                            hb_itemRelease( pAAAA );
                            char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                            strcpy(cLinea,pLinea);
                            const char * cFuente = cLinea;
                      
                            for(j=1; j<=uiArrayLenB; j++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                               PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                               char * Str = FUNSTRTRAN((const char *)cFuente, 
                                    hb_itemGetCPtr( pBB ), 
                                    hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                               hb_itemRelease(pBB);
                               hb_itemRelease(pDD);
                         
                               const char * Buff = Str;
                               free(cLinea);
                               if (Buff!=NULL){
                                  ////  printf("\nDATO OBTENIDO: %s\n",Buff);
                                  cLinea = (char *)calloc(strlen(Buff)+1,1);
                                  strcpy(cLinea,Buff);
                                  cFuente = cLinea;
                               }else{
                                  strOk=0;
                                  //  printf("\nPASO POR NULL\n");
                                  hb_itemRelease(pAAA);
                                  hb_itemRelease(pCCC);
                                  hb_itemRelease(pAA);
                                  hb_itemRelease(pCC);
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) {break;}
                            hb_arraySetC( pCCC, o, (const char *)cFuente);
                            free(cLinea);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCC, m, pCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0; }
                break;
             }
             case 2 :
             { // 
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                
                if (uiArrayLenB>0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            const char * pLinea = hb_itemGetCPtr( pAAAA );
                            hb_itemRelease( pAAAA );
                            char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                            strcpy(cLinea,pLinea);
                            const char * cFuente = cLinea;
                      
                            for(j=1; j<=uiArrayLenB; j++){
                               PHB_ITEM pBB = hb_itemArrayGet( pB, j);

                               char * Str = FUNSTRTRAN((const char *)cFuente, 
                                    hb_itemGetCPtr( pBB ), 
                                    hb_itemGetCPtr( pD ), pOcurr, pNumre);
                               
                               hb_itemRelease(pBB);
                         
                               const char * Buff = Str;
                               free(cLinea);
                               if (Buff!=NULL){
                                  ////  printf("\nDATO OBTENIDO: %s\n",Buff);
                                  cLinea = (char *)calloc(strlen(Buff)+1,1);
                                  strcpy(cLinea,Buff);
                                  cFuente = cLinea;
                               }else{
                                  strOk=0;
                                  //  printf("\nPASO POR NULL\n");
                                  hb_itemRelease(pAAA);
                                  hb_itemRelease(pCCC);
                                  hb_itemRelease(pAA);
                                  hb_itemRelease(pCC);
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) {break;}
                            hb_arraySetC( pCCC, o, (const char *)cFuente);
                            free(cLinea);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCC, m, pCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0;}
                break;
             }
             case 3 : 
             { //
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                
                if (uiArrayLenD>0){   
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            const char * pLinea = hb_itemGetCPtr( pAAAA );
                            hb_itemRelease( pAAAA );
                            char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                            strcpy(cLinea,pLinea);
                            const char * cFuente = cLinea;
                      
                            for(j=1; j<=uiArrayLenD; j++){
                               PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                               char * Str = FUNSTRTRAN((const char *)cFuente, 
                                    hb_itemGetCPtr( pB ), 
                                    hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                               
                               hb_itemRelease(pDD);
                         
                               const char * Buff = Str;
                               free(cLinea);
                               if (Buff!=NULL){
                                  ////  printf("\nDATO OBTENIDO: %s\n",Buff);
                                  cLinea = (char *)calloc(strlen(Buff)+1,1);
                                  strcpy(cLinea,Buff);
                                  cFuente = cLinea;
                               }else{
                                  strOk=0;
                                  //  printf("\nPASO POR NULL\n");
                                  hb_itemRelease(pAAA);
                                  hb_itemRelease(pCCC);
                                  hb_itemRelease(pAA);
                                  hb_itemRelease(pCC);
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) {break;}
                            hb_arraySetC( pCCC, o, (const char *)cFuente);
                            free(cLinea);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCC, m, pCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0; }
                break;
             }
             case 4 : 
             { //
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         const char * pLinea = hb_itemGetCPtr( pAAAA );
                         hb_itemRelease( pAAAA );
                         char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                         strcpy(cLinea,pLinea);
                         const char * cFuente = cLinea;
                         char * Str = FUNSTRTRAN((const char *)cFuente, 
                              hb_itemGetCPtr( pB ), 
                              hb_itemGetCPtr( pD ), pOcurr, pNumre);
                         const char * Buff = Str;
                         free(cLinea);
                         if (Buff!=NULL){
                            hb_arraySetC( pCCC, o, (const char *)Buff);
                         }else{
                            strOk=0;
                            //  printf("\nPASO POR NULL\n");
                            hb_itemRelease(pAAA);
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCC, m, pCCC);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) {break;}
                   hb_arraySet( pCWM, n, pCC);
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
             }
             break;
          }
          break;
       }
       case 4 : 
       {
          unsigned int n=1,m=1,o=1,p=1;

          switch( codfun ){
             case 1 : 
             {
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                if (uiArrayLenB == uiArrayLenD  && uiArrayLenB > 0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                            for( p=1; p<=pBlk; p++){
                            
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               const char * pLinea = hb_itemGetCPtr( pAAAAA );
                               hb_itemRelease( pAAAAA );
                               char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                               strcpy(cLinea,pLinea);
                               const char * cFuente = cLinea;
                      
                               for(j=1; j<=uiArrayLenB; j++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                                  PHB_ITEM pDD = hb_itemArrayGet( pD, j); 
                                  char * Str = FUNSTRTRAN((const char *)cFuente, 
                                       hb_itemGetCPtr( pBB ), 
                                       hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                                  hb_itemRelease(pBB);
                                  hb_itemRelease(pDD);
                         
                                  const char * Buff = Str;
                                  free(cLinea);
                                  if (Buff!=NULL){
                                     cLinea = (char *)calloc(strlen(Buff)+1,1);
                                     strcpy(cLinea,Buff);
                                     cFuente = cLinea;
                                  }else{
                                     strOk=0;
                                     hb_itemRelease(pAAAA);
                                     hb_itemRelease(pCCCC);
                                     hb_itemRelease(pAAA);
                                     hb_itemRelease(pCCC);
                                     hb_itemRelease(pAA);
                                     hb_itemRelease(pCC);
                                     break;
                                  }
                                  free(Str);
                               }
                               if ( !strOk ) {break;}
                               hb_arraySetC( pCCCC, p, (const char *)cFuente);
                               free(cLinea);
                            }
                            if ( !strOk ) {break;}
                            hb_arraySet( pCCC, o, pCCCC);
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCC, m, pCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0; }
                break;
             }
             case 2 :
             { // 
                long uiArrayLenB = ( long ) hb_arrayLen( pB );
                
                if (uiArrayLenB>0){
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                            for( p=1; p<=pBlk; p++){
                            
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               const char * pLinea = hb_itemGetCPtr( pAAAAA );
                               hb_itemRelease( pAAAAA );
                               char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                               strcpy(cLinea,pLinea);
                               const char * cFuente = cLinea;
                      
                               for(j=1; j<=uiArrayLenB; j++){
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, j);
                                  char * Str = FUNSTRTRAN((const char *)cFuente, 
                                       hb_itemGetCPtr( pBB ), 
                                       hb_itemGetCPtr( pD ), pOcurr, pNumre);
                                  hb_itemRelease(pBB);
                         
                                  const char * Buff = Str;
                                  free(cLinea);
                                  if (Buff!=NULL){
                                     cLinea = (char *)calloc(strlen(Buff)+1,1);
                                     strcpy(cLinea,Buff);
                                     cFuente = cLinea;
                                  }else{
                                     strOk=0;
                                     hb_itemRelease(pAAAA);
                                     hb_itemRelease(pCCCC);
                                     hb_itemRelease(pAAA);
                                     hb_itemRelease(pCCC);
                                     hb_itemRelease(pAA);
                                     hb_itemRelease(pCC);
                                     break;
                                  }
                                  free(Str);
                               }
                               if ( !strOk ) {break;}
                               hb_arraySetC( pCCCC, p, (const char *)cFuente);
                               free(cLinea);
                            }
                            if ( !strOk ) {break;}
                            hb_arraySet( pCCC, o, pCCCC);
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCC, m, pCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0; }
                break;
             }
             case 3 : 
             { //
                long uiArrayLenD = ( long ) hb_arrayLen( pD );
                
                if (uiArrayLenD>0){   
                   long j;
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                            for( p=1; p<=pBlk; p++){
                            
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               const char * pLinea = hb_itemGetCPtr( pAAAAA );
                               hb_itemRelease( pAAAAA );
                               char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                               strcpy(cLinea,pLinea);
                               const char * cFuente = cLinea;
                      
                               for(j=1; j<=uiArrayLenD; j++){
                                  PHB_ITEM pDD = hb_itemArrayGet( pD, j);
                                  char * Str = FUNSTRTRAN((const char *)cFuente, 
                                  hb_itemGetCPtr( pB ), 
                                  hb_itemGetCPtr( pDD ), pOcurr, pNumre);
                                  hb_itemRelease(pDD);
                         
                                  const char * Buff = Str;
                                  free(cLinea);
                                  if (Buff!=NULL){
                                     cLinea = (char *)calloc(strlen(Buff)+1,1);
                                     strcpy(cLinea,Buff);
                                     cFuente = cLinea;
                                  }else{
                                     strOk=0;
                                     hb_itemRelease(pAAAA);
                                     hb_itemRelease(pCCCC);
                                     hb_itemRelease(pAAA);
                                     hb_itemRelease(pCCC);
                                     hb_itemRelease(pAA);
                                     hb_itemRelease(pCC);
                                     break;
                                  }
                                  free(Str);
                               }
                               if ( !strOk ) {break;}
                               hb_arraySetC( pCCCC, p, (const char *)cFuente);
                               free(cLinea);
                            }
                            if ( !strOk ) {break;}
                            hb_arraySet( pCCC, o, pCCCC);
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCC, m, pCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCWM, n, pCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                } else { strOk = 0; }
                break;
             }
             case 4 : 
             { //
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            const char * pLinea = hb_itemGetCPtr( pAAAAA );
                            hb_itemRelease( pAAAAA );
                            char * cLinea = (char *)calloc(strlen( pLinea )+1,1);
                            strcpy(cLinea,pLinea);
                            const char * cFuente = cLinea;
                   
                            char * Str = FUNSTRTRAN((const char *)cFuente, 
                                 hb_itemGetCPtr( pB ), 
                                 hb_itemGetCPtr( pD ), pOcurr, pNumre);
                            const char * Buff = Str;
                            free(cLinea);
                            if (Buff!=NULL){
                               hb_arraySetC( pCCCC, p, (const char *)Buff);
                            }else{
                               strOk=0;
                               hb_itemRelease(pAAAA);
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pAAA);
                               hb_itemRelease(pCCC);
                               hb_itemRelease(pAA);
                               hb_itemRelease(pCC);
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) {break;}
                         hb_arraySet( pCCC, o, pCCCC);
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);
                      }
                      if ( !strOk ) {break;}
                      hb_arraySet( pCC, m, pCCC);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) {break;}
                   hb_arraySet( pCWM, n, pCC);
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       } 
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

// XSTKMINMAX(FUENTE,DIM1,DIM1R,DIM1C,DIM1P,DIM1B,EIX)
HB_FUNC( XSTKMINMAX )
{
   PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // ARRAY A BUSCAR
   unsigned int pDim = hb_parni( 2 );
   unsigned int pRow = hb_parni( 3 );
   unsigned int pCol = hb_parni( 4 );
   unsigned int pPag = hb_parni( 5 );
   unsigned int pBlk = hb_parni( 6 );
   unsigned int codfun = hb_parni( 7 );  // 1=max, 2=min
   
   double vRet = 0, pScan;  // min o max a devolver
   
   switch( pDim ){
      case 1 : // 1D
      {
         unsigned int n;
         PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
         vRet = hb_itemGetND( pAA );
         hb_itemRelease(pAA);
         for(n=2;n<=pRow;n++){
            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
            pScan = hb_itemGetND( hb_itemArrayGet( pA, n) );
            hb_itemRelease(pAA);
            if( codfun == 1){  // maximo de la lista
              if( vRet < pScan )
                 vRet = pScan;
            }else{             // busca el minimo
              if( vRet > pScan )
                 vRet = pScan;
            }
         }
         break;
      }
      case 2 :
      {
         unsigned int n=1,m=1;
         long i,ndx;

         ndx = pRow*pCol;
         
         PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
         PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1);
         vRet = hb_itemGetND( pAAA );
         hb_itemRelease(pAAA);
         hb_itemRelease(pAA);
         for(i=1;i<=ndx;i++){
            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
            pScan = hb_itemGetND( pAAA );
            hb_itemRelease(pAAA);
            hb_itemRelease(pAA);
            if( codfun == 1){  // maximo de la lista
              if( vRet < pScan )
                 vRet = pScan;
            }else{             // busca el minimo
              if( vRet > pScan )
                 vRet = pScan;
            }
            if ( ++m > pCol ){
               m=1;
               ++n;
            }
         }
         break;
      }
      case 3 :
      {
         unsigned int n=1,m=1,o=1;
         long i,ndx;

         ndx = pRow*pCol*pPag;
         
         PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
         PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1);
         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, 1);
         vRet = hb_itemGetND( pAAAA );
         hb_itemRelease(pAAAA);
         hb_itemRelease(pAAA);
         hb_itemRelease(pAA);
         
         for(i=1;i<=ndx;i++){
            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
            pScan = hb_itemGetND( pAAAA );
            hb_itemRelease(pAAAA);
            hb_itemRelease(pAAA);
            hb_itemRelease(pAA);
            if( codfun == 1){  // maximo de la lista
              if( vRet < pScan )
                 vRet = pScan;
            }else{             // busca el minimo
              if( vRet > pScan )
                 vRet = pScan;
            }
            if ( ++o > pPag ){
                o=1;
                if ( ++m > pCol ){
                   m=1;
                   ++n;
               }
            }
         }
         break;
      }
      case 4 :
      {
         unsigned int n=1,m=1,o=1,p=1;
         long i,ndx;
         
         ndx = pRow*pCol*pPag*pBlk;
         
         PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
         PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1);
         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, 1);
         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, 1);
         vRet = hb_itemGetND( pAAAAA );
         hb_itemRelease(pAAAAA);
         hb_itemRelease(pAAAA);
         hb_itemRelease(pAAA);
         hb_itemRelease(pAA);
         
         for(i=1;i<=ndx;i++){
            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
            PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
            pScan = hb_itemGetND( pAAAAA );
            hb_itemRelease(pAAAAA);
            hb_itemRelease(pAAAA);
            hb_itemRelease(pAAA);
            hb_itemRelease(pAA);
            if( codfun == 1){  // maximo de la lista
              if( vRet < pScan )
                 vRet = pScan;
            }else{             // busca el minimo
              if( vRet > pScan )
                 vRet = pScan;
            }
            if ( ++p > pBlk ){
               p=1;
               if ( ++o > pPag ){
                  o=1;
                  if ( ++m > pCol ){
                     m=1;
                     ++n;
                  }
               }
            }
         }
         break;
      }
   }
   hb_retnd( vRet );
}

// XFUNPUTRANGE(FUENTE,AX,POS,{DIM2,DIM3R,DIM2R,DIM2C,DIM2P,DIM2B,EPX,EVX})==0
// TIENE QUE RECIBIR pCWM PORQUE SOLO SE MODIFICARÁN ALGUNOS DATOS. ESTO ES, DEBO COPIAR
// A LA MISMA POSICIÓN AQUELLOS DATOS QUE NO SON MODIFICADOS.
// NO PUEDO CAMBIAR LOS DATOS DIRECTAMENTE EN PCWM, PORQUE GENERARIA PERDIDA DE DATOS
HB_FUNC( XFUNPUTRANGE )
{
    PHB_ITEM pCW = hb_param( 1, HB_IT_ARRAY ); // TARGET
    PHB_ITEM pA  = hb_param( 2, HB_IT_ANY ); // A = ARRAY 1D FUENTE. PUEDE SER UN SINGLE
    PHB_ITEM pB  = hb_param( 3, HB_IT_ARRAY ); // B = POSICIONES DEL TARGET
    PHB_ITEM params   = hb_param( 4, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    PHB_ITEM p8 = hb_itemArrayGet( params, 8);
    PHB_ITEM p9 = hb_itemArrayGet( params, 9);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de TARGET
    unsigned int pRow = hb_itemGetNI( p2 );   // rows POS
    unsigned int pCol = hb_itemGetNI( p3 );   // cols POS
    unsigned int aRow = hb_itemGetNI( p4 );   // rows FUENTE
    unsigned int aCol = hb_itemGetNI( p5 );   // cols  "
    unsigned int aPag = hb_itemGetNI( p6 );   // pags  "
    unsigned int aBlk = hb_itemGetNI( p7 );   // blks  "
    int pTyp          = hb_itemGetNI( p8 );   // tipo de array FUENTE
    int pTel          = hb_itemGetNI( p9 );  // si es elemento 0 o array 1
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
    hb_itemRelease(p8);
    hb_itemRelease(p9);
    
    PHB_ITEM pCWM = NULL;
    
    int mtOk = 1;
    if( pDim == 1 ){
       if( pCol > 0 ) mtOk = 0;
    }else if( pDim != pCol ) mtOk = 0;

    
    if( mtOk && pRow ) {
       
       switch( pDim )
       {
          case 1 : // 1D
          {
             unsigned int n,pos=1;
             long pPos=0;

             switch( pTyp ){
                case 1 : // string
                {
                   pCWM = hb_itemArrayNew( aRow ); // CWM
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   pPos = hb_itemGetNI( pBB );
                   hb_itemRelease(pBB);
                   if ( pPos <= 0 || pPos > aRow ){
                      mtOk = 0;
                      break;  // salgo del switch
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      for( n=1; n<=aRow; n++){
                         if( sw && n == pPos ){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, pos);
                            hb_arraySetC( pCWM, pPos, (const char *) hb_itemGetCPtr( pAA ) );
                            hb_itemRelease(pAA);
                            if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                               sw=0;
                            }else{
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pos);
                               pPos = hb_itemGetNI( pBB );
                               hb_itemRelease(pBB);
                               if ( pPos <= 0 || pPos > aRow ){
                                  mtOk = 0;
                                  break;  // salgo del switch
                               }
                            }
                         }else{
                            PHB_ITEM pAA = hb_itemArrayGet( pCW, n);
                            hb_arraySetC( pCWM, n, (const char *) hb_itemGetCPtr( pAA ) );
                            hb_itemRelease(pAA);
                         }
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      const char * cElement = hb_itemGetCPtr( pA );
                      for( n=1; n<=aRow; n++){
                         if( sw && n == pPos ){
                            hb_arraySetC( pCWM, pPos, (const char *) cElement );
                            if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                               sw=0;
                            }else{
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pos);
                               pPos = hb_itemGetNI( pBB );
                               hb_itemRelease(pBB);
                               if ( pPos <= 0 || pPos > aRow ){
                                  mtOk = 0;
                                  break;  // salgo del switch
                               }
                            }
                         }else{
                            PHB_ITEM pAA = hb_itemArrayGet( pCW, n);
                            hb_arraySetC( pCWM, n, (const char *) hb_itemGetCPtr( pAA ) );
                            hb_itemRelease(pAA);
                         }
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 2 : // numero
                {
                   pCWM = hb_itemArrayNew( aRow ); // CWM
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   pPos = hb_itemGetNI( pBB );
                   hb_itemRelease(pBB);
                   if ( pPos <= 0 || pPos > aRow ){
                      mtOk = 0;
                      break;  // salgo del switch
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      for( n=1; n<=aRow; n++){
                         ///////printf("\nN=%d, pPOS = %ld\n",n,pPos);
                         if( sw && n == pPos ){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, pos);
                            hb_arraySetND( pCWM, pPos, (double) hb_itemGetND( pAA ) );
                            hb_itemRelease(pAA);
                            if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                               sw=0;
                            }else{
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pos);
                               pPos = hb_itemGetNI( pBB );
                               hb_itemRelease(pBB);
                               if ( pPos <= 0 || pPos > aRow ){
                                  mtOk = 0;
                                  break;  // salgo del switch
                               }
                            }
                         }else{
                            PHB_ITEM pAA = hb_itemArrayGet( pCW, n);
                            hb_arraySetND( pCWM, n, (double) hb_itemGetND( pAA ) );
                            hb_itemRelease(pAA);
                         }
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) {
                         mtOk = 0;
                      }
                   }else{    // es solo un elemento [>a rango]<-0
                      double nElement = hb_itemGetND( pA );
                      for( n=1; n<=aRow; n++){
                         if( sw && n == pPos ){
                            hb_arraySetND( pCWM, pPos, (double) nElement );
                            if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                               sw=0;
                            }else{
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pos);
                               pPos = hb_itemGetNI( pBB );
                               hb_itemRelease(pBB);
                               if ( pPos <= 0 || pPos > aRow ){
                                  mtOk = 0;
                                  
                                  break;  // salgo del switch
                               }
                            }
                         }else{
                            PHB_ITEM pAA = hb_itemArrayGet( pCW, n);
                            hb_arraySetND( pCWM, n, (double) hb_itemGetND( pAA ) );
                            hb_itemRelease(pAA);
                         }
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) {
                         mtOk = 0;
                      }
                   }
                   break;
                }
                case 3 : // logica
                {
                   pCWM = hb_itemArrayNew( aRow ); // CWM
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   pPos = hb_itemGetNI( pBB );
                   hb_itemRelease(pBB);
                   if ( pPos <= 0 || pPos > aRow ){
                      mtOk = 0;
                      break;  // salgo del switch
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      for( n=1; n<=aRow; n++){
                         if( sw && n == pPos ){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, pos);
                            hb_arraySetL( pCWM, pPos, (HB_BOOL) hb_itemGetL( pAA ) );
                            hb_itemRelease(pAA);
                            if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                               sw=0;
                            }else{
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pos);
                               pPos = hb_itemGetNI( pBB );
                               hb_itemRelease(pBB);
                               if ( pPos <= 0 || pPos > aRow ){
                                  mtOk = 0;
                                  break;  // salgo del switch
                               }
                            }
                         }else{
                            PHB_ITEM pAA = hb_itemArrayGet( pCW, n);
                            hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAA ) );
                            hb_itemRelease(pAA);
                         }
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-0
                      HB_BOOL lElement = hb_itemGetL( pA );
                      for( n=1; n<=aRow; n++){
                         if( sw && n == pPos ){
                            hb_arraySetL( pCWM, pPos, (HB_BOOL) lElement );
                            if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                               sw=0;
                            }else{
                               PHB_ITEM pBB = hb_itemArrayGet( pB, pos);
                               pPos = hb_itemGetNI( pBB );
                               hb_itemRelease(pBB);
                               if ( pPos <= 0 || pPos > aRow ){
                                  mtOk = 0;
                                  break;  // salgo del switch
                               }
                            }
                         }else{
                            PHB_ITEM pAA = hb_itemArrayGet( pCW, n);
                            hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAA ) );
                            hb_itemRelease(pAA);
                         }
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
             }
             break;
          }
          case 2 : // 2D
          {
             unsigned int n,m,pos=1;
             long pPos1=0, pPos2=0;
                
             switch( pTyp ){
                case 1 : // string
                {
                   
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                      mtOk = 0;
                      break;
                   } 
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            if( sw && n == pPos1 && m == pPos2 ){
                               PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                               hb_arraySetC( pCC, m, (const char *) hb_itemGetCPtr( pAA ) );
                               hb_itemRelease(pAA);
                               if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                  sw=0;
                               }else{
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                  PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                  PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                  pPos1 = hb_itemGetNI( pBB1 );
                                  pPos2 = hb_itemGetNI( pBB2 );
                                  hb_itemRelease(pBB1);
                                  hb_itemRelease(pBB2);
                                  hb_itemRelease(pBB);
                                  if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                                     mtOk = 0;
                                     hb_itemRelease(pCC);
                                     hb_itemRelease(pCCW);
                                     break;
                                  } 
                               }
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pCCW, m);
                               hb_arraySetC( pCC, m, (const char *) hb_itemGetCPtr( pAA ) );
                               hb_itemRelease(pAA);
                            }
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      const char * cElement = hb_itemGetCPtr( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            if( sw && n == pPos1 && m == pPos2 ){
                               hb_arraySetC( pCC, m, (const char *) cElement );
                               if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                  sw=0;
                               }else{
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                  PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                  PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                  pPos1 = hb_itemGetNI( pBB1 );
                                  pPos2 = hb_itemGetNI( pBB2 );
                                  hb_itemRelease(pBB1);
                                  hb_itemRelease(pBB2);
                                  hb_itemRelease(pBB);
                                  if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                                     mtOk = 0;
                                     hb_itemRelease(pCC);
                                     hb_itemRelease(pCCW);
                                     break;
                                  } 
                               }
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pCCW, m);
                               hb_arraySetC( pCC, m, (const char *) hb_itemGetCPtr( pAA ) );
                               hb_itemRelease(pAA);
                            }
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 2 : // numero
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                      mtOk = 0;
                      break;
                   } 
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            if( sw && n == pPos1 && m == pPos2 ){
                               PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                               hb_arraySetND( pCC, m, (double) hb_itemGetND( pAA ) );
                               hb_itemRelease(pAA);
                               if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                  sw=0;
                               }else{
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                  PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                  PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                  pPos1 = hb_itemGetNI( pBB1 );
                                  pPos2 = hb_itemGetNI( pBB2 );
                                  hb_itemRelease(pBB1);
                                  hb_itemRelease(pBB2);
                                  hb_itemRelease(pBB);
                                  if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                                     mtOk = 0;
                                     hb_itemRelease(pCC);
                                     hb_itemRelease(pCCW);
                                     break;
                                  } 
                               }
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pCCW, m);
                               hb_arraySetND( pCC, m, (double) hb_itemGetND( pAA ) );
                               hb_itemRelease(pAA);
                            }
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      double nElement = hb_itemGetND( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            if( sw && n == pPos1 && m == pPos2 ){
                               hb_arraySetND( pCC, m, (double) nElement );
                               if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                  sw=0;
                               }else{
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                  PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                  PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                  pPos1 = hb_itemGetNI( pBB1 );
                                  pPos2 = hb_itemGetNI( pBB2 );
                                  hb_itemRelease(pBB1);
                                  hb_itemRelease(pBB2);
                                  hb_itemRelease(pBB);
                                  if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                                     mtOk = 0;
                                     hb_itemRelease(pCC);
                                     hb_itemRelease(pCCW);
                                     break;
                                  } 
                               }
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pCCW, m);
                               hb_arraySetND( pCC, m, (double) hb_itemGetND( pAA ) );
                               hb_itemRelease(pAA);
                            }
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 3 : // logica
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                      mtOk = 0;
                      break;
                   } 
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            if( sw && n == pPos1 && m == pPos2 ){
                               PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                               hb_arraySetL( pCC, m, (HB_BOOL) hb_itemGetL( pAA ) );
                               hb_itemRelease(pAA);
                               if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                  sw=0;
                               }else{
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                  PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                  PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                  pPos1 = hb_itemGetNI( pBB1 );
                                  pPos2 = hb_itemGetNI( pBB2 );
                                  hb_itemRelease(pBB1);
                                  hb_itemRelease(pBB2);
                                  hb_itemRelease(pBB);
                                  if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                                     mtOk = 0;
                                     hb_itemRelease(pCC);
                                     hb_itemRelease(pCCW);
                                     break;
                                  } 
                               }
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pCCW, m);
                               hb_arraySetL( pCC, m, (HB_BOOL) hb_itemGetL( pAA ) );
                               hb_itemRelease(pAA);
                            }
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      HB_BOOL lElement = hb_itemGetL( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            if( sw && n == pPos1 && m == pPos2 ){
                               hb_arraySetL( pCC, m, (HB_BOOL) lElement );
                               if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                  sw=0;
                               }else{
                                  PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                  PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                  PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                  pPos1 = hb_itemGetNI( pBB1 );
                                  pPos2 = hb_itemGetNI( pBB2 );
                                  hb_itemRelease(pBB1);
                                  hb_itemRelease(pBB2);
                                  hb_itemRelease(pBB);
                                  if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                                     mtOk = 0;
                                     hb_itemRelease(pCC);
                                     hb_itemRelease(pCCW);
                                     break;
                                  } 
                               }
                            }else{
                               PHB_ITEM pAA = hb_itemArrayGet( pCCW, m);
                               hb_arraySetL( pCC, m, (HB_BOOL) hb_itemGetL( pAA ) );
                               hb_itemRelease(pAA);
                            }
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
             }
             break;
          }
          case 3 :  // 3D
          {
             unsigned int n,m,o,pos=1;
             HB_MAXINT pPos1=0, pPos2=0, pPos3=0;

             switch( pTyp ){
                case 1 : // string
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                        pPos3 <= 0 || pPos3 > aPag ){
                      mtOk = 0;
                      break;
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               if( sw && n == pPos1 && m == pPos2 && o == pPos3 ){
                                  PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                                  hb_arraySetC( pCCC, o, (const char *) hb_itemGetCPtr( pAA ) );
                                  hb_itemRelease(pAA);
                                  if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                     sw=0;
                                  }else{
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                     PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                     PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                     PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                     pPos1 = hb_itemGetNI( pBB1 );
                                     pPos2 = hb_itemGetNI( pBB2 );
                                     pPos3 = hb_itemGetNI( pBB3 );
                                     hb_itemRelease(pBB1);
                                     hb_itemRelease(pBB2);
                                     hb_itemRelease(pBB3);
                                     hb_itemRelease(pBB);
                                     if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                          pPos3 <= 0 || pPos3 > aPag ){
                                        mtOk = 0;
                                        hb_itemRelease(pCCC);
                                        hb_itemRelease(pCCCW);
                                        hb_itemRelease(pCC);
                                        hb_itemRelease(pCCW);
                                        break;
                                     } 
                                  }
                               }else{
                                  PHB_ITEM pAA = hb_itemArrayGet( pCCCW, o);
                                  hb_arraySetC( pCCC, o, (const char *) hb_itemGetCPtr( pAA ) );
                                  hb_itemRelease(pAA);
                               }
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      const char * cElement = hb_itemGetCPtr( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               if( sw && n == pPos1 && m == pPos2 && o == pPos3 ){
                                  hb_arraySetC( pCCC, o, (const char *) cElement );
                                  if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                     sw=0;
                                  }else{
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                     PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                     PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                     PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                     pPos1 = hb_itemGetNI( pBB1 );
                                     pPos2 = hb_itemGetNI( pBB2 );
                                     pPos3 = hb_itemGetNI( pBB3 );
                                     hb_itemRelease(pBB1);
                                     hb_itemRelease(pBB2);
                                     hb_itemRelease(pBB3);
                                     hb_itemRelease(pBB);
                                     if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                          pPos3 <= 0 || pPos3 > aPag ){
                                        mtOk = 0;
                                        hb_itemRelease(pCCC);
                                        hb_itemRelease(pCCCW);
                                        hb_itemRelease(pCC);
                                        hb_itemRelease(pCCW);
                                        break;
                                     } 
                                  }
                               }else{
                                  PHB_ITEM pAA = hb_itemArrayGet( pCCCW, o);
                                  hb_arraySetC( pCCC, o, (const char *) hb_itemGetCPtr( pAA ) );
                                  hb_itemRelease(pAA);
                               }
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 2 : // numero
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                        pPos3 <= 0 || pPos3 > aPag ){
                      mtOk = 0;
                      break;
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               if( sw && n == pPos1 && m == pPos2 && o == pPos3 ){
                                  PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                                  hb_arraySetND( pCCC, o, (double) hb_itemGetND( pAA ) );
                                  hb_itemRelease(pAA);
                                  if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                     sw=0;
                                  }else{
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                     PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                     PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                     PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                     pPos1 = hb_itemGetNI( pBB1 );
                                     pPos2 = hb_itemGetNI( pBB2 );
                                     pPos3 = hb_itemGetNI( pBB3 );
                                     hb_itemRelease(pBB1);
                                     hb_itemRelease(pBB2);
                                     hb_itemRelease(pBB3);
                                     hb_itemRelease(pBB);
                                     if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                          pPos3 <= 0 || pPos3 > aPag ){
                                        mtOk = 0;
                                        hb_itemRelease(pCCC);
                                        hb_itemRelease(pCCCW);
                                        hb_itemRelease(pCC);
                                        hb_itemRelease(pCCW);
                                        break;
                                     } 
                                  }
                               }else{
                                  PHB_ITEM pAA = hb_itemArrayGet( pCCCW, o);
                                  hb_arraySetND( pCCC, o, (double) hb_itemGetND( pAA ) );
                                  hb_itemRelease(pAA);
                               }
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      double nElement = hb_itemGetND( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               if( sw && n == pPos1 && m == pPos2 && o == pPos3 ){
                                  hb_arraySetND( pCCC, o, (double) nElement );
                                  if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                     sw=0;
                                  }else{
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                     PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                     PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                     PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                     pPos1 = hb_itemGetNI( pBB1 );
                                     pPos2 = hb_itemGetNI( pBB2 );
                                     pPos3 = hb_itemGetNI( pBB3 );
                                     hb_itemRelease(pBB1);
                                     hb_itemRelease(pBB2);
                                     hb_itemRelease(pBB3);
                                     hb_itemRelease(pBB);
                                     if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                          pPos3 <= 0 || pPos3 > aPag ){
                                        mtOk = 0;
                                        hb_itemRelease(pCCC);
                                        hb_itemRelease(pCCCW);
                                        hb_itemRelease(pCC);
                                        hb_itemRelease(pCCW);
                                        break;
                                     } 
                                  }
                               }else{
                                  PHB_ITEM pAA = hb_itemArrayGet( pCCCW, o);
                                  hb_arraySetND( pCCC, o, (double) hb_itemGetND( pAA ) );
                                  hb_itemRelease(pAA);
                               }
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 3 : // logica
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                        pPos3 <= 0 || pPos3 > aPag ){
                      mtOk = 0;
                      break;
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               if( sw && n == pPos1 && m == pPos2 && o == pPos3 ){
                                  PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                                  hb_arraySetL( pCCC, o, (HB_BOOL) hb_itemGetL( pAA ) );
                                  hb_itemRelease(pAA);
                                  if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                     sw=0;
                                  }else{
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                     PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                     PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                     PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                     pPos1 = hb_itemGetNI( pBB1 );
                                     pPos2 = hb_itemGetNI( pBB2 );
                                     pPos3 = hb_itemGetNI( pBB3 );
                                     hb_itemRelease(pBB1);
                                     hb_itemRelease(pBB2);
                                     hb_itemRelease(pBB3);
                                     hb_itemRelease(pBB);
                                     if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                          pPos3 <= 0 || pPos3 > aPag ){
                                        mtOk = 0;
                                        hb_itemRelease(pCCC);
                                        hb_itemRelease(pCCCW);
                                        hb_itemRelease(pCC);
                                        hb_itemRelease(pCCW);
                                        break;
                                     } 
                                  }
                               }else{
                                  PHB_ITEM pAA = hb_itemArrayGet( pCCCW, o);
                                  hb_arraySetL( pCCC, o, (HB_BOOL) hb_itemGetL( pAA ) );
                                  hb_itemRelease(pAA);
                               }
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      HB_BOOL lElement = hb_itemGetL( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               if( sw && n == pPos1 && m == pPos2 && o == pPos3 ){
                                  hb_arraySetL( pCCC, o, (HB_BOOL) lElement );
                                  if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                     sw=0;
                                  }else{
                                     PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                     PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                     PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                     PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                     pPos1 = hb_itemGetNI( pBB1 );
                                     pPos2 = hb_itemGetNI( pBB2 );
                                     pPos3 = hb_itemGetNI( pBB3 );
                                     hb_itemRelease(pBB1);
                                     hb_itemRelease(pBB2);
                                     hb_itemRelease(pBB3);
                                     hb_itemRelease(pBB);
                                     if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                          pPos3 <= 0 || pPos3 > aPag ){
                                        mtOk = 0;
                                        hb_itemRelease(pCCC);
                                        hb_itemRelease(pCCCW);
                                        hb_itemRelease(pCC);
                                        hb_itemRelease(pCCW);
                                        break;
                                     } 
                                  }
                               }else{
                                  PHB_ITEM pAA = hb_itemArrayGet( pCCCW, o);
                                  hb_arraySetL( pCCC, o, (HB_BOOL) hb_itemGetL( pAA ) );
                                  hb_itemRelease(pAA);
                               }
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
             }
             break;
          }
          case 4 :  // 4D
          {
             unsigned int n,m,o,p,pos=1;
             HB_MAXINT pPos1, pPos2, pPos3, pPos4;

             switch( pTyp ){
                case 1 : // string
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   pPos4 = hb_itemGetNI( pBB4 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB4);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                       pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                       mtOk = 0;
                       break;
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               PHB_ITEM pCCCC = hb_itemArrayNew( aBlk ); // CWM
                               PHB_ITEM pCCCCW = hb_itemArrayGet( pCCCW, o);
                               for( p=1; p<=aBlk; p++){
                            
                                  if( sw && n == pPos1 && m == pPos2 && o == pPos3 && p == pPos4 ){
                                     PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                                     hb_arraySetC( pCCCC, p, (const char *) hb_itemGetCPtr( pAA ) );
                                     hb_itemRelease(pAA);
                                     if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                        sw=0;
                                     }else{
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                        PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                        PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                        PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                        PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                                        pPos1 = hb_itemGetNI( pBB1 );
                                        pPos2 = hb_itemGetNI( pBB2 );
                                        pPos3 = hb_itemGetNI( pBB3 );
                                        pPos4 = hb_itemGetNI( pBB4 );
                                        hb_itemRelease(pBB1);
                                        hb_itemRelease(pBB2);
                                        hb_itemRelease(pBB3);
                                        hb_itemRelease(pBB4);
                                        hb_itemRelease(pBB);
                                        if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){ 
                                           mtOk = 0;
                                           hb_itemRelease(pCCCC);
                                           hb_itemRelease(pCCCCW);
                                           hb_itemRelease(pCCC);
                                           hb_itemRelease(pCCCW);
                                           hb_itemRelease(pCC);
                                           hb_itemRelease(pCCW);
                                           break;
                                        } 
                                     }
                                  }else{
                                     PHB_ITEM pAA = hb_itemArrayGet( pCCCCW, p);
                                     hb_arraySetC( pCCCC, p, (const char *) hb_itemGetCPtr( pAA ) );
                                     hb_itemRelease(pAA);
                                  }
                               }
                               if ( !mtOk ) break;
                               hb_arraySet( pCCC, o, pCCCC );
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pCCCCW);
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      const char * cElement = hb_itemGetCPtr( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               PHB_ITEM pCCCC = hb_itemArrayNew( aBlk ); // CWM
                               PHB_ITEM pCCCCW = hb_itemArrayGet( pCCCW, o);
                               for( p=1; p<=aBlk; p++){
                            
                                  if( sw && n == pPos1 && m == pPos2 && o == pPos3 && p == pPos4 ){
                                     hb_arraySetC( pCCCC, p, (const char *) cElement );
                                     if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                        sw=0;
                                     }else{
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                        PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                        PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                        PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                        PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                                        pPos1 = hb_itemGetNI( pBB1 );
                                        pPos2 = hb_itemGetNI( pBB2 );
                                        pPos3 = hb_itemGetNI( pBB3 );
                                        pPos4 = hb_itemGetNI( pBB4 );
                                        hb_itemRelease(pBB1);
                                        hb_itemRelease(pBB2);
                                        hb_itemRelease(pBB3);
                                        hb_itemRelease(pBB4);
                                        hb_itemRelease(pBB);
                                        if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){ 
                                           mtOk = 0;
                                           hb_itemRelease(pCCCC);
                                           hb_itemRelease(pCCCCW);
                                           hb_itemRelease(pCCC);
                                           hb_itemRelease(pCCCW);
                                           hb_itemRelease(pCC);
                                           hb_itemRelease(pCCW);
                                           break;
                                        } 
                                     }
                                  }else{
                                     PHB_ITEM pAA = hb_itemArrayGet( pCCCCW, p);
                                     hb_arraySetC( pCCCC, p, (const char *) hb_itemGetCPtr( pAA ) );
                                     hb_itemRelease(pAA);
                                  }
                               }
                               if ( !mtOk ) break;
                               hb_arraySet( pCCC, o, pCCCC );
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pCCCCW);
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 2 : // numero
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   pPos4 = hb_itemGetNI( pBB4 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB4);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                       pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                       mtOk = 0;
                       break;
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               PHB_ITEM pCCCC = hb_itemArrayNew( aBlk ); // CWM
                               PHB_ITEM pCCCCW = hb_itemArrayGet( pCCCW, o);
                               for( p=1; p<=aBlk; p++){
                            
                                  if( sw && n == pPos1 && m == pPos2 && o == pPos3 && p == pPos4 ){
                                     PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                                     hb_arraySetND( pCCCC, p, (double) hb_itemGetND( pAA ) );
                                     hb_itemRelease(pAA);
                                     if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                        sw=0;
                                     }else{
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                        PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                        PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                        PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                        PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                                        pPos1 = hb_itemGetNI( pBB1 );
                                        pPos2 = hb_itemGetNI( pBB2 );
                                        pPos3 = hb_itemGetNI( pBB3 );
                                        pPos4 = hb_itemGetNI( pBB4 );
                                        hb_itemRelease(pBB1);
                                        hb_itemRelease(pBB2);
                                        hb_itemRelease(pBB3);
                                        hb_itemRelease(pBB4);
                                        hb_itemRelease(pBB);
                                        if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){ 
                                           mtOk = 0;
                                           hb_itemRelease(pCCCC);
                                           hb_itemRelease(pCCCCW);
                                           hb_itemRelease(pCCC);
                                           hb_itemRelease(pCCCW);
                                           hb_itemRelease(pCC);
                                           hb_itemRelease(pCCW);
                                           break;
                                        } 
                                     }
                                  }else{
                                     PHB_ITEM pAA = hb_itemArrayGet( pCCCCW, p);
                                     hb_arraySetND( pCCCC, p, (double) hb_itemGetND( pAA ) );
                                     hb_itemRelease(pAA);
                                  }
                               }
                               if ( !mtOk ) break;
                               hb_arraySet( pCCC, o, pCCCC );
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pCCCCW);
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      double nElement = hb_itemGetND( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               PHB_ITEM pCCCC = hb_itemArrayNew( aBlk ); // CWM
                               PHB_ITEM pCCCCW = hb_itemArrayGet( pCCCW, o);
                               for( p=1; p<=aBlk; p++){
                            
                                  if( sw && n == pPos1 && m == pPos2 && o == pPos3 && p == pPos4 ){
                                     hb_arraySetND( pCCCC, p, (double) nElement );
                                     if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                        sw=0;
                                     }else{
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                        PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                        PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                        PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                        PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                                        pPos1 = hb_itemGetNI( pBB1 );
                                        pPos2 = hb_itemGetNI( pBB2 );
                                        pPos3 = hb_itemGetNI( pBB3 );
                                        pPos4 = hb_itemGetNI( pBB4 );
                                        hb_itemRelease(pBB1);
                                        hb_itemRelease(pBB2);
                                        hb_itemRelease(pBB3);
                                        hb_itemRelease(pBB4);
                                        hb_itemRelease(pBB);
                                        if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){ 
                                           mtOk = 0;
                                           hb_itemRelease(pCCCC);
                                           hb_itemRelease(pCCCCW);
                                           hb_itemRelease(pCCC);
                                           hb_itemRelease(pCCCW);
                                           hb_itemRelease(pCC);
                                           hb_itemRelease(pCCW);
                                           break;
                                        } 
                                     }
                                  }else{
                                     PHB_ITEM pAA = hb_itemArrayGet( pCCCCW, p);
                                     hb_arraySetND( pCCCC, p, (double) hb_itemGetND( pAA ) );
                                     hb_itemRelease(pAA);
                                  }
                               }
                               if ( !mtOk ) break;
                               hb_arraySet( pCCC, o, pCCCC );
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pCCCCW);
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
                case 3 : // logica
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   pPos4 = hb_itemGetNI( pBB4 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB4);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                       pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                       mtOk = 0;
                       break;
                   }
                   int sw=1;
                   if ( pTel ){   // es array   [>s rango]<-vector
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               PHB_ITEM pCCCC = hb_itemArrayNew( aBlk ); // CWM
                               PHB_ITEM pCCCCW = hb_itemArrayGet( pCCCW, o);
                               for( p=1; p<=aBlk; p++){
                                  if( sw && n == pPos1 && m == pPos2 && o == pPos3 && p == pPos4 ){
                                     PHB_ITEM pAA = hb_itemArrayGet( pA, pos);                            
                                     hb_arraySetL( pCCCC, p, (HB_BOOL) hb_itemGetL( pAA ) );
                                     hb_itemRelease(pAA);
                                     if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                        sw=0;
                                     }else{
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                        PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                        PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                        PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                        PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                                        pPos1 = hb_itemGetNI( pBB1 );
                                        pPos2 = hb_itemGetNI( pBB2 );
                                        pPos3 = hb_itemGetNI( pBB3 );
                                        pPos4 = hb_itemGetNI( pBB4 );
                                        hb_itemRelease(pBB1);
                                        hb_itemRelease(pBB2);
                                        hb_itemRelease(pBB3);
                                        hb_itemRelease(pBB4);
                                        hb_itemRelease(pBB);
                                        if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){ 
                                           mtOk = 0;
                                           hb_itemRelease(pCCCC);
                                           hb_itemRelease(pCCCCW);
                                           hb_itemRelease(pCCC);
                                           hb_itemRelease(pCCCW);
                                           hb_itemRelease(pCC);
                                           hb_itemRelease(pCCW);
                                           break;
                                        } 
                                     }
                                  }else{
                                     PHB_ITEM pAA = hb_itemArrayGet( pCCCCW, p);
                                     hb_arraySetL( pCCCC, p, (HB_BOOL) hb_itemGetL( pAA ) );
                                     hb_itemRelease(pAA);
                                  }
                               }
                               if ( !mtOk ) break;
                               hb_arraySet( pCCC, o, pCCCC );
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pCCCCW);
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }else{    // es solo un elemento [>a rango]<-"hola"
                      HB_BOOL lElement = hb_itemGetL( pA );
                      pCWM = hb_itemArrayNew( aRow ); // CWM
                      for( n=1; n<=aRow; n++){
                         PHB_ITEM pCC = hb_itemArrayNew( aCol ); // CWM
                         PHB_ITEM pCCW = hb_itemArrayGet( pCW, n);
                         for( m=1; m<=aCol; m++){
                            PHB_ITEM pCCC = hb_itemArrayNew( aPag ); // CWM
                            PHB_ITEM pCCCW = hb_itemArrayGet( pCCW, m);
                            for( o=1; o<=aPag; o++){
                               PHB_ITEM pCCCC = hb_itemArrayNew( aBlk ); // CWM
                               PHB_ITEM pCCCCW = hb_itemArrayGet( pCCCW, o);
                               for( p=1; p<=aBlk; p++){
                                  if( sw && n == pPos1 && m == pPos2 && o == pPos3 && p == pPos4 ){
                                     hb_arraySetL( pCCCC, p, (HB_BOOL) lElement );
                                     if ( ++pos > pRow /*uiArrayLen*/ ){  // llego al limite de array de posiciones
                                        sw=0;
                                     }else{
                                        PHB_ITEM pBB = hb_itemArrayGet( pB, pos);  // examino primera posicion de POS
                                        PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                                        PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                                        PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                                        PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                                        pPos1 = hb_itemGetNI( pBB1 );
                                        pPos2 = hb_itemGetNI( pBB2 );
                                        pPos3 = hb_itemGetNI( pBB3 );
                                        pPos4 = hb_itemGetNI( pBB4 );
                                        hb_itemRelease(pBB1);
                                        hb_itemRelease(pBB2);
                                        hb_itemRelease(pBB3);
                                        hb_itemRelease(pBB4);
                                        hb_itemRelease(pBB);
                                        if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){ 
                                           mtOk = 0;
                                           hb_itemRelease(pCCCC);
                                           hb_itemRelease(pCCCCW);
                                           hb_itemRelease(pCCC);
                                           hb_itemRelease(pCCCW);
                                           hb_itemRelease(pCC);
                                           hb_itemRelease(pCCW);
                                           break;
                                        } 
                                     }
                                  }else{
                                     PHB_ITEM pAA = hb_itemArrayGet( pCCCCW, p);
                                     hb_arraySetL( pCCCC, p, (HB_BOOL) hb_itemGetL( pAA ) );
                                     hb_itemRelease(pAA);
                                  }
                               }
                               if ( !mtOk ) break;
                               hb_arraySet( pCCC, o, pCCCC );
                               hb_itemRelease(pCCCC);
                               hb_itemRelease(pCCCCW);
                            }
                            if ( !mtOk ) break;
                            hb_arraySet( pCC, m, pCCC );
                            hb_itemRelease(pCCC);
                            hb_itemRelease(pCCCW);
                         }
                         if ( !mtOk ) break;
                         hb_arraySet( pCWM, n, pCC );
                         hb_itemRelease(pCC);
                         hb_itemRelease(pCCW);
                      }
                      if ( pos != pRow+1/*uiArrayLen+1*/ ) mtOk = 0;
                   }
                   break;
                }
             }
             break;
          }
       }
    }
    if ( !mtOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

// XFUNGETRANGE(TEMPORAL,FUENTE,POS,{DIM2,DIM1R,DIM1C y los dim de fuente,TYP})
HB_FUNC( XFUNGETRANGE )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = FUENTE
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B = POSICIONES
    PHB_ITEM params   = hb_param( 3, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    PHB_ITEM p8 = hb_itemArrayGet( params, 8);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de FUENTE
    unsigned int pRow = hb_itemGetNI( p2 );   // rows POS
    unsigned int pCol = hb_itemGetNI( p3 );   // cols POS
    unsigned int aRow = hb_itemGetNI( p4 );   // rows FUENTE
    unsigned int aCol = hb_itemGetNI( p5 );   // cols  "
    unsigned int aPag = hb_itemGetNI( p6 );   // pags  "
    unsigned int aBlk = hb_itemGetNI( p7 );   // blks  "
    int pTyp          = hb_itemGetNI( p8 );   // tipo de array FUENTE    

    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
    hb_itemRelease(p8);

    int mtOk = 1;
    if( pDim == 1 ){
       if( pCol > 0 ) mtOk = 0;
    }else if( pDim != pCol ) mtOk = 0;
    
    PHB_ITEM pCWM = NULL;
    
    if( mtOk && pRow ) {
       
       switch( pDim )
       {
          case 1 : // 1D
          {
             unsigned int n=1;
             HB_MAXINT pPos;
             switch( pTyp ){
                case 1 : // string
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      pPos = hb_itemGetNI( pBB );
                      hb_itemRelease(pBB);
                      if ( pPos <= 0 || pPos > aRow ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA = hb_itemArrayGet( pA, pPos);
                      hb_arraySetC( pCWM, n, (const char *) hb_itemGetCPtr( pAA ) );
                      hb_itemRelease(pAA);
                   }
                   break;
                }
                case 2 : // numero
                {
                   /*PHB_ITEM pAA = hb_itemArrayGet( pA, 1 );
                   if ( HB_IS_NUMINT ( pAA ) ){
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         pPos = hb_itemGetNI( pBB );
                         hb_itemRelease(pBB);
                         if ( pPos <= 0 || pPos > aRow ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, pPos);
                         HB_MAXINT nInt = hb_itemGetNInt( pAA );
                         hb_arraySetNInt( pCWM, n, (HB_MAXINT) nInt );
                         hb_itemRelease(pAA);
                      }
                   }else if( HB_IS_NUMERIC( pAA ) ){
                      printf("\nPASA POR NUMERIC\n");
                      hb_itemRelease(pAA);*/
                      
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         pPos = hb_itemGetNI( pBB );
                         hb_itemRelease(pBB);
                         if ( pPos <= 0 || pPos > aRow ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, pPos);
                         double nDouble = hb_itemGetND( pAA );
                         hb_arraySetND( pCWM, n, (double) nDouble );
                         hb_itemRelease(pAA);
                      }
                  /* }else{
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         pPos = hb_itemGetNI( pBB );
                         hb_itemRelease(pBB);
                         if ( pPos <= 0 || pPos > aRow ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, pPos);
                         long nLong = hb_itemGetNL( pAA );
                         hb_arraySetNL( pCWM, n, (long) nLong );
                         hb_itemRelease(pAA);
                      }
                   }*/
                   break;
                }
                case 3 : // logica
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      pPos = hb_itemGetNI( pBB );
                      hb_itemRelease(pBB);
                      if ( pPos <= 0 || pPos > aRow ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA = hb_itemArrayGet( pA, pPos);
                      hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAA ) );
                      hb_itemRelease(pAA);
                   }
                   break;
                }
             }
             break;
          }
          case 2 : // 2D
          {
             unsigned int n=1;
             HB_MAXINT pPos1, pPos2;
 
             switch( pTyp ){
                case 1 : // string
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                      PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                      pPos1 = hb_itemGetNI( pBB1 );
                      pPos2 = hb_itemGetNI( pBB2 );
                      hb_itemRelease(pBB1);
                      hb_itemRelease(pBB2);
                      hb_itemRelease(pBB);
                      if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA = hb_itemArrayGet( pA, pPos1 );
                      PHB_ITEM pAA2 = hb_itemArrayGet( pAA, pPos2 );
                      hb_arraySetC( pCWM, n, (const char *) hb_itemGetCPtr( pAA2 ) );
                      hb_itemRelease(pAA2);
                      hb_itemRelease(pAA);
                   }
                   break;
                }
                case 2 : // numero
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, 1);
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                      mtOk = 0;
                      break;
                   }
                 /*  PHB_ITEM pAA = hb_itemArrayGet( pA, pPos1 );
                   PHB_ITEM pAA2 = hb_itemArrayGet( pA, pPos2 );
                   if ( HB_IS_NUMINT ( pAA2 ) ){
                      hb_itemRelease(pAA2);
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAA2 = hb_itemArrayGet( pAA, pPos2 );
                         hb_arraySetND( pCWM, n, (HB_MAXINT) hb_itemGetNInt( pAA2 ) );
                         hb_itemRelease(pAA2);
                         hb_itemRelease(pAA);
                      }
                      
                   }else if( HB_IS_NUMERIC( pAA2 ) ){
                      hb_itemRelease(pAA2);
                      hb_itemRelease(pAA);
                      */
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAA2 = hb_itemArrayGet( pAA, pPos2 );
                         hb_arraySetND( pCWM, n, (double) hb_itemGetND( pAA2 ) );
                         hb_itemRelease(pAA2);
                         hb_itemRelease(pAA);
                      }
                  /* }else{   // long
                      hb_itemRelease(pAA2);
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAA2 = hb_itemArrayGet( pAA, pPos2 );
                         hb_arraySetND( pCWM, n, (long) hb_itemGetNL( pAA2 ) );
                         hb_itemRelease(pAA2);
                         hb_itemRelease(pAA);
                      }
                   }*/
                   break;
                }
                case 3 : // logica
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                      PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                      pPos1 = hb_itemGetNI( pBB1 );
                      pPos2 = hb_itemGetNI( pBB2 );
                      hb_itemRelease(pBB1);
                      hb_itemRelease(pBB2);
                      hb_itemRelease(pBB);
                      if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA = hb_itemArrayGet( pA, pPos1 );
                      PHB_ITEM pAA2 = hb_itemArrayGet( pAA, pPos2 );
                      hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAA2 ) );
                      hb_itemRelease(pAA2);
                      hb_itemRelease(pAA);
                   }
                   break;
             }
             break;
          }
          case 3 :  // 3D
          {
             unsigned int n=1;
             HB_MAXINT pPos1, pPos2, pPos3;

             switch( pTyp ){
                case 1 : // string
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                      PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                      PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                      pPos1 = hb_itemGetNI( pBB1 );
                      pPos2 = hb_itemGetNI( pBB2 );
                      pPos3 = hb_itemGetNI( pBB3 );
                      hb_itemRelease(pBB3);
                      hb_itemRelease(pBB2);
                      hb_itemRelease(pBB1);
                      hb_itemRelease(pBB);
                      if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                           pPos3 <= 0 || pPos3 > aPag ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                      PHB_ITEM pAAA3 = hb_itemArrayGet( pAAA, pPos3 );
                      hb_arraySetC( pCWM, n, (const char *) hb_itemGetCPtr( pAAA3 ) );
                      hb_itemRelease(pAAA3);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                   }
                   break;
                }
                case 2 : // numero
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, 1);
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                        pPos3 <= 0 || pPos3 > aPag ){
                      mtOk = 0;
                      break;
                   }
                /*   PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                   PHB_ITEM pAAA2 = hb_itemArrayGet( pAAA, 1 );
                   if ( HB_IS_NUMINT ( pAAA2 ) ){
                      hb_itemRelease(pAAA2);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         pPos3 = hb_itemGetNI( pBB3 );
                         hb_itemRelease(pBB3);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                              pPos3 <= 0 || pPos3 > aPag ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                         PHB_ITEM pAAA3 = hb_itemArrayGet( pAAA, pPos3 );
                         hb_arraySetND( pCWM, n, (HB_MAXINT) hb_itemGetNInt( pAAA3 ) );
                         hb_itemRelease(pAAA3);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pAA);
                      }
                   }else if ( HB_IS_NUMERIC ( pAAA2 ) ){
                      hb_itemRelease(pAAA2);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                      */
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         pPos3 = hb_itemGetNI( pBB3 );
                         hb_itemRelease(pBB3);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                              pPos3 <= 0 || pPos3 > aPag ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                         PHB_ITEM pAAA3 = hb_itemArrayGet( pAAA, pPos3 );
                         hb_arraySetND( pCWM, n, (double) hb_itemGetND( pAAA3 ) );
                         hb_itemRelease(pAAA3);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pAA);
                      }
                /*   }else{
                      hb_itemRelease(pAAA2);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         pPos3 = hb_itemGetNI( pBB3 );
                         hb_itemRelease(pBB3);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                              pPos3 <= 0 || pPos3 > aPag ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                         PHB_ITEM pAAA3 = hb_itemArrayGet( pAAA, pPos3 );
                         hb_arraySetND( pCWM, n, (long) hb_itemGetNL( pAAA3 ) );
                         hb_itemRelease(pAAA3);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pAA);
                      }
                   }  */ 
                   break;
                }
                case 3 : // logica
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                      PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                      PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                      pPos1 = hb_itemGetNI( pBB1 );
                      pPos2 = hb_itemGetNI( pBB2 );
                      pPos3 = hb_itemGetNI( pBB3 );
                      hb_itemRelease(pBB3);
                      hb_itemRelease(pBB2);
                      hb_itemRelease(pBB1);
                      hb_itemRelease(pBB);
                      if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                           pPos3 <= 0 || pPos3 > aPag ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                      PHB_ITEM pAAA3 = hb_itemArrayGet( pAAA, pPos3 );
                      hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAAA3 ) );
                      hb_itemRelease(pAAA3);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                   }
                   break;
                }
             }
             break;
          }
          case 4 :  // 4D
          {
             unsigned int n=1;
             HB_MAXINT pPos1, pPos2, pPos3, pPos4;

             switch( pTyp ){
                case 1 : // string
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                      PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                      PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                      PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                      pPos1 = hb_itemGetNI( pBB1 );
                      pPos2 = hb_itemGetNI( pBB2 );
                      pPos3 = hb_itemGetNI( pBB3 );
                      pPos4 = hb_itemGetNI( pBB4 );
                      hb_itemRelease(pBB4);
                      hb_itemRelease(pBB3);
                      hb_itemRelease(pBB2);
                      hb_itemRelease(pBB1);
                      hb_itemRelease(pBB);
                      if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, pPos3 );
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, pPos4 );
                      hb_arraySetC( pCWM, n, (const char *) hb_itemGetCPtr( pAAAAA ) );
                      hb_itemRelease(pAAAAA);
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                   }
                   break;
                }
                case 2 : // numero
                {
                   PHB_ITEM pBB = hb_itemArrayGet( pB, 1);
                   PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                   PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                   PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                   PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                   pPos1 = hb_itemGetNI( pBB1 );
                   pPos2 = hb_itemGetNI( pBB2 );
                   pPos3 = hb_itemGetNI( pBB3 );
                   pPos4 = hb_itemGetNI( pBB4 );
                   hb_itemRelease(pBB4);
                   hb_itemRelease(pBB3);
                   hb_itemRelease(pBB2);
                   hb_itemRelease(pBB1);
                   hb_itemRelease(pBB);
                   if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                        pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                      mtOk = 0;
                      break;
                   }
                 /*  PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, pPos3 );
                   PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, 1 );
                   if ( HB_IS_NUMINT ( pAAAAA ) ){
                      hb_itemRelease(pAAAAA);
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                         PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         pPos3 = hb_itemGetNI( pBB3 );
                         pPos4 = hb_itemGetNI( pBB4 );
                         hb_itemRelease(pBB4);
                         hb_itemRelease(pBB3);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                              pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, pPos3 );
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, pPos4 );
                         hb_arraySetND( pCWM, n, (HB_MAXINT) hb_itemGetNInt( pAAAAA ) );
                         hb_itemRelease(pAAAAA);
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pAA);
                      }
                   }else if ( HB_IS_NUMERIC ( pAAAAA ) ){
                      hb_itemRelease(pAAAAA);
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                      */
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                         PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         pPos3 = hb_itemGetNI( pBB3 );
                         pPos4 = hb_itemGetNI( pBB4 );
                         hb_itemRelease(pBB4);
                         hb_itemRelease(pBB3);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                              pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, pPos3 );
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, pPos4 );
                         hb_arraySetND( pCWM, n, (double) hb_itemGetND( pAAAAA ) );
                         hb_itemRelease(pAAAAA);
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pAA);
                      }
                  /* }else{
                      hb_itemRelease(pAAAAA);
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                         PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                         PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                         PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                         PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                         pPos1 = hb_itemGetNI( pBB1 );
                         pPos2 = hb_itemGetNI( pBB2 );
                         pPos3 = hb_itemGetNI( pBB3 );
                         pPos4 = hb_itemGetNI( pBB4 );
                         hb_itemRelease(pBB4);
                         hb_itemRelease(pBB3);
                         hb_itemRelease(pBB2);
                         hb_itemRelease(pBB1);
                         hb_itemRelease(pBB);
                         if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                              pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                            mtOk = 0;
                            break;
                         }
                         PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, pPos3 );
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, pPos4 );
                         hb_arraySetND( pCWM, n, (long) hb_itemGetNL( pAAAAA ) );
                         hb_itemRelease(pAAAAA);
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pAA);
                      }
                   }*/
                   break;
                }
                case 3 : // logica
                {
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pBB1 = hb_itemArrayGet( pBB, 1);
                      PHB_ITEM pBB2 = hb_itemArrayGet( pBB, 2);
                      PHB_ITEM pBB3 = hb_itemArrayGet( pBB, 3);
                      PHB_ITEM pBB4 = hb_itemArrayGet( pBB, 4);
                      pPos1 = hb_itemGetNI( pBB1 );
                      pPos2 = hb_itemGetNI( pBB2 );
                      pPos3 = hb_itemGetNI( pBB3 );
                      pPos4 = hb_itemGetNI( pBB4 );
                      hb_itemRelease(pBB4);
                      hb_itemRelease(pBB3);
                      hb_itemRelease(pBB2);
                      hb_itemRelease(pBB1);
                      hb_itemRelease(pBB);
                      if ( pPos1 <=0 || pPos1 > aRow || pPos2 <= 0 || pPos2 > aCol ||
                           pPos3 <= 0 || pPos3 > aPag || pPos4 <= 0 || pPos4 > aBlk ){
                         mtOk = 0;
                         break;
                      }
                      PHB_ITEM pAA  = hb_itemArrayGet( pA, pPos1 );
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, pPos2 );
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, pPos3 );
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, pPos4 );
                      hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAAAAA ) );
                      hb_itemRelease(pAAAAA);
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pAA);
                   }
                   break;
                }
             }
             break;
          }
          break;
       }
    }
    if ( !mtOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

/****** SUBSTR, STRCUT y FUNCIONES AUXILIARES *******/

//char * FUNSTRCUT(const char * linea, unsigned short DESDE, 
//                 unsigned short HASTA, unsigned short LEN){
char * FUNSTRCUT(const char * linea, int DESDE, 
                 int HASTA, int LEN){
  const char *t;
  uint16_t i,l;
  
  if (HASTA>LEN) HASTA=LEN;
  if (LEN-DESDE<HASTA) HASTA = 0;
 
  char * buffer = ( char * ) calloc( (LEN - (HASTA-DESDE) + 1), 1); // sizeof(char) );
  
  if ( buffer == NULL )
     return NULL;
  char * buf = buffer;   
  t = linea;
  for (i=0; i<DESDE; i++) {
     //if (*t<0) {t++;--DESDE;}
     t++;
  }
  l = (t - linea)-1;
 // strncpy(buf,linea,l);
  strncat(buf,linea,l);
//  buf[l]='\0';
  t--;
  // busco resto de linea no borrable:
  if (HASTA>0) {
     for (i=0;i<HASTA ;i++) {
        //if (*t<0) {t++;--HASTA;}
        t++;
     }
     strcat(buf,t);
  }
  buf[LEN - (HASTA-DESDE)]='\0';
  return buffer;
}

char * FUNREPLICATE(const char * szText, int nLen, int nTimes){

   char * szResult = (char *) calloc((( nLen * nTimes ) + 1),1);//sizeof(char *));
  // char * szResult = (char *) malloc((( nLen * nTimes ) + 1));
  if ( szResult == NULL )
     return NULL;
     
   char * szPtr = szResult;
   HB_ISIZ n;

   for( n = 0; n < nTimes; ++n )
   {
      int j=nLen;
      while(j--) szPtr[j] = szText[j];
      //strncat( szPtr, szText, nLen );
      szPtr += nLen;
   }
   return ( szResult );
}

char * FUNXSUBSTR(const char *linea, int inicio, int cuenta){
   int l = strlen(linea);
   // ajusto inicio: resto uno
   --inicio;
   if (l<inicio) return NULL;   // OJO con esto: el que reciba, debe poner ""

   char *buffer;
   buffer = (char *)calloc(cuenta+1,1);//sizeof(char *));
   //buffer = (char *)malloc(cuenta+1);
   if (buffer == NULL) return NULL;
   char *buf = buffer;
   // evaluar si hay caracteres especiales antes del inicio
 //  int i;
 //  const char *t;
 //  t = linea;
  /*********************************
   esta porcion está comentada mas no borrada
   porque Harbour ya hace el análisis de los
   caracteres especiales con acentos.
   *************************/
/*   i = 0;
   do{
       if (*t<0) {inicio++;t++;}
       t++;
   }while(++i<inicio);  */
   
   // evaluar si los hay entre el substring
 //  t = linea+inicio;
/*   i = 0;
   do{
       if (*t<0) {cuenta++;t++;if(*t=='\0') break;}
       t++;
       if(!*t) break;
   }while(++i<cuenta); */
   strncpy(buf, linea+inicio, cuenta);
   buf[cuenta] = '\0';

   return buffer;
}

HB_FUNC( XMEADDSTR )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = STRING
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = POSICIONES/REPLICA
    unsigned int pDim = hb_parni( 3 );   // dimension de matrices
    unsigned int pRow = hb_parni( 4 );   // rows
    unsigned int pCol = hb_parni( 5 );   // cols
    unsigned int pPag = hb_parni( 6 );   // pags
    unsigned int pBlk = hb_parni( 7 );   // blks
    HB_ISIZ    codfun = hb_parns( 8 );   // codigo de funcion. reserva 0 para strcpy
    
    int strOk = 1;
    
    HB_MAXINT nPos = hb_itemGetNI( pB );

    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1 :
       {
          unsigned int n=1;
          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                        nPos + 1, hb_itemGetCLen( pAA ));
                   hb_itemRelease( pAA );
                   const char * Buff = Str;
                   if (Buff!=NULL)
                      hb_arraySetC( pCWM, n, Buff );
                   else{
                      strOk = 0;
                      break;
                   }
                   free(Str);
                }
                break;
              }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                        1, hb_itemGetCLen( pAA ) - nPos);
                   hb_itemRelease( pAA );
                   const char * Buff = Str;
                   if (Buff!=NULL)
                      hb_arraySetC( pCWM, n, Buff );
                   else{
                      strOk = 0;
                      break;
                   }
                   free(Str);
                }
                break;
              }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   char * Str = FUNREPLICATE( hb_itemGetCPtr( pAA ), 
                                           hb_itemGetCLen( pAA ), nPos);
                   hb_itemRelease( pAA );
                   const char * Buff = Str;
                   if (Buff!=NULL)
                      hb_arraySetC( pCWM, n, Buff );
                   else{
                         strOk = 0;
                         break;
                   }
                   free(Str);
                }
                break;
              }
          }
          break;
       }
       case 2 :
       {
          unsigned int n=1,m=1;

          switch( codfun ){

             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);

                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                                nPos + 1, hb_itemGetCLen( pAAA ) );
                      hb_itemRelease( pAAA );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCC, m, Buff );
                      else{
                         strOk = 0;
                         hb_itemRelease( pAA );
                         hb_itemRelease( pCC );
                         break;
                      }
                      free(Str);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 1, 
                                hb_itemGetCLen( pAAA ) - nPos);
                      hb_itemRelease( pAAA );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCC, m, Buff );
                      else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCC );
                            break;
                      }
                      free(Str);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      char * Str = FUNREPLICATE( hb_itemGetCPtr( pAAA ), 
                                hb_itemGetCLen( pAAA ), nPos);
                      hb_itemRelease( pAAA );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCC, m, Buff );
                      else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCC );
                            break;
                      }
                      free(Str);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       }
       case 3 :
       {
          unsigned int n=1,m=1,o=1;

          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                                nPos + 1, hb_itemGetCLen( pAAAA ) );
                         hb_itemRelease( pAAAA );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCCC, o, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCCC );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                                1, hb_itemGetCLen( pAAAA ) - nPos);
                         hb_itemRelease( pAAAA );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCCC, o, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCCC );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         char * Str = FUNREPLICATE( hb_itemGetCPtr( pAAAA ), 
                                hb_itemGetCLen( pAAAA ), nPos);
                         hb_itemRelease( pAAAA );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCCC, o, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCCC );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       }   
       case 4 :
       {
          unsigned int n=1,m=1,o=1,p=1;

          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                               nPos + 1, hb_itemGetCLen( pAAAAA ));
                            hb_itemRelease( pAAAAA );
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCCC, p, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAAA );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pCCCC );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                 1, hb_itemGetCLen( pAAAAA ) - nPos);
                            hb_itemRelease( pAAAAA );
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCCC, p, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAAA );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pCCCC );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            char * Str = FUNREPLICATE( hb_itemGetCPtr( pAAAAA ), 
                                 hb_itemGetCLen( pAAAAA ), nPos);
                            hb_itemRelease( pAAAAA );
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCCC, p, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAAA );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pCCCC );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break; 
       }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( XSUBSTR )  // substr GENERAL: el normal, pos y porcion
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ANY ); // A = STRING
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = POSICIONES/REPLICA
    PHB_ITEM pD = hb_param( 3, HB_IT_ANY ); // D = porcion
    unsigned int pDim = hb_parni( 4 );   // dimension de matrices
    unsigned int pRow = hb_parni( 5 );   // rows
    unsigned int pCol = hb_parni( 6 );   // cols
    unsigned int pPag = hb_parni( 7 );   // pags
    unsigned int pBlk = hb_parni( 8 );   // blks
    int codfun        = hb_parni( 9 );   // codigo de funcion. reserva 0 para strcpy
    
    int strOk = 1;
    int swCut = 0;

    int nPos, nPorcion;
              
    if ( codfun > 10 ) { // es STRCUT
       codfun -= 10;
       swCut = 1;
    }
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1 :
       {
          nPos     = ( codfun == 1 || codfun == 4) ? hb_itemGetNI( pB ) : 0; 
          nPorcion = ( codfun == 1 || codfun == 2) ? hb_itemGetNI( pD ) : 0;
          switch( codfun ){
             case 1 :{
                if ( swCut ){  // corta
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAA ), 
                           nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAA ) );
                      hb_itemRelease( pAA );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }else{     // copia
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                                  nPos<=0? 1 : nPos, nPorcion );
                      hb_itemRelease( pAA );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }
                break;
             }case 2:{
                if ( swCut ){  // corta
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      nPos = hb_itemGetNI( pBB );
                      char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAA ), 
                           nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAA ) );
                      
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }else{     // copia
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      nPos = hb_itemGetNI( pBB );
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                                  nPos<=0? 1 : nPos, nPorcion );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }
                break;
             }case 3:{
                if ( swCut ){  // corta
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      nPos = hb_itemGetNI( pBB );
                      nPorcion = hb_itemGetNI( pDD );
                      char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAA ), 
                           nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAA ) );
                      
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      hb_itemRelease( pDD );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }else{     // copia
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      nPos = hb_itemGetNI( pBB );
                      nPorcion = hb_itemGetNI( pDD );
                      
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                            nPos<=0? 1 : nPos, nPorcion );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      hb_itemRelease( pDD );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }   
                }
                break;
             }case 4:{
                if ( swCut ){  // corta
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      nPorcion = hb_itemGetNI( pDD );
                      char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAA ), 
                           nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAA ) );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pDD );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }else{     // copia
                   unsigned int n;
                   pCWM = hb_itemArrayNew( pRow ); // CWM
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      nPorcion = hb_itemGetNI( pDD );
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                            nPos<=0? 1 : nPos, nPorcion );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pDD );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCWM, n, Buff );
                      else{
                         strOk = 0;
                         break;
                      }
                      free(Str);
                   }
                }
             }  
          }
          break;
       }
       case 2:
       {
          nPos     = ( codfun == 1 || codfun == 4) ? hb_itemGetNI( pB ) : 0; 
          nPorcion = ( codfun == 1 || codfun == 2) ? hb_itemGetNI( pD ) : 0;
          
          switch( codfun ){
             case 1 :{
                unsigned int n=1,m=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAA ) );
                         hb_itemRelease( pAAA );
                         const char * Buff = Str;
                         if (Buff!=NULL) hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion );
                         hb_itemRelease( pAAA );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 2:{
                unsigned int n=1,m=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         nPos = hb_itemGetNI( pBBB );
                         char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAA ) );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         const char * Buff = Str;
                         if (Buff!=NULL) hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         nPos = hb_itemGetNI( pBBB );
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         const char * Buff = Str;
                         if (Buff!=NULL) hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 3:{
                unsigned int n=1,m=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         nPos = hb_itemGetNI( pBBB );
                         nPorcion = hb_itemGetNI( pDDD );
                         char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAA ) );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pDDD );
                         const char * Buff = Str;
                         if (Buff!=NULL) hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            hb_itemRelease( pDD );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         nPos = hb_itemGetNI( pBBB );
                         nPorcion = hb_itemGetNI( pDDD );
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pDDD );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            hb_itemRelease( pDD );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 4:{
                unsigned int n=1,m=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         nPorcion = hb_itemGetNI( pDDD );
                         char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAA ) );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pDDD );
                         const char * Buff = Str;
                         if (Buff!=NULL) hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pDD );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         nPorcion = hb_itemGetNI( pDDD );
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                              nPos<=0? 1 : nPos, nPorcion );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pDDD );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCC, m, Buff );
                         else{
                            strOk = 0;
                            hb_itemRelease( pAA );
                            hb_itemRelease( pDD );
                            hb_itemRelease( pCC );
                            break;
                         }
                         free(Str);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }
             }  
          }
          break;
       }
       case 3:
       {
          nPos     = ( codfun == 1 || codfun == 4) ? hb_itemGetNI( pB ) : 0; 
          nPorcion = ( codfun == 1 || codfun == 2) ? hb_itemGetNI( pD ) : 0;
          
          switch( codfun ){
             case 1 :{
                unsigned int n=1,m=1,o=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);

                            char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAA ) );
                            hb_itemRelease( pAAAA );
                            const char * Buff = Str;
                            if (Buff!=NULL) hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion );
                            hb_itemRelease( pAAAA );
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 2:{
                unsigned int n=1,m=1,o=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            nPos = hb_itemGetNI( pBBBB );
                            char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAA ) );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            const char * Buff = Str;
                            if (Buff!=NULL) hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pBBB);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            nPos = hb_itemGetNI( pBBBB );
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion );
                            
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            const char * Buff = Str;
                            if (Buff!=NULL) hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pBBB);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 3:{
                unsigned int n=1,m=1,o=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            nPos = hb_itemGetNI( pBBBB );
                            nPorcion = hb_itemGetNI( pDDDD );
                            char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAA ) );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pDDDD );
                            const char * Buff = Str;
                            if (Buff!=NULL) hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pDDD );
                               hb_itemRelease( pCC );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               hb_itemRelease( pDD );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pDDD );
                         hb_itemRelease( pCCC );
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            nPos = hb_itemGetNI( pBBBB );
                            nPorcion = hb_itemGetNI( pDDDD );
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion );
                            
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pDDDD );
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pDDD );
                               hb_itemRelease( pCC );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               hb_itemRelease( pDD );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pDDD );
                         hb_itemRelease( pCCC );
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 4:{
                unsigned int n=1,m=1,o=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            
                            nPorcion = hb_itemGetNI( pDDDD );
                            char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAA ) );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pDDDD );
                            const char * Buff = Str;
                            if (Buff!=NULL) hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pDDD );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pDD );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pDDD);
                         hb_itemRelease(pCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            
                            nPorcion = hb_itemGetNI( pDDDD );
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                                 nPos<=0? 1 : nPos, nPorcion );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pDDDD );
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCC, o, Buff );
                            else{
                               strOk = 0;
                               hb_itemRelease( pCCC );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pDDD );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pDD );
                               hb_itemRelease( pCC );
                               break;
                            }
                            free(Str);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pDDD);
                         hb_itemRelease(pCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }
             }  
          }
          break;
       }
       case 4:
       {
          nPos     = ( codfun == 1 || codfun == 4) ? hb_itemGetNI( pB ) : 0; 
          nPorcion = ( codfun == 1 || codfun == 2) ? hb_itemGetNI( pD ) : 0;
          
          switch( codfun ){
             case 1 :{
                unsigned int n=1,m=1,o=1,p=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);

                               char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAAA ) );
                               hb_itemRelease( pAAAAA );
                               const char * Buff = Str;
                               if (Buff!=NULL)
                                  hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               
                               char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion );
                               hb_itemRelease( pAAAAA );
                               const char * Buff = Str;
                               if (Buff!=NULL)
                                  hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 2:{
                unsigned int n=1,m=1,o=1,p=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                               nPos = hb_itemGetNI( pBBBBB );
                               char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAAA ) );
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               const char * Buff = Str;
                               if (Buff!=NULL) hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pBBBB);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pBBB);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                               nPos = hb_itemGetNI( pBBBBB );
                               char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion );
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               const char * Buff = Str;
                               if (Buff!=NULL) hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pBBBB);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pBBB);
                         hb_itemRelease(pCCC);
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 3:{
                unsigned int n=1,m=1,o=1,p=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                               PHB_ITEM pDDDDD = hb_itemArrayGet( pDDDD, p);
                               nPos = hb_itemGetNI( pBBBBB );
                               nPorcion = hb_itemGetNI( pDDDDD );
                               char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAAA ) );
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pDDDDD );
                               const char * Buff = Str;
                               if (Buff!=NULL)
                                  hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pDDDD );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pDDD );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pDD );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pDDDD );
                            hb_itemRelease( pCCCC );
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pDDD );
                         hb_itemRelease( pCCC );
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                               PHB_ITEM pDDDDD = hb_itemArrayGet( pDDDD, p);
                               nPos = hb_itemGetNI( pBBBBB );
                               nPorcion = hb_itemGetNI( pDDDDD );
                               char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion );
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pDDDDD );
                               const char * Buff = Str;
                               if (Buff!=NULL)
                                  hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pDDDD );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pDDD );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pDD );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pDDDD );
                            hb_itemRelease( pCCCC );
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pDDD );
                         hb_itemRelease( pCCC );
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }
                break;
             }case 4:{
                unsigned int n=1,m=1,o=1,p=1;
                if ( swCut ){  // corta
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               PHB_ITEM pDDDDD = hb_itemArrayGet( pDDDD, p);
                               nPorcion = hb_itemGetNI( pDDDDD );
                               char * Str = FUNSTRCUT((const char *)hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion, hb_itemGetCLen( pAAAAA ) );
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pDDDDD );
                               const char * Buff = Str;
                               if (Buff!=NULL)
                                  hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pDDDD );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pDDD );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pDD );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pDDDD);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pDDD);
                         hb_itemRelease(pCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }else{     // copia
                   pCWM = hb_itemArrayNew( pRow ); // CWM 
                   for( n=1; n<=pRow; n++){
                      PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                      PHB_ITEM pDD = hb_itemArrayGet( pD, n);
                      PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                      for( m=1; m<=pCol; m++){
                         PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                         PHB_ITEM pDDD = hb_itemArrayGet( pDD, m);
                         PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                         for( o=1; o<=pPag; o++){
                            PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                            PHB_ITEM pDDDD = hb_itemArrayGet( pDDD, o);
                            PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                            for( p=1; p<=pBlk; p++){
                               PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                               PHB_ITEM pDDDDD = hb_itemArrayGet( pDDDD, p);
                            
                               nPorcion = hb_itemGetNI( pDDDDD );
                               char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                    nPos<=0? 1 : nPos, nPorcion );
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pDDDDD );
                               const char * Buff = Str;
                               if (Buff!=NULL)
                                  hb_arraySetC( pCCCC, p, Buff );
                               else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pDDDD );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pDDD );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pDD );
                                  hb_itemRelease( pCC );
                                  break;
                               }
                               free(Str);
                            }
                            if ( !strOk ) break;
                            hb_arraySet( pCCC, o, pCCCC );
                            hb_itemRelease(pAAAA);
                            hb_itemRelease(pDDDD);
                            hb_itemRelease(pCCCC);
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCC, m, pCCC );
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pDDD);
                         hb_itemRelease(pCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCWM, n, pCC );
                      hb_itemRelease(pAA);
                      hb_itemRelease(pDD);
                      hb_itemRelease(pCC);
                   }
                }
             }  
          }
          break;       
       } 
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( XRPSUBSTR )  // substr GENERAL y réplica: el normal, y +- numero
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ANY ); // A = STRING
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = POSICIONES/REPLICA
    unsigned int pDim = hb_parni( 3 );   // dimension de matrices
    unsigned int pRow = hb_parni( 4 );   // rows
    unsigned int pCol = hb_parni( 5 );   // cols
    unsigned int pPag = hb_parni( 6 );   // pags
    unsigned int pBlk = hb_parni( 7 );   // blks
    HB_ISIZ    codfun = hb_parns( 8 );   // codigo de funcion. reserva 0 para strcpy
    
    int strOk = 1;
    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1 :
       {
          unsigned int n=1;
          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                       hb_itemGetNI( pBB ) + 1, hb_itemGetCLen( pAA ));
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   const char * Buff = Str;
                   if (Buff!=NULL)
                      hb_arraySetC( pCWM, n, Buff );
                   else{
                      strOk = 0;
                      break;
                   }
                   free(Str);
                }
                break;
             }
             case 2 :{  // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAA ), 
                       1, hb_itemGetCLen( pAA ) - hb_itemGetNI( pBB ));
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   const char * Buff = Str;
                   if (Buff!=NULL)
                      hb_arraySetC( pCWM, n, Buff );
                   else{
                      strOk = 0;
                      break;
                   }
                   free(Str);
                   
                }
                break;
             }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   char * Str = FUNREPLICATE( hb_itemGetCPtr( pAA ), 
                        hb_itemGetCLen( pAA ), hb_itemGetNI( pBB ));
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   const char * Buff = Str;
                   if (Buff!=NULL)
                      hb_arraySetC( pCWM, n, Buff );
                   else{
                      strOk = 0;
                      break;
                   }
                   free(Str);
                }
                break;
             }
          }
          break;
       }
       case 2 :
       {
          unsigned int n=1,m=1;

          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                            hb_itemGetNI( pBBB ) + 1, 
                            hb_itemGetCLen( pAAA ));
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCC, m, Buff );
                      else{
                                  strOk = 0;
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                      free(Str);
                      
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAA ), 
                           1, hb_itemGetCLen( pAAA ) - hb_itemGetNI( pBBB ));
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCC, m, Buff );
                      else{
                                  strOk = 0;
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                      free(Str);
                      
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      char * Str = FUNREPLICATE( hb_itemGetCPtr( pAAA ), 
                          hb_itemGetCLen( pAAA ), 
                          hb_itemGetNI( pBBB ) );
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      const char * Buff = Str;
                      if (Buff!=NULL)
                         hb_arraySetC( pCC, m, Buff );
                      else{
                                  strOk = 0;
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                      free(Str);
                      
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
              }
          }
          break;
       }
       case 3 :
       {
          unsigned int n=1,m=1,o=1;

          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                              hb_itemGetNI( pBBBB ) + 1, 
                              hb_itemGetCLen( pAAAA ));
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCCC, o, Buff );
                         else{
                                  strOk = 0;
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                         free(Str);
                         
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pCCC );
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);   
                }
                break;
              }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAA ), 
                              1, hb_itemGetCLen( pAAAA ) - 
                              hb_itemGetNI( pBBBB ));
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCCC, o, Buff );
                         else{
                                  strOk = 0;
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                         free(Str);
                         
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pCCC );
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         char * Str = FUNREPLICATE( hb_itemGetCPtr( pAAAA ), 
                              hb_itemGetCLen( pAAAA ), 
                              hb_itemGetNI( pBBBB ) );
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         const char * Buff = Str;
                         if (Buff!=NULL)
                            hb_arraySetC( pCCC, o, Buff );
                         else{
                                  strOk = 0;
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                         free(Str);
                         
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pCCC );
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       }
       case 4 :
       {
          unsigned int n=1,m=1,o=1,p=1;

          switch( codfun ){
             case 1 : { // mueve puntero inicial
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                            
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                 hb_itemGetNI( pBBBBB ) + 1, 
                                 hb_itemGetCLen( pAAAAA ));
                            hb_itemRelease(pAAAAA);
                            hb_itemRelease(pBBBBB);
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCCC, p, Buff );
                            else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                            free(Str);
                            
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pBBBB);
                         hb_itemRelease(pCCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pBBB);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 2 : { // mueve desde atras
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                            char * Str = FUNXSUBSTR( hb_itemGetCPtr( pAAAAA ), 
                                 1, hb_itemGetCLen( pAAAAA ) 
                                 - hb_itemGetNI( pBBBBB ));
                            hb_itemRelease(pAAAAA);
                            hb_itemRelease(pBBBBB);
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCCC, p, Buff );
                            else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                            free(Str);
                            
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pBBBB);
                         hb_itemRelease(pCCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pBBB);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
              }
             case 3 : { // replicate
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                            char * Str = FUNREPLICATE( hb_itemGetCPtr( pAAAAA ), 
                                 hb_itemGetCLen( pAAAAA ), 
                                 hb_itemGetNI( pBBBBB ) );
                            hb_itemRelease(pAAAAA);
                            hb_itemRelease(pBBBBB);
                            const char * Buff = Str;
                            if (Buff!=NULL)
                               hb_arraySetC( pCCCC, p, Buff );
                            else{
                                  strOk = 0;
                                  hb_itemRelease( pAAAA );
                                  hb_itemRelease( pAAA );
                                  hb_itemRelease( pAA );
                                  hb_itemRelease( pBBBB );
                                  hb_itemRelease( pBBB );
                                  hb_itemRelease( pBB );
                                  hb_itemRelease( pCCCC );
                                  hb_itemRelease( pCCC );
                                  hb_itemRelease( pCC );
                                  break;
                            }
                            free(Str);
                            
                         }
                         if ( !strOk ) break;
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pBBBB);
                         hb_itemRelease(pCCCC);   
                      }
                      if ( !strOk ) break;
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pBBB);
                      hb_itemRelease(pCCC);
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break; 
       }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

//XMESTRLET(CWM,A,ELEM,DIM,ROW,COL,PAG,BLK)
HB_FUNC( XMESTRLET )  // concatena 2 strings
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B   A + B o B + A
    unsigned int pDim = hb_parni( 3 );   // dimension de matrices
    unsigned int pRow = hb_parni( 4 );   // rows
    unsigned int pCol = hb_parni( 5 );   // cols
    unsigned int pPag = hb_parni( 6 );   // pags
    unsigned int pBlk = hb_parni( 7 );   // blks
    int pOrden = hb_parni( 8 );   // 0 = M + E, 1 = E + M

    const char * pStr1;
    const char * pStr2;
    HB_SIZE nLen1, nLen2;
    int strOk = 1;
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1 :
       {
          pStr2 = hb_itemGetCPtr( pB );
          nLen2 = hb_itemGetCLen( pB );
          unsigned int n=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             pStr1 = hb_itemGetCPtr( pAA );
             nLen1 = hb_itemGetCLen( pAA );
             hb_itemRelease( pAA );
             char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
             if ( pTarget == NULL ){
                strOk = 0;
                free(pTarget);
                break;
             }
             char * Temp = pTarget;
             if ( pOrden == 0 ) {
                strncat(Temp, pStr1, nLen1);
                strncat(Temp, pStr2, nLen2);
             }else{
                strncat(Temp, pStr2, nLen2);
                strncat(Temp, pStr1, nLen1);
             }
             Temp[nLen1 + nLen2 + 1]='\0';

             hb_arraySetC( pCWM, n, (char *) Temp );
             free(pTarget);
             
          }
          break;
       }
       case 2 :
       {
          unsigned int n=1,m=1;

          pStr2 = hb_itemGetCPtr( pB );
          nLen2 = hb_itemGetCLen( pB );
          
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                pStr1 = hb_itemGetCPtr( pAAA );
                nLen1 = hb_itemGetCLen( pAAA );
                hb_itemRelease( pAAA );
                char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *)); 
                if ( pTarget == NULL ){
                   strOk = 0;
                   free(pTarget);
                   break;
                }
             
                char * Temp = pTarget;
                if ( pOrden == 0 ) {
                   strncat(Temp, pStr1, nLen1);
                   strncat(Temp, pStr2, nLen2);
                }else{
                   strncat(Temp, pStr2, nLen2);
                   strncat(Temp, pStr1, nLen1);
                }
                Temp[nLen1 + nLen2 + 1]='\0';
           
                hb_arraySetC( pCC, m, (char *) Temp );
                free(pTarget);
                
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
             if ( !strOk ) break;
          }
          break;
       }
       case 3 :
       {
          unsigned int n=1,m=1,o=1;

          pStr2 = hb_itemGetCPtr( pB );
          nLen2 = hb_itemGetCLen( pB );
          
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   pStr1 = hb_itemGetCPtr( pAAAA );
                   nLen1 = hb_itemGetCLen( pAAAA );
                   hb_itemRelease(pAAAA); 
                   char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
                   if ( pTarget == NULL ){
                      strOk = 0;
                      free(pTarget);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pCC);
                      break;
                   }
             
                   char * Temp = pTarget;
                   if ( pOrden == 0 ) {
                      strncat(Temp, pStr1, nLen1);
                      strncat(Temp, pStr2, nLen2);
                   }else{
                      strncat(Temp, pStr2, nLen2);
                      strncat(Temp, pStr1, nLen1);
                   }
                   Temp[nLen1 + nLen2 + 1]='\0';
                   hb_arraySetC( pCCC, o, (char *) Temp );
                   free(pTarget);
                     
                }
                if ( !strOk ) break;
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             if ( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
             ///GEN_PAPC_COORD_3D
          }
          break;
       }
       case 4 :
       {
          unsigned int n=1,m=1,o=1,p=1;

          pStr2 = hb_itemGetCPtr( pB );
          nLen2 = hb_itemGetCLen( pB );
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      pStr1 = hb_itemGetCPtr( pAAAAA );
                      nLen1 = hb_itemGetCLen( pAAAAA );
                      hb_itemRelease(pAAAAA);

                      char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
                      if ( pTarget == NULL ){
                         strOk = 0;
                         free(pTarget);
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC); 
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pCCC); 
                         hb_itemRelease(pAA);
                         hb_itemRelease(pCC); 
                         break;
                      }

                      char * Temp = pTarget;
                      if ( pOrden == 0 ) {
                         strncat(Temp, pStr1, nLen1);
                         strncat(Temp, pStr2, nLen2);
                      }else{
                         strncat(Temp, pStr2, nLen2);
                         strncat(Temp, pStr1, nLen1);
                      }
                      Temp[nLen1 + nLen2 + 1]='\0';
                      hb_arraySetC( pCCCC, p, (char *) Temp );
                      free(pTarget);
                      
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pCCCC);   
                }
                if ( !strOk ) break;
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pCCC);
             }
             if ( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pCC);
             ///GEN_PAPC_COORD_4D
          }
          break;
       }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

//XMMSTRLET(CWM,A,B,DIM,ROW,COL,PAG,BLK,CODFUN)
// devuelve matriz vacia si hay error
HB_FUNC( XMMSTRLET )  // concatena 2 strings
{

    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B   A + B
    unsigned int pDim = hb_parni( 3 );   // dimension de matrices
    unsigned int pRow = hb_parni( 4 );   // rows
    unsigned int pCol = hb_parni( 5 );   // cols
    unsigned int pPag = hb_parni( 6 );   // pags
    unsigned int pBlk = hb_parni( 7 );   // blks
    
    int strOk = 1;
    
    const char * pStr1;
    const char * pStr2;
    HB_SIZE nLen1, nLen2;
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1 :
       {
          unsigned int n=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             pStr1 = hb_itemGetCPtr( pAA );
             pStr2 = hb_itemGetCPtr( pBB );
             nLen1 = hb_itemGetCLen( pAA );
             nLen2 = hb_itemGetCLen( pBB );
             hb_itemRelease( pAA );
             hb_itemRelease( pBB );
             char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
             if ( pTarget == NULL ){
                strOk = 0;
                free(pTarget);
                break;
             }
             char * Temp = pTarget;
             strncat(Temp, pStr1, nLen1);
             strncat(Temp, pStr2, nLen2 );

             Temp[nLen1 + nLen2 + 1]='\0';
             hb_arraySetC( pCWM, n, (const char *) Temp );
             free(pTarget);
             
          }
          break;
       }
       case 2 :
       {
          unsigned int n=1,m=1;
          
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);

                pStr1 = hb_itemGetCPtr( pAAA );
                pStr2 = hb_itemGetCPtr( pBBB );
                nLen1 = hb_itemGetCLen( pAAA );
                nLen2 = hb_itemGetCLen( pBBB );
                hb_itemRelease(pAAA);
                hb_itemRelease(pBBB);
                char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
                if ( pTarget == NULL ){
                   strOk = 0;
                   free(pTarget);
                   hb_itemRelease(pAA);
                   hb_itemRelease(pBB);
                   hb_itemRelease(pCC);
                   break;
                }
             
                char * Temp = pTarget;
             
                strncat(Temp, pStr1, nLen1);
                strncat(Temp, pStr2, nLen2 );

                Temp[nLen1 + nLen2 + 1]='\0';
                hb_arraySetC( pCC, m, (const char *) Temp );
                free(pTarget);
             }
             if ( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pBB);
             hb_itemRelease(pCC);
             
             //GEN_PABC_COORD_2D
          }
          break;
       }
       case 3 :
       {
          unsigned int n=1,m=1,o=1;
          
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);

                   pStr1 = hb_itemGetCPtr( pAAAA );
                   pStr2 = hb_itemGetCPtr( pBBBB );
                   nLen1 = hb_itemGetCLen( pAAAA );
                   nLen2 = hb_itemGetCLen( pBBBB );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pBBBB);
                   char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
                   if ( pTarget == NULL ){
                      strOk = 0;
                      free(pTarget);
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pBBB);
                      hb_itemRelease(pCCC);
                      hb_itemRelease(pAA);
                      hb_itemRelease(pBB);
                      hb_itemRelease(pCC);
                      break;
                   }

                   char * Temp = pTarget;
                   strncat(Temp, pStr1, nLen1);
                   strncat(Temp, pStr2, nLen2 );

                   Temp[nLen1 + nLen2 + 1]='\0';
                   hb_arraySetC( pCCC, o, (const char *) Temp );
                   free(pTarget);
                }
                if ( !strOk ) break;
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pBBB);
                hb_itemRelease(pCCC);
             }
             if ( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pBB);
             hb_itemRelease(pCC);
          }
          break;
       }
       case 4 :
       {
          unsigned int n=1,m=1,o=1,p=1;
          pCWM = hb_itemArrayNew( pRow ); // CWM 
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                            
                      pStr1 = hb_itemGetCPtr( pAAAAA );
                      pStr2 = hb_itemGetCPtr( pBBBBB );
                      nLen1 = hb_itemGetCLen( pAAAAA );
                      nLen2 = hb_itemGetCLen( pBBBBB );
                      hb_itemRelease(pAAAAA);
                      hb_itemRelease(pBBBBB);

                      char * pTarget = ( char * ) calloc(( nLen1 + nLen2 + 1 ),sizeof(char *));
                      if ( pTarget == NULL ){
                         strOk = 0;
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pBBBB);
                         hb_itemRelease(pCCCC);
                         hb_itemRelease(pAAA);
                         hb_itemRelease(pBBB);
                         hb_itemRelease(pCCC);
                         hb_itemRelease(pAA);
                         hb_itemRelease(pBB);
                         hb_itemRelease(pCC);
                         free(pTarget);
                         break;
                      }
                      char * Temp = pTarget;
                      strncat(Temp, pStr1, nLen1);
                      strncat(Temp, pStr2, nLen2 );

                      Temp[nLen1 + nLen2 + 1]='\0';
                      hb_arraySetC( pCCCC, p, (const char *) Temp );
                      free(pTarget);
                      
                   }
                   if ( !strOk ) break;
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease(pAAAA);
                   hb_itemRelease(pBBBB);
                   hb_itemRelease(pCCCC);
                }
                if ( !strOk ) break;
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease(pAAA);
                hb_itemRelease(pBBB);
                hb_itemRelease(pCCC);
             }
             if ( !strOk ) break;
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease(pAA);
             hb_itemRelease(pBB);
             hb_itemRelease(pCC);   
             ///GEN_PABC_COORD_4D
          }
          break; 
       }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

// XLETVTOM(AX,CWM,DIM,ROW,COL,PAG,BLK,{0,1})
HB_FUNC( XLETVTOM )  // mvectorz a vmatrizector: usado por unique
{
  ////  PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // CWM
    PHB_ITEM pCWM = hb_param( 1, HB_IT_ARRAY ); // A
    
    unsigned int pDim = hb_parni( 2 );   // dimension de matrices
    unsigned int pRow = hb_parni( 3 );   // rows
    unsigned int pCol = hb_parni( 4 );   // cols
    unsigned int pPag = hb_parni( 5 );   // pags
    unsigned int pBlk = hb_parni( 6 );   // blks
    unsigned int pCod = hb_parni( 7 );   // 0=leo por filas; 1=leo por columnas
    
    PHB_ITEM pA = NULL;   // este es el resultado.
    
    switch( pDim )
    {
    case 1 :
    {
       unsigned int n=1;
       PHB_ITEM pSource = hb_itemArrayGet( pCWM, 1);
       
       if( HB_IS_STRING( pSource ) ){
          pA = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pC = hb_itemArrayGet( pCWM, n);
             hb_arraySetC( pA, n, (const char *)hb_itemGetCPtr( pC ) );
             hb_itemRelease( pC );
          }
       }else if( HB_IS_LOGICAL( pSource ) ){
          pA = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pC = hb_itemArrayGet( pCWM, n);
             hb_arraySetL( pA, n, (HB_BOOL) hb_itemGetL( pC ) ) ;
             hb_itemRelease( pC );
          }
       }else if ( HB_IS_NUMINT ( pSource ) ){
          pA = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pC = hb_itemArrayGet( pCWM, n);
             hb_arraySetNInt( pA, n, (HB_MAXINT) hb_itemGetNInt( pC ) );
             hb_itemRelease( pC );
          }
       }else if( HB_IS_NUMERIC( pSource ) ) {
          pA = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pC = hb_itemArrayGet( pCWM, n);
             hb_arraySetND( pA, n, (double) hb_itemGetND( pC ) );
             hb_itemRelease( pC );
          }
       }else if( HB_IS_LONG( pSource )  ){
          pA = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pC = hb_itemArrayGet( pCWM, n);
             hb_arraySetNL( pA, n, (long) hb_itemGetNL( pC ) );
             hb_itemRelease( pC );
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 2 :
    {
       PHB_ITEM pSource=NULL;

       unsigned int n=1,m=1;
       long ndx = pRow*pCol, i;
       
       // creo la matriz
       pA = hb_itemArrayNew( 0 ); // CWM
       for (i=1; i<=pRow; i++){
          PHB_ITEM pAA = hb_itemArrayNew( pCol ); // CWM
          hb_arrayAdd( pA, pAA );
          hb_itemRelease( pAA );
       }

       if ( pCod == 0){  // lee por fila
          
          pSource = hb_itemArrayGet( pCWM, 1 );
          
          if( HB_IS_STRING( pSource ) ){
             i=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pC = hb_itemArrayGet( pCWM, i++ );
                   hb_arraySetC( pAA, m, (const char *) hb_itemGetCPtr( pC ) );
                   hb_itemRelease( pC );
                }
                hb_itemRelease( pAA );
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             i=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pC = hb_itemArrayGet( pCWM, i++ );
                   hb_arraySetNInt( pAA, m, (HB_MAXINT) hb_itemGetNInt( pC ) );
                   hb_itemRelease( pC );
                }
                hb_itemRelease( pAA );
                //HB_INCRESHAPE_2D
             }
          }else if( HB_IS_NUMERIC( pSource ) ){
             i=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pC = hb_itemArrayGet( pCWM, i++ );
                   hb_arraySetND( pAA, m, (double) hb_itemGetND( pC ) );
                   hb_itemRelease( pC );
                }
                hb_itemRelease( pAA );
                //HB_INCRESHAPE_2D
             }
          }else if( HB_IS_LONG( pSource ) ){
             i=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pC = hb_itemArrayGet( pCWM, i++ );
                   hb_arraySetNL( pAA, m, (long) hb_itemGetNL( pC ) );
                   hb_itemRelease( pC );
                }
                hb_itemRelease( pAA );
                //HB_INCRESHAPE_2D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             i=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pC = hb_itemArrayGet( pCWM, i++ ); 
                   hb_arraySetL( pAA, m, (HB_BOOL) hb_itemGetL( pC ) );
                   hb_itemRelease( pC );
                }
                hb_itemRelease( pAA );
                //HB_INCRESHAPE_2D
             }
          }
       }else{   // lee por columna
          
          pSource = hb_itemArrayGet( pCWM, 1 );
          
          if( HB_IS_STRING( pSource ) ){
             for( i=1; i<=ndx; i++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                 hb_arraySetC( pAA, m, (const char *) hb_itemGetCPtr( pC ) );
                 if ( ++n > pRow ){
                    n=1;
                    ++m;
                 }
                 hb_itemRelease( pC );
                 hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             for( i=1; i<=ndx; i++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                 hb_arraySetNInt( pAA, m, (HB_MAXINT) hb_itemGetNInt( pC ) );
                 if ( ++n > pRow ){
                    n=1;
                    ++m;
                 }
                 hb_itemRelease( pC );
                 hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }else if( HB_IS_NUMERIC( pSource ) ){
             for( i=1; i<=ndx; i++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                 hb_arraySetND( pAA, m, (double) hb_itemGetND( pC ) );
                 if ( ++n > pRow ){
                    n=1;
                    ++m;
                 }
                 hb_itemRelease( pC );
                 hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }else if( HB_IS_LONG( pSource ) ){
             for( i=1; i<=ndx; i++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                 hb_arraySetNL( pAA, m, (long) hb_itemGetNL( pC ) );
                 if ( ++n > pRow ){
                    n=1;
                    ++m;
                 }
                 hb_itemRelease( pC );
                 hb_itemRelease( pAA );
                 ///HB2_INCRESHAPE_2D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             for( i=1; i<=ndx; i++){
                 PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                 PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                 hb_arraySetL( pAA, m, (HB_BOOL) hb_itemGetL( pC ) );
                 if ( ++n > pRow ){
                    n=1;
                    ++m;
                 }
                 hb_itemRelease( pC );
                 hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 3 :
    {
       PHB_ITEM pSource = NULL;
       long i,j,ndx;
       unsigned int n=1,m=1,o=1;
       ndx = pRow*pCol*pPag;
       
       // creo la matriz
       pA = hb_itemArrayNew( 0 ); // CWM
       for (i=1; i<=pRow; i++){
          PHB_ITEM pAA = hb_itemArrayNew( 0 ); // CWM
          for (j=1; j<=pCol; j++){
             PHB_ITEM pAAA = hb_itemArrayNew( pPag ); // CWM
             hb_arrayAdd( pAA, pAAA );
             hb_itemRelease( pAAA );
          }
          hb_arrayAdd( pA, pAA );
          hb_itemRelease( pAA );
       }
       
       if ( pCod == 0){  // lee por fila
          
          pSource = hb_itemArrayGet( pCWM, 1 );
          
          if( HB_IS_STRING( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetC( pAAA, o, (const char *) hb_itemGetCPtr( pC ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNInt( pAAA, o, (HB_MAXINT) hb_itemGetNInt( pC ));
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if( HB_IS_NUMERIC( pSource ) ){ 
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetND( pAAA, o, (double) hb_itemGetND( pC ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if( HB_IS_LONG( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNL( pAAA, o, (long) hb_itemGetNL( pC ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetL( pAAA, o, (HB_BOOL) hb_itemGetL( pC ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){
                      n=1;
                      ++o;
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }
       }else{  // por columna
          
          pSource = hb_itemArrayGet( pCWM, 1 );
          if( HB_IS_STRING( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetC( pAAA, o, (const char *) hb_itemGetCPtr( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNInt( pAAA, o, (HB_MAXINT) hb_itemGetNInt( pC ));
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetND( pAAA, o, (double) hb_itemGetND( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if( HB_IS_LONG( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNL( pAAA, o, (long) hb_itemGetNL( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetL( pAAA, o, (HB_BOOL) hb_itemGetL( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 4 :
    {
       PHB_ITEM pSource;
       long i,j,k,ndx;
       unsigned int n=1,m=1,o=1,p=1;
       ndx = pRow*pCol*pPag*pBlk;

// creo la matriz
       pA = hb_itemArrayNew( 0 ); // CWM
       for (i=1; i<=pRow; i++){
          PHB_ITEM pAA = hb_itemArrayNew( 0 ); // CWM
          for (j=1; j<=pCol; j++){
             PHB_ITEM pAAA = hb_itemArrayNew( 0 ); // CWM
             for (k=1; k<=pPag; k++){
                PHB_ITEM pAAAA = hb_itemArrayNew( pBlk ); // CWM
                hb_arrayAdd( pAAA, pAAAA );
                hb_itemRelease( pAAAA );
             }
             hb_arrayAdd( pAA, pAAA );
             hb_itemRelease( pAAA );
          }
          hb_arrayAdd( pA, pAA );
          hb_itemRelease( pAA );
       }

       if ( pCod == 0){  // lee por fila
          
          pSource = hb_itemArrayGet( pCWM, 1 );
          if( HB_IS_STRING( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetC( pAAAA, p, (const char *) hb_itemGetCPtr( pC ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){ 
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNInt( pAAAA, p, (HB_MAXINT) hb_itemGetNInt( pC ));
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){ 
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetND( pAAAA, p, (double) hb_itemGetND( pC ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){ 
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if( HB_IS_LONG( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNL( pAAAA, p, (long) hb_itemGetNL( pC ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){ 
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetL( pAAAA, p, (HB_BOOL) hb_itemGetL( pC ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){ 
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }
       }else{   // por clumnas
          
          pSource = hb_itemArrayGet( pCWM, 1 );
          if( HB_IS_STRING( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetC( pAAAA, p, (const char *) hb_itemGetCPtr( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNInt( pAAAA, p, (HB_MAXINT) hb_itemGetNInt( pC ));
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetND( pAAAA, p, (double) hb_itemGetND( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if( HB_IS_LONG( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetNL( pAAAA, p, (long) hb_itemGetNL( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pC = hb_itemArrayGet( pCWM, i );
                hb_arraySetL( pAAAA, p, (HB_BOOL) hb_itemGetL( pC ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pC );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }
       }
       break;
    }
    }
    hb_itemReturnRelease( pA );
}

// CWM:=XLETMTOV(AX,DIM,ROW,COL,PAG,BLK,{0,1})
HB_FUNC( XLETMTOV )  // matriz a vector: usado por unique
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A
    unsigned int pDim = hb_parni( 2 );   // dimension de matrices
    unsigned int pRow = hb_parni( 3 );   // rows
    unsigned int pCol = hb_parni( 4 );   // cols
    unsigned int pPag = hb_parni( 5 );   // pags
    unsigned int pBlk = hb_parni( 6 );   // blks
    unsigned int pCod = hb_parni( 7 );   // 0=leo por filas; 1=leo por columnas
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim )
    {
    case 1 :
    {
       unsigned int n=1;
       PHB_ITEM pSource = hb_itemArrayGet( pA, 1);
       
       if( HB_IS_STRING( pSource ) ){
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetC( pCWM, n, (const char *)hb_itemGetCPtr( pAA ) );
             hb_itemRelease( pAA );
          }
       }else if( HB_IS_LOGICAL( pSource ) ){
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( pAA ) ) ;
             hb_itemRelease( pAA );
          }
       }else if ( HB_IS_NUMINT ( pSource ) ){
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetNInt( pCWM, n, (HB_MAXINT) hb_itemGetNInt( pAA ) );
             hb_itemRelease( pAA );
          }
       }else if( HB_IS_NUMERIC( pSource ) ) {
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetND( pCWM, n, (double) hb_itemGetND( pAA ) );
             hb_itemRelease( pAA );
          }
       }else if( HB_IS_LONG( pSource )  ){
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             hb_arraySetNL( pCWM, n, (long) hb_itemGetNL( pAA ) );
             hb_itemRelease( pAA );
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 2 :
    {
       unsigned int n=1,m=1,i=1;
       PHB_ITEM pSource=NULL;

       if ( pCod == 0){  // lee por fila
          PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
          pSource = hb_itemArrayGet( pAA, 1 );
          hb_itemRelease( pAA );
          
          if( HB_IS_STRING( pSource ) ){
             pCWM = hb_itemArrayNew( pRow*pCol ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetC( pCWM, i++, (const char *) hb_itemGetCPtr( pAAA ) );
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             pCWM = hb_itemArrayNew( pRow*pCol ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetNInt( pCWM, i++, (HB_MAXINT) hb_itemGetNInt( pAAA ) );
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
          }else if( HB_IS_NUMERIC( pSource ) ){
             pCWM = hb_itemArrayNew( pRow*pCol ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetND( pCWM, i++, (double) hb_itemGetND( pAAA ) );
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
          }else if( HB_IS_LONG( pSource ) ){
             pCWM = hb_itemArrayNew( pRow*pCol ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetNL( pCWM, i++, (long) hb_itemGetNL( pAAA ) );
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             pCWM = hb_itemArrayNew( pRow*pCol ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetL( pCWM, i++, (HB_BOOL) hb_itemGetL( pAAA ) );
                   hb_itemRelease( pAAA );
                }
                hb_itemRelease( pAA );
             }
          }   
       }else{   // lee por columna
          PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
          pSource = hb_itemArrayGet( pAA, 1 );
          hb_itemRelease( pAA );
          
          unsigned int ndx = pRow*pCol;
          
          if( HB_IS_STRING( pSource ) ){
             
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                hb_arraySetC( pCWM, i, (const char *) hb_itemGetCPtr( pAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   ++m;
                }
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA ); 
                   ///HB2_INCRESHAPE_2D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                hb_arraySetNInt( pCWM, i, (HB_MAXINT) hb_itemGetNInt( pAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   ++m;
                }
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA ); 
                /// HB2_INCRESHAPE_2D
             }
          }else if( HB_IS_NUMERIC( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                hb_arraySetND( pCWM, i, (double) hb_itemGetND( pAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   ++m;
                }
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }else if( HB_IS_LONG( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                hb_arraySetNL( pCWM, i, (long) hb_itemGetNL( pAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   ++m;
                }
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                hb_arraySetL( pCWM, i, (HB_BOOL) hb_itemGetL( pAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   ++m;
                }
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );  
                 ///HB2_INCRESHAPE_2D
             }
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 3 :
    {

       unsigned int n=1,m=1,o=1;
       long ndx = pRow*pCol*pPag, i=0;
       PHB_ITEM pSource = NULL;

       if ( pCod == 0){  // lee por fila
          
          PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
          PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1 );
          pSource = hb_itemArrayGet( pAAA, 1 );
          hb_itemRelease( pAAA );
          hb_itemRelease( pAA );
          
          if( HB_IS_STRING( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // columna
                hb_arraySetC( pCWM, i, (const char *) hb_itemGetCPtr( pAAAA ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // columna
                hb_arraySetNInt( pCWM, i, (HB_MAXINT) hb_itemGetNInt( pAAAA ));
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // columna
                hb_arraySetND( pCWM, i, (double) hb_itemGetND( pAAAA ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if( HB_IS_LONG( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // columna
                hb_arraySetNL( pCWM, i, (long) hb_itemGetNL( pAAAA ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // columna
                hb_arraySetL( pCWM, i, (HB_BOOL) hb_itemGetL( pAAAA ) );
                if ( ++m > pCol ){ 
                   m=1; 
                   if ( ++n > pRow ){ 
                      n=1; 
                      ++o; 
                   } 
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_3D
             }
          }
       }else{  // por columna
          PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
          PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1 );
          pSource = hb_itemArrayGet( pAAA, 1 );
          hb_itemRelease( pAAA );
          hb_itemRelease( pAA );
          
          if( HB_IS_STRING( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                hb_arraySetC( pCWM, i, (const char *) hb_itemGetCPtr( pAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){ 
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                hb_arraySetNInt( pCWM, i, (HB_MAXINT) hb_itemGetNInt( pAAAA ));
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){ 
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                hb_arraySetND( pCWM, i, (double) hb_itemGetND( pAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){ 
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if( HB_IS_LONG( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                hb_arraySetNL( pCWM, i, (long) hb_itemGetNL( pAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){ 
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                hb_arraySetL( pCWM, i, (HB_BOOL) hb_itemGetL( pAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){ 
                      m=1;
                      ++o;
                   }
                }
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_3D
             }
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 4 :
    {
       unsigned int n=1,m=1,o=1,p=1;
       long ndx = pRow*pCol*pPag*pBlk, i=0;
       PHB_ITEM pSource=NULL;

       if ( pCod == 0){  // lee por fila
          
          PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
          PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1 );
          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, 1 );
          pSource = hb_itemArrayGet( pAAAA, 1 );
          hb_itemRelease( pAAAA );
          hb_itemRelease( pAAA );
          hb_itemRelease( pAA );
          
          if( HB_IS_STRING( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetC( pCWM, i, (const char *) hb_itemGetCPtr( pAAAAA ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetNInt( pCWM, i, (HB_MAXINT) hb_itemGetNInt( pAAAAA ));
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetND( pCWM, i, (double) hb_itemGetND( pAAAAA ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if( HB_IS_LONG( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetNL( pCWM, i, (long) hb_itemGetNL( pAAAAA ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetL( pCWM, i, (HB_BOOL) hb_itemGetL( pAAAAA ) );
                if ( ++m > pCol ){
                   m=1;
                   if ( ++n > pRow ){
                      n=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB_INCRESHAPE_4D
             }
          }
       }else{   // por clumnas
          
          PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
          PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1 );
          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, 1 );
          pSource = hb_itemArrayGet( pAAAA, 1 );
          hb_itemRelease( pAAAA );
          hb_itemRelease( pAAA );
          hb_itemRelease( pAA );
          
          if( HB_IS_STRING( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetC( pCWM, i, (const char *) hb_itemGetCPtr( pAAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if ( HB_IS_NUMINT ( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetNInt( pCWM, i, (HB_MAXINT) hb_itemGetNInt( pAAAAA ));
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if( HB_IS_NUMERIC( pSource ) ) {
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetND( pCWM, i, (double) hb_itemGetND( pAAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if( HB_IS_LONG( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetNL( pCWM, i, (long) hb_itemGetNL( pAAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }else if( HB_IS_LOGICAL( pSource ) ){
             pCWM = hb_itemArrayNew( ndx ); // CWM
             for( i=1; i<=ndx; i++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);  // fila
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m); // columna
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o); // pagina
                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p); // bloque
                hb_arraySetL( pCWM, i, (HB_BOOL) hb_itemGetL( pAAAAA ) );
                if ( ++n > pRow ){
                   n=1;
                   if ( ++m > pCol ){
                      m=1;
                      if ( ++o > pPag ){
                         o=1;
                         ++p;
                      }
                   }
                }
                hb_itemRelease( pAAAAA );
                hb_itemRelease( pAAAA );
                hb_itemRelease( pAAA );
                hb_itemRelease( pAA );
                ///HB2_INCRESHAPE_4D
             }
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    }
    hb_itemReturnRelease( pCWM );
}

uint16_t ftokens(const char *linea, const char *buscar, uint16_t lb) {
   const char *t,*r; // son solo punteros apuntando a la cadena s.

   uint16_t n=0;

   r = linea;  // rescato primera posición
   t = strstr(r,buscar);
   while (t!=NULL) {
      r = t + lb;
      ++n;
      t = strstr(r,buscar);
   }

   return n;
}

char * fun_alltrim( const char *linea, HB_SIZE sizel) {
   const char *r,*s;
   char *t,*buffer;
   HB_SIZE tsize;

   r = linea;
   if ( *r=='\t' || *r=='\r' || *r=='\n' || *r==' ' ){
      while (( *r=='\t' || *r=='\r' || *r=='\n' || *r==' ') && *r) r++; 
      if (!*r) return NULL;  // no hay texto, solo puras weás! 
   }
   s = linea + (sizel-1);
   if (*s=='\t' || *s=='\r' || *s=='\n' || *s==' ') {
      while (( *s=='\t' || *s=='\r' || *s=='\n' || *s==' ') && s!=linea) s--;     
      if (s==linea) return NULL;  // no hay texto, sólo puras weás!
   }
   tsize = s - r + 1;  // longitud del texto.

   buffer = (char *) calloc((tsize+1),1);//sizeof(char *));
   if (buffer==NULL) return NULL;
   t = buffer;
   strncpy (t,r,tsize);
   t[tsize]='\0';

   return buffer;
}

#define MAXBUFFER 4096

char *fsaturate( const char *tokens, const char *tok, const char *linea){
   char *buffer;
   const char *t, *s;
   char **ltoken;     // lista de tokens
   uint16_t lentok = strlen(tok);
   uint16_t i=0,l, sizei;

   if (lentok==0) return NULL;

   // cuántos tokens tengo?
   uint16_t ntok = ftokens(tokens,tok,lentok);
   if (ntok==0) return NULL;   // no hay tokens
   //ltoken = (char**)malloc( sizeof(char *)*(ntok+2) );
   ltoken = (char**)calloc( ntok+1, sizeof(char *) );
   // a ntok se suma 1, pues acá necesito los tokens, no los separadores, como en strtran. 

   if (ltoken==NULL) return NULL;   // no hay memoria

   // obtengo tokens y los guardo en un arreglo para reemplazar después.
   t = tokens;
   char *temp;
   while ((s = strstr(t,tok))!=NULL) {
       l = s - t;
       
       ltoken[i] = (char*)calloc( (l+1), 1);//sizeof(char *) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           //free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           return NULL;     // no hay memoria para el arreglo
       }
       //strncpy(ltoken[i], t, l);
       strncpy(temp, t, l);
       t = ++s;
    //   printf("\nTOken... %s\n",ltoken[i]);
       ++i;
   }

   if (t!=NULL) {           // queda un token más: lo capturo.
       ltoken[i] = (char*)calloc( (strlen(t)+1), 1);// sizeof(char *) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           ///free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           return NULL;     // no hay memoria para el arreglo
       }
       
       //strcpy(ltoken[i], t);
       strcpy(temp, t);
       sizei = i;
   } else sizei = i-1;

   // asigno espacio a la línea objetiva
   ///buf = (char *) malloc (sizeof(char *)*MAXBUFFER); // MAXBUFFER lo asgno por flag "512"
   buffer = (char *) calloc (MAXBUFFER,1);//sizeof(char *));
   char *buf = buffer;
   if (buf==NULL) {         // limpiar la memoria que ya fue asignada
       //free(ltoken);
       for (l=0;l<=i;++l) free(ltoken[l]);
       free(ltoken);
       free(buffer);
       return NULL;         // no hay memoria para el arreglo
   }
   // Reemplazo los tokens en la línea objetiva
   uint16_t ncampo=0;
   uint16_t lc=0;
   const char *c, *cc;

  // strcpy(buf,"");
   t = linea;
   while ((s = strstr(t,"$"))!=NULL) {
       l = s - t;
       strncat(buf,t,l);         // rescato porción de linea sin tocar, antes del token
       c = s+1;                  // desde el supuesto dígito en adelante
       while (isdigit(*c)) c++;  // obtengo el número del campo
       lc = c - s;               // longitud del número
       if (lc>1) {               // es un campo. 1= no es un campo
          char *cindice,*cind;        // para guardar los índices
          cindice = (char *) malloc (1*(lc+1));
          cind = cindice;
          if (cind==NULL) {     // limpiar la memoria que ya fue asignada
              ///free(ltoken);
              for (l=0;l<=i;++l) free(ltoken[l]);
              free(ltoken);
              free(buffer);
              return NULL;         // no hay memoria para el arreglo
          }
          
          strncpy(cind,s+1,lc);   // preparo el indice del arreglo para obtener token
          ncampo = atoi(cind);
          if (ncampo<=sizei) {     // es un campo válido??
             // aniadir aqui el pad, si lo hay
             const char * campo = ltoken[ncampo];
             if(*c==':'){  // aqui hay un pad
                cc = c;
                c++;  // me lo salto
                
                char *cPadding;
                char *cPadToken;        // para guardar los índices
                int w=0;
                
                while(isdigit(*c)) {c++;++w;}
                lc = c - ( cc+w);
                cPadding = (char *) calloc (lc+1,1);//sizeof(char *));
                cPadToken = (char * ) calloc (128,1);
                char * cPad = cPadding;
          	strncpy(cPad,(cc+w),lc);
          	
                int nPad = atoi(cPad);
                int sizeCampo = strlen(campo);
          	//printf("\nCIND=%d CPAD = %d sizeCampo=%d Campo=%s",ncampo,nPad,sizeCampo,campo);
                if(toupper(*c) == 'C'){  //0
                   cPadToken=strpad(campo,nPad,sizeCampo,0);
                }else if(toupper(*c) == 'L'){  //1
                   cPadToken=strpad(campo,nPad,sizeCampo,1);
                }else if(toupper(*c) == 'R'){  //2
                   cPadToken=strpad(campo,nPad,sizeCampo,2);
                }else{   // error
                   return NULL;
                }
               // printf("\nENTRA AQUI con %s\n",cPadToken);
                if (cPadToken!=NULL) 
                   strcat(buf,cPadToken);
                else
                   strcat(buf,"");

                // printf("\nESTA OK\n");
                c++;
                free(cPadding);
                free(cPadToken);
             }else{
                //strcat(buf,campo);
                char * cCampo = fun_alltrim( (const char*)campo, (HB_SIZE)strlen(campo));
                if (cCampo == NULL){
                   char * cCampo = (char * )calloc(1,1);
                   cCampo[0]='\0';
                }
                const char * pCampo = cCampo;
              //  printf("\nENTRA AQUI con %s\n",cCampo);
                strcat(buf, pCampo);
              //  printf("\nESTA OK\n");
                free(cCampo);
             }
          }
          t = c;              // siempre: por si o por no, el campo será eliminado igual
          free(cindice);
       } else {
          strncat(buf,s,1);   // rescato "$" que no es un campo
          t = ++s;            // avanzo un espacio y continúo el proceso
       }
   }
   // rescato lo último que no ha sido rescatado
   strcat (buf,t);
   int nLen = strlen(buf);
//   buf[nLen+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   char * Retorno = (char *) calloc (nLen+1,1);//sizeof(char));
   char * Ret = Retorno;
   strcpy(Ret,buf);
   
   // deguerbo resultado
   free(buffer);
   return Retorno;
/*
//   buf[strlen(buf)+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   // deguerbo resultado
   return buffer; */
}

char *fLPsaturate( const char *tokens, int* pos, int nPos, const char *linea){
   char *buffer;
   const char *t, *s;
   char **ltoken;     // lista de tokens
   uint16_t i=0,j=0,k=0,l, sizei;

   ltoken = (char**)malloc((nPos+1) * sizeof(char **) );
   // a ntok se suma 1, pues acá necesito los tokens, no los separadores, como en strtran. 

   if (ltoken==NULL) return NULL;   // no hay memoria

   // obtengo tokens y los guardo en un arreglo para reemplazar después.
   t = tokens;
   j = 0;
   const char *c,*cc;
   c = t;
   char *temp;
   while (j<nPos){   //((s = strstr(t,tok))!=NULL) {
   	   k=0;
   	   while (k++<pos[j]) c++;
       l = c - t;
       
       ltoken[i] = (char*)calloc( (l+1), 1);//sizeof(char) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           ///free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           return NULL;     // no hay memoria para el arreglo
       }
       
       //strncpy(ltoken[i], t, l); // guardo con espacio y todo, porque con strpad se eliminan.
       strncpy(temp, t, l);
       t = c;
       ++i;
       ++j;
   }

   if (t!=NULL) {           // queda un token más: lo capturo.
       ltoken[i] = (char*)calloc( (strlen(t)+1), 1);//sizeof(char) );
       temp = ltoken[i];
       if (temp==NULL) {     // limpiar la memoria que ya fue asignada
           ///free(ltoken);
           for (l=0;l<=i;++l) free(ltoken[l]);
           free(ltoken);
           return NULL;     // no hay memoria para el arreglo
       }
       
       //strcpy(ltoken[i], t);
       strcpy(temp, t);
       
       sizei = i-1;
   } else sizei = i-1;

   // asigno espacio a la línea objetiva
   buffer = (char *) calloc (MAXBUFFER,1);//sizeof(char));
   char *buf = buffer;
   if (buf==NULL) {         // limpiar la memoria que ya fue asignada
       //free(ltoken);
       for (l=0;l<=i;++l) free(ltoken[l]);
       free(ltoken);
       free(buffer);
       return NULL;         // no hay memoria para el arreglo
   }
   
   // Reemplazo los tokens en la línea objetiva
   uint16_t ncampo=0;
   uint16_t lc=0;
   
  // strcpy(buf,"");
   t = linea;
   
   while ((s = strstr(t,"$"))!=NULL) {
       l = s - t;
       strncat(buf,t,l);         // rescato porción de linea sin tocar, antes del token
       c = s+1;                  // desde el supuesto dígito en adelante
       while (isdigit(*c)) c++;  // obtengo el número del campo
       lc = c - s;               // longitud del número
       if (lc>1) {               // es un campo. 1= no es un campo
          char *cindice, *cind;        // para guardar los índices
          cindice = (char *) malloc (1*(lc+1));
          cind = cindice;
          //cindice = (char *) calloc (3,sizeof(char *));
          if (cind==NULL) {     // limpiar la memoria que ya fue asignada
             //free(ltoken);
             for (l=0;l<=i;++l) free(ltoken[l]);
             free(ltoken);
             free(buffer);
             return NULL;         // no hay memoria para el arreglo
          }
          
          strncpy(cind,s+1,lc);   // preparo el indice del arreglo para obtener token
          ncampo = atoi(cind);
          
          if (ncampo<=sizei) {     // es un campo válido??
             const char * campo = ltoken[ncampo];
          	 // aniadir aqui el pad, si lo hay
             if(*c==':'){  // aqui hay un pad
                 cc = c;
          	    c++;  // me lo salto
          	    char *cPad;
          	    char *cPadding;
          	    
          	    int w=0;

          	    while(isdigit(*c)) {c++;++w;}
          	    lc = c - ( cc+w);
          	    cPadding = (char *) calloc (lc+1,1);//sizeof(char));
          	    cPad = cPadding;
          	    strncpy(cPad,(cc+w),lc);
          	    int nPad = atoi(cPad);
          	    int sizeCampo = strlen(campo);
          	    char *cPadToken;        // para guardar los índices
          	    if(toupper(*c) == 'C'){  //0
          	       cPadToken=strpad(campo,nPad,sizeCampo,0);
          	    }else if(toupper(*c) == 'L'){  //1
          	       cPadToken=strpad(campo,nPad,sizeCampo,1);
          	    }else if(toupper(*c) == 'R'){  //2
          	       cPadToken=strpad(campo,nPad,sizeCampo,2);
          	    }else{   // error
          	       return NULL;
          	    }
          	    if (cPadToken!=NULL) 
                        strcat(buf,cPadToken);
                    else
                        strcat(buf,"");
                        
          	    c++;
          	    free(cPadding);
          	    free(cPadToken);
             }else{
                HB_SIZE nLenC = strlen(campo);
                char * cCampo = fun_alltrim( (const char*)campo, nLenC);
                if (cCampo == NULL){
                   char * cCampo = (char * )calloc(1,1);
                   cCampo[0]='\0';
                }
                const char * pCampo = cCampo;
                strcat(buf, (const char*)pCampo);  // aqui el problema
                free(cCampo);
             }
          }
          t = c;              // siempre: por si o por no, el campo será eliminado igual
          free(cindice);
       } else {
          strncat(buf,s,1);   // rescato "$" que no es un campo
          t = ++s;            // avanzo un espacio y continúo el proceso
       }
   }
   // rescato lo último que no ha sido rescatado
   strcat (buf,t);
   int nLen = strlen(buf);
//   buf[nLen+1]='\0';

   // libero memoria
   
   for (l=0;l<=i;++l) free(ltoken[l]);
   free(ltoken);
   
   char * Retorno = (char *) calloc (nLen+1,1);//sizeof(char));
   char * Ret = Retorno;
   strcpy(Ret,buf);
   
   // deguerbo resultado
   free(buffer);
   return Retorno;
}

HB_FUNC( XFUNCCCSATURA )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_STRING ); // tokens
    PHB_ITEM pB = hb_param( 2, HB_IT_STRING ); // B = separador
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = linea a rellenar
    
    char * pBuffer;
    pBuffer = (char *)fsaturate( hb_itemGetCPtr( pA ), hb_itemGetCPtr( pB ), 
                                 hb_itemGetCPtr( pD ));
    if (pBuffer==NULL){
       pBuffer = (char * ) calloc(1,1);
       pBuffer[0]='\0';
    }
    const char * Ret = pBuffer;
    hb_retc( Ret );
    free(pBuffer);
}

HB_FUNC( XFUNCACSATURA )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_STRING ); // tokens
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B = LARGO POSICION
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = linea a rellenar
    unsigned int nLen = hb_parni( 4 );
    
    /*** EXTRAIGO EL ARRAY A PROCESAR **/
    int pos[nLen];
    unsigned int i;
    
    for (i=0;i<nLen;i++){
       pos[i] = hb_itemGetNI(hb_itemArrayGet( pB, i+1));
    }
    char * pBuffer;
    pBuffer = (char *)fLPsaturate( hb_itemGetCPtr( pA ), pos, nLen,
                                 hb_itemGetCPtr( pD ));
    if (pBuffer==NULL){
       pBuffer = (char * ) calloc(1,1);
       pBuffer[0]='\0';
    }
    const char * Ret = pBuffer;
    hb_retc( Ret );
    free(pBuffer);
}

/***
   RTX:=XSATURA(TEMPORAL, AX, FX, EX, 0, {DIM1,DIM1R,DIM1C,DIM1P,DIM1B})     AX=ARRAY
   RTX:=XSATURA(TEMPORAL, AX, FX, EX, DIM2R, {DIM1,DIM1R,DIM1C,DIM1P,DIM1B}) AX=ARRAY y FX=VECTOR
   ***/      
HB_FUNC( XSATURA )
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A = TOKENS
    PHB_ITEM pB = hb_param( 2, HB_IT_ANY ); // B = separador o array posiciones
    PHB_ITEM pD = hb_param( 3, HB_IT_STRING ); // D = patron a saturar
    unsigned int pLen = hb_parni( 4 ); // 0=fsatura(sep), (!=)0 = fLPsatura(largo de array de pos)
    PHB_ITEM params   = hb_param( 5, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    
    PHB_ITEM pCWM = NULL;
    
    switch(pDim){
       case 1: {
          if( pLen ){  // largo posicion
             int pos[pLen];
             HB_MAXINT q;
             for (q=0;q<pLen;q++){
                PHB_ITEM pQ = hb_itemArrayGet( pB, q+1);
                pos[q] = hb_itemGetNInt(pQ);
                hb_itemRelease( pQ );
             }
             unsigned int n;
             const char * pDD = hb_itemGetCPtr( pD );
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                char * pBuffer;
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                pBuffer = (char *)fLPsaturate( hb_itemGetCPtr( pAA ), 
                                 pos, pLen, pDD);
                if (pBuffer==NULL){
                    pBuffer = (char * ) calloc(1,1);
                    pBuffer[0]='\0';
                }
                const char * Ret = pBuffer;
                hb_arraySetC( pCWM, n, Ret );
                free(pBuffer);
                hb_itemRelease( pAA );
             }
          }else{   // separador
             unsigned int n;
             const char * pDD = hb_itemGetCPtr( pD );
             const char * pBB = hb_itemGetCPtr( pB );
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                char * pBuffer;
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                pBuffer = (char *)fsaturate( hb_itemGetCPtr( pAA ), 
                                 pBB, pDD);
                if (pBuffer==NULL){
                    pBuffer = (char * ) calloc(1,1);
                    pBuffer[0]='\0';
                }
                const char * Ret = pBuffer;
                hb_arraySetC( pCWM, n, Ret );
                free(pBuffer);
                hb_itemRelease( pAA );
             }
          }
          break;
       }
       case 2: {
          if( pLen ){  // largo posicion
             int pos[pLen];
             unsigned int q;
             for (q=0;q<pLen;q++){
                PHB_ITEM pQ = hb_itemArrayGet( pB, q+1);
                pos[q] = hb_itemGetNInt( pQ );
                hb_itemRelease( pQ );
             }
             unsigned int n=1,m=1;
             
             const char * pDD = hb_itemGetCPtr( pD );
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                for( m=1; m<=pCol; m++){
                   char * pBuffer;
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   pBuffer = (char *)fLPsaturate( hb_itemGetCPtr( pAAA ), 
                                 pos, pLen, pDD);
                   if (pBuffer==NULL){
                      pBuffer = (char * ) calloc(1,1);
                      pBuffer[0]='\0';
                   }
                   const char * Ret = pBuffer;
                   hb_arraySetC( pCC, m, Ret );
                   free(pBuffer);
                   hb_itemRelease( pAAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);  
             }
          }else{   // separador
             const char * pDD = hb_itemGetCPtr( pD );
             const char * pBB = hb_itemGetCPtr( pB );

             unsigned int n=1,m=1;
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   char * pBuffer;
                   pBuffer = (char *)fsaturate( hb_itemGetCPtr( pAAA ), 
                                 pBB, pDD);
                   if (pBuffer==NULL){
                      pBuffer = (char * ) calloc(1,1);
                      pBuffer[0]='\0';
                   }
                   const char * Ret = pBuffer;
                   hb_arraySetC( pCC, m, Ret );
                   free(pBuffer);
                   hb_itemRelease( pAAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
          }
          break;       
       }
       case 3: {
          if( pLen ){  // largo posicion
             int pos[pLen];
             unsigned int q;
             for (q=0;q<pLen;q++){
                PHB_ITEM pQ = hb_itemArrayGet( pB, q+1);
                pos[q] = hb_itemGetNInt( pQ );
                hb_itemRelease( pQ );
             }
             unsigned int n=1,m=1,o=1;
             const char * pDD = hb_itemGetCPtr( pD );
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      char * pBuffer;
                      pBuffer = (char *)fLPsaturate( hb_itemGetCPtr( pAAAA ), 
                                 pos, pLen, pDD);
                      if (pBuffer==NULL){
                         pBuffer = (char * ) calloc(1,1);
                         pBuffer[0]='\0';
                      }
                      const char * Ret = pBuffer;
                      hb_arraySetC( pCCC, o, Ret );
                      free(pBuffer);
                      hb_itemRelease(pAAAA);   
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease(pAAA);
                   hb_itemRelease(pCCC);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
          }else{   // separador
             unsigned int n=1,m=1,o=1;

             const char * pDD = hb_itemGetCPtr( pD );
             const char * pBB = hb_itemGetCPtr( pB );
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      char * pBuffer;
                      pBuffer = (char *)fsaturate( hb_itemGetCPtr( pAAAA ), 
                                 pBB, pDD);
                      if (pBuffer==NULL){
                         pBuffer = (char * ) calloc(1,1);
                         pBuffer[0]='\0';
                      }
                      const char * Ret = pBuffer;
                      hb_arraySetC( pCCC, o, Ret );
                      free(pBuffer);
                      hb_itemRelease(pAAAA);   
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease(pAAA);
                   hb_itemRelease(pCCC);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
          }
          break;
       }
       case 4: {
          if( pLen ){  // largo posicion
             int pos[pLen];
             unsigned int q;
             for (q=0;q<pLen;q++){
                PHB_ITEM pQ = hb_itemArrayGet( pB, q+1);
                pos[q] = hb_itemGetNInt( pQ );
                hb_itemRelease( pQ );
             }
             unsigned int n=1,m=1,o=1,p=1;

             const char * pDD = hb_itemGetCPtr( pD );

             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                         char * pBuffer;
                         pBuffer = (char *)fLPsaturate( hb_itemGetCPtr( pAAAAA ), 
                                 pos, pLen, pDD);
                         if (pBuffer==NULL){
                            pBuffer = (char * ) calloc(1,1);
                            pBuffer[0]='\0';
                         }
                         const char * Ret = pBuffer;
                         hb_arraySetC( pCCCC, p, Ret );
                         free(pBuffer);
                         hb_itemRelease(pAAAAA);
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pCCCC);   
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease(pAAA);
                   hb_itemRelease(pCCC);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
          }else{   // separador

             unsigned int n=1,m=1,o=1,p=1;

             const char * pDD = hb_itemGetCPtr( pD );
             const char * pBB = hb_itemGetCPtr( pB );
             pCWM = hb_itemArrayNew( pRow ); // CWM 
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                         char * pBuffer;
                         pBuffer = (char *)fsaturate( hb_itemGetCPtr( pAAAAA ), 
                                 pBB, pDD);
                         if (pBuffer==NULL){
                            pBuffer = (char * ) calloc(1,1);
                            pBuffer[0]='\0';
                         }

                         const char * Ret = pBuffer;
                         hb_arraySetC( pCCCC, p, Ret );
                         free(pBuffer);
                         hb_itemRelease(pAAAAA);
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease(pAAAA);
                      hb_itemRelease(pCCCC);   
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease(pAAA);
                   hb_itemRelease(pCCC);
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease(pAA);
                hb_itemRelease(pCC);
             }
          }
          break;
       }
    }
    hb_itemReturnRelease( pCWM );
}


char *fun_rtrim(const char *linea, HB_SIZE size) { 

   size--;   // me salto el '\0'
   char * r, *buffer;
   const char * pLinea = linea;
   const char * t;
   HB_SIZE tsize;

   t = pLinea;
   t += size;
   if (*t=='\n' || *t=='\t' || *t=='\r' || *t==' '){
      while ((*t=='\n' || *t=='\t' || *t=='\r' || *t==' ') && t!=pLinea) t--;
      if (t==pLinea) return NULL;
   }
   tsize = t - pLinea + 2;

   buffer = (char *) calloc(tsize,1);//sizeof(char *) );
   if (buffer==NULL) return NULL;
   r = buffer;
   strncpy(r,pLinea,tsize-1);
   r[tsize-1]='\0';
   return buffer;
}

char * fun_ltrim(const char *linea, HB_SIZE size) {

   const char *t;
   t = linea;
   size_t s_size;

   if (*t=='\n' || *t=='\t' || *t=='\r' || *t==' '){
      while (( *t=='\t' || *t=='\r' || *t=='\n' || *t==' ') && *t) t++;
      if (!*t) return NULL;
   }
   char *r, *buffer;
   s_size = size - (t - linea) + 1;
   buffer = (char *) calloc(s_size,sizeof(char *));
   if (buffer==NULL) return NULL;
   r = buffer;
   strncpy( r, t, s_size-1 );
   r[s_size]='\0';
   return buffer;
} 


char *fun_upper(const char *linea, HB_SIZE size){
   char *buffer,*t;
   const char* pLinea = linea;
   HB_SIZE i;
   buffer=(char *)calloc((size+1),1);//sizeof(char));
   if (buffer==NULL) return NULL;
   t = buffer;
   for (i=0;i<size;i++) {
      t[i] = HB_TOUPPER(*pLinea);
      pLinea++;
   } 
   t[i]='\0';

   return buffer; 
}

char *fun_lower(const char *linea, HB_SIZE size){
   char *buffer,*t; 
   HB_SIZE i;
   buffer=(char *)calloc((size+1),1); //sizeof(char));
   if (buffer==NULL) return NULL;
   t = buffer;
   for (i=0;i<size;i++) {
      t[i] = HB_TOLOWER(*linea);
      linea++;
   } 
   t[i]='\0';

   return buffer; 
}

HB_FUNC( XMMSTRING )  // solo números y booleanos
{
  struct {
     char * (*h)(const char *, HB_SIZE);
  } oFunStr[5]= {{fun_alltrim},{fun_ltrim},{fun_rtrim},{fun_lower},{fun_upper}};

    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A
    unsigned int pDim = hb_parni( 2 );   // dimension de matrices
    unsigned int pRow = hb_parni( 3 );   // rows
    unsigned int pCol = hb_parni( 4 );   // cols
    unsigned int pPag = hb_parni( 5 );   // pags
    unsigned int pBlk = hb_parni( 6 );   // blks
    unsigned int codfun = hb_parni( 7 );   // funcion a calcular.
    
    PHB_ITEM pCWM = NULL;    // resultado
    int strOk=1;
    
    switch( pDim )
    {
    case 1 : 
    {
       unsigned int n=1;
       pCWM = hb_itemArrayNew( pRow ); // CWM
       for( n=1; n<=pRow; n++){
          PHB_ITEM ppA = hb_itemArrayGet( pA, n);
          char * Str = (*oFunStr[codfun].h)( hb_itemGetCPtr( ppA),
                                          hb_itemGetCLen( ppA ));
          const char * buff = Str;
          hb_itemRelease( ppA );
          if (buff != NULL)
             hb_arraySetC( pCWM, n, buff );
          else{
             strOk = 0;
             break;
          }
          free(Str);
       }
       break;
    }
    case 2 :
    {

       unsigned int n=1,m=1;

       pCWM = hb_itemArrayNew( pRow ); // CWM
       for( n=1; n<=pRow; n++){
          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          for( m=1; m<=pCol; m++){
             PHB_ITEM pSource = hb_itemArrayGet( pAA, m );
             char * Str = (*oFunStr[codfun].h)(hb_itemGetCPtr( pSource ),
                                          hb_itemGetCLen( pSource ));
             hb_itemRelease( pSource );
             const char * buff = Str;
             if (buff != NULL)
                hb_arraySetC( pCC, m,buff );
             else{
                strOk = 0;
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
                break;
             }
             free(Str);
          }
          if ( !strOk ) break;
          hb_arraySet( pCWM, n, pCC );
          hb_itemRelease( pCC );
          hb_itemRelease( pAA );
       }
       break;
    }
    case 3 :
    {
       
       unsigned int n=1,m=1,o=1;

       pCWM = hb_itemArrayNew( pRow ); // CWM
       for( n=1; n<=pRow; n++){
          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          for( m=1; m<=pCol; m++){
             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m );
             for( o=1; o<=pPag; o++){
                PHB_ITEM pSource = hb_itemArrayGet( pAAA, o );
                char * Str = (*oFunStr[codfun].h)(hb_itemGetCPtr( pSource ),
                                          hb_itemGetCLen( pSource ));
                hb_itemRelease( pSource ); 
                const char * buff = Str;
                if (buff != NULL)
                   hb_arraySetC( pCCC, o,buff );
                else{
                   strOk = 0;
                   hb_itemRelease( pCCC );
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                   break;
                }
                free(Str);
                
             }
             if ( !strOk ) break;
             hb_arraySet( pCC, n, pCCC );
             hb_itemRelease( pCCC );
             hb_itemRelease( pAAA );
          }
          if ( !strOk ) break;
          hb_arraySet( pCWM, n, pCC );
          hb_itemRelease( pCC );
          hb_itemRelease( pAA );
       }
       break;
    }
    case 4 :
    {

       unsigned int n=1,m=1,o=1,p=1;

       pCWM = hb_itemArrayNew( pRow ); // CWM
       for( n=1; n<=pRow; n++){
          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
          for( m=1; m<=pCol; m++){
             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m );
             for( p=1; p<=pPag; p++){
                PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, p );
                for( o=1; p<=pBlk; o++){
                    PHB_ITEM pSource = hb_itemArrayGet( pAAAA, o );
                    char * Str = (*oFunStr[codfun].h)(hb_itemGetCPtr( pSource ),
                                          hb_itemGetCLen( pSource ));
                    hb_itemRelease( pSource );
                    const char * buff = Str;
                    if (buff != NULL)
                       hb_arraySetC( pCCCC, o,buff );
                    else{
                       strOk = 0;
                       hb_itemRelease( pCCCC );
                       hb_itemRelease( pAAAA );
                       hb_itemRelease( pCCC );
                       hb_itemRelease( pAAA );
                       hb_itemRelease( pCC );
                       hb_itemRelease( pAA );
                       break;
                    }
                    free(Str);
                    
                }
                if ( !strOk ) break;
                hb_arraySet( pCCC, p, pCCCC );
                hb_itemRelease( pCCCC );
                hb_itemRelease( pAAAA );
             }
             if ( !strOk ) break;
             hb_arraySet( pCC, m, pCCC );
             hb_itemRelease( pCCC );
             hb_itemRelease( pAAA );
          }
          if ( !strOk ) break;
          hb_arraySet( pCWM, n, pCC );
          hb_itemRelease( pCC );
          hb_itemRelease( pAA );
       }
       break;
    }
    }
    if ( !strOk ){
       hb_itemRelease(pCWM);
       pCWM = hb_itemArrayNew( 0 ); // CWM
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( XMMLET )  // solo números y booleanos
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A
    unsigned int pDim = hb_parni( 2 );   // dimension de matrices
    unsigned int pRow = hb_parni( 3 );   // rows
    unsigned int pCol = hb_parni( 4 );   // cols
    unsigned int pPag = hb_parni( 5 );   // pags
    unsigned int pBlk = hb_parni( 6 );   // blks
    unsigned int codfun = hb_parni( 7 );   // funcion a calcular.
    
    PHB_ITEM pCWM = NULL;    // resultado
    
    switch( pDim )
    {
    case 1 :
    {
       
       unsigned int n=1;
       PHB_ITEM ppA = hb_itemArrayGet( pA, 1);
       
       if( HB_IS_STRING( ppA ) ){
          hb_itemRelease( ppA );
          switch( codfun ){
             case 0 :
             {
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM ppA = hb_itemArrayGet( pA, n);
                   hb_arraySetC( pCWM, n, (const char *)hb_itemGetCPtr( ppA ));
                   hb_itemRelease( ppA );
                }
                break;
             }
             case 5 : // strlen
             {
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM ppA = hb_itemArrayGet( pA, n);
                   hb_arraySetNI( pCWM, n, (HB_SIZE)hb_itemGetCLen( ppA ));
                   hb_itemRelease( ppA );
                }
                break;
             }
             case 9 :  // strlz
             {
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM ppA = hb_itemArrayGet( pA, n);
                   hb_arraySetL( pCWM, n, hb_itemGetCLen( ppA )<=0 ? HB_TRUE : HB_FALSE  );
                   hb_itemRelease( ppA );
                }
                break;
             }
          }
       }else if( HB_IS_LOGICAL( ppA ) ){
          hb_itemRelease( ppA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM ppA = hb_itemArrayGet( pA, n);
             hb_arraySetL( pCWM, n, (HB_BOOL) hb_itemGetL( ppA ) ) ;
             hb_itemRelease( ppA );
          }
       }else{
          PHB_ITEM pSource = hb_itemArrayGet( pA, 1 );
          hb_itemRelease( ppA ); 
          switch( codfun ){
             case 0 :
             {
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM ppA = hb_itemArrayGet( pA, n);
                   hb_arraySetND( pCWM, n, (double) hb_itemGetND( ppA ) );
                   hb_itemRelease( ppA );
                }
                break;
             }
             case 1 :   // por ahora: random=1
             {
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM ppA = hb_itemArrayGet( pA, n);
                   hb_arraySetND( pCWM, n, (double) hb_itemGetND( ppA ) * hb_random_num() );
                   hb_itemRelease( ppA );
                }
                break;
             }
             case 2 :   // asigna entero por division entera con 1
             {
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM ppA = hb_itemArrayGet( pA, n);
                   hb_arraySetNL( pCWM, n, (long) hb_itemGetNL( ppA ) );
                   hb_itemRelease( ppA );
                }
                break;
             }
          }
          hb_itemRelease( pSource );
       }
       break;
    }
    case 2 :
    {
       PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
       PHB_ITEM pSource = hb_itemArrayGet( pAA, 1 );
       hb_itemRelease( pAA );
       
       unsigned int n=1,m=1;
              
       switch( codfun ){
          case 0 :
          {
             if( HB_IS_STRING( pSource ) ){
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetC( pCC, m, (const char *) hb_itemGetCPtr( ppAA ) );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }else if( HB_IS_LOGICAL( pSource ) ){
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetL( pCC, m, (HB_BOOL) hb_itemGetL( ppAA ) );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }else{  // es numero
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetND( pCC, m, (double) hb_itemGetND( ppAA ) );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 5 :  // strlen
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetNI( pCC, m, (HB_SIZE)hb_itemGetCLen( ppAA ));
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
          case 9 :  // strlz
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetL( pCC, m, hb_itemGetCLen( ppAA )<=0 ? HB_TRUE : HB_FALSE  );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
          case 1 :  // random
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetND( pCC, m, (double) hb_itemGetND( ppAA ) * hb_random_num() );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 :  // asigna entero por division entera con 1
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   hb_arraySetNL( pCC, m, (long) hb_itemGetNL( ppAA ) );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
       }
       hb_itemRelease( pSource );
       break;
    }
    case 3 :
    {
       PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
       PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1);
       PHB_ITEM pSource = hb_itemArrayGet( pAAA, 1 );
       hb_itemRelease( pAAA );
       hb_itemRelease( pAA );

       unsigned int n=1,m=1,o=1;
       
       switch( codfun ){
          case 0 :   // asigna normal
          {
             if( HB_IS_STRING( pSource ) ){
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetC( pCCC, o, (const char *) hb_itemGetCPtr( ppAAA ) );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }else if( HB_IS_LOGICAL( pSource ) ){
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetL( pCCC, o, (HB_BOOL) hb_itemGetL( ppAAA ) );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }else{   // es numero
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetND( pCCC, o, (double) hb_itemGetND( ppAAA ) );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 5 :  // strlen
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetNI( pCCC, o, (HB_SIZE)hb_itemGetCLen( ppAAA ));
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             break;
          }
          case 9 :  // strlz
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetL( pCCC, o, hb_itemGetCLen( ppAAA )<=0 ? HB_TRUE : HB_FALSE  );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             break;
          }
          case 1 :  // random
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetND( pCCC, o, (double) hb_itemGetND( ppAAA )
                              * hb_random_num());
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             break;
          }
          case 2 :  // asigna entero por div entera con 1
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         hb_arraySetNL( pCCC, o, (long) hb_itemGetNL( ppAAA ) );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             break;
          }
       }
       hb_itemRelease( pSource );
       break;
    }

    case 4 :
    {
       PHB_ITEM pAA = hb_itemArrayGet( pA, 1);
       PHB_ITEM pAAA = hb_itemArrayGet( pAA, 1);
       PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, 1);
       PHB_ITEM pSource = hb_itemArrayGet( pAAAA, 1 );
       hb_itemRelease( pAAAA );
       hb_itemRelease( pAAA );
       hb_itemRelease( pAA );

       unsigned int n=1,m=1,o=1,p=1;
       
       switch( codfun ){
          case 0 :
          {
             if( HB_IS_STRING( pSource ) ){
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                            hb_arraySetC( pCCCC, p, (const char *) hb_itemGetCPtr( ppAAAA ) );
                            hb_itemRelease( ppAAAA );
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease( pCCCC );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }else if( HB_IS_LOGICAL( pSource ) ){
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                            hb_arraySetL( pCCCC, p, (HB_BOOL) hb_itemGetL( ppAAAA ) );
                            hb_itemRelease( ppAAAA );
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease( pCCCC );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }else{   // numero
                pCWM = hb_itemArrayNew( pRow ); // CWM
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                      PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                         PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                            hb_arraySetND( pCCCC, p, (double) hb_itemGetND( ppAAAA ) );
                            hb_itemRelease( ppAAAA );
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease( pCCCC );
                         hb_itemRelease( ppAAA );
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease( pCCC );
                      hb_itemRelease( ppAA );
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease( pCC );
                   hb_itemRelease( pAA );
                }
             }
             break;
          }
          case 5 :  // strlen
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                      PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                         hb_arraySetNI( pCCCC, p, (HB_SIZE)hb_itemGetCLen( ppAAAA ));
                         hb_itemRelease( ppAAAA );
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease( pCCCC );
                      hb_itemRelease( ppAAA );
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease( pCCC );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
          case 9 :  // strlz
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                      PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                         hb_arraySetL( pCCCC, p, hb_itemGetCLen( ppAAAA )<=0 ? HB_TRUE : HB_FALSE  );
                         hb_itemRelease( ppAAAA );
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease( pCCCC );
                      hb_itemRelease( ppAAA );
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease( pCCC );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
          case 1 : //  random
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                      PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                         hb_arraySetND( pCCCC, p, (double) hb_itemGetND( ppAAAA ) 
                              * hb_random_num() );
                         hb_itemRelease( ppAAAA );
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease( pCCCC );
                      hb_itemRelease( ppAAA );
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease( pCCC );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
          case 2 :  // div entera con 1
          {
             pCWM = hb_itemArrayNew( pRow ); // CWM
             for( n=1; n<=pRow; n++){
                PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                   PHB_ITEM ppAA = hb_itemArrayGet( pAA, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                      PHB_ITEM ppAAA = hb_itemArrayGet( ppAA, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM ppAAAA = hb_itemArrayGet( ppAAA, p);
                         hb_arraySetNL( pCCCC, p, (long) hb_itemGetNL( ppAAAA ) );
                         hb_itemRelease( ppAAAA );
                      }
                      hb_arraySet( pCCC, o, pCCCC );
                      hb_itemRelease( pCCCC );
                      hb_itemRelease( ppAAA );
                   }
                   hb_arraySet( pCC, m, pCCC );
                   hb_itemRelease( pCCC );
                   hb_itemRelease( ppAA );
                }
                hb_arraySet( pCWM, n, pCC );
                hb_itemRelease( pCC );
                hb_itemRelease( pAA );
             }
             break;
          }
       } 
       hb_itemRelease( pSource );
       break;
    }
    }
   // hb_itemClear( pA );
    hb_itemReturnRelease( pCWM );
}

// XEMLET(stk_var_02[EBX],stk_var_02[EAX],1,DIMR,0,0,0)
/* LA FORMA DE ASIGNACIÓN POR FILAS ES DEMASIADO COSTOSA PARA MATRICES GRANDES.
  LO NATURAL PARA HARBOUR ES BLOK,PAG,COL,FIL.
  USAR EL METODO FILA SOLO PARA RESHAPE, Y QUE DIOS SE APIADE DE TU ALMA IMPÍA
  CONCHETUMARE*/
HB_FUNC( XEMLET )  
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ANY ); // A
    unsigned int pDim = hb_parni( 2 );   // dimension de matrices
    unsigned int pRow = hb_parni( 3 );   // rows
    unsigned int pCol = hb_parni( 4 );   // cols
    unsigned int pPag = hb_parni( 5 );   // pags
    unsigned int pBlk = hb_parni( 6 );   // blks
    
    double pDouble;
    HB_BOOL pBool;
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim )
    {
    case 1 :
    {
       unsigned int n=1; 
       if( HB_IS_STRING( pA ) ){
          const char * pString = hb_itemGetCPtr( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             hb_arraySetC( pCWM, n, (const char *) pString   );
          }
       }else if( HB_IS_LOGICAL( pA ) ){
          pBool = hb_itemGetL( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             hb_arraySetL( pCWM, n, (HB_BOOL) pBool ) ;
          }
       }else{   // numero
          pDouble = hb_itemGetND( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             hb_arraySetND( pCWM, n, (double) pDouble );
          }
       }
       break;
    }
    case 2 :
    {

       unsigned int n=1,m=1; 

       if( HB_IS_STRING( pA ) ){
          const char * pString = hb_itemGetCPtr( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                hb_arraySetC( pCC, m, (const char *) pString );
             }   
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }else if( HB_IS_LOGICAL( pA ) ){
          pBool = hb_itemGetL( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                hb_arraySetL( pCC, m, (HB_BOOL) pBool );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }else{
          pDouble = hb_itemGetND( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                hb_arraySetND( pCC, m, (double) pDouble );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }
       break;
    }
    case 3 :
    {

       unsigned int n=1,m=1,o=1; 
       
       if( HB_IS_STRING( pA ) ){
          const char * pString = hb_itemGetCPtr( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                for( o=1; o<=pPag; o++){
                   hb_arraySetC( pCCC, o, (const char *)pString );
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease( pCCC );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }else if( HB_IS_LOGICAL( pA ) ){
          pBool = hb_itemGetL( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                for( o=1; o<=pPag; o++){
                   hb_arraySetL( pCCC, o,(HB_BOOL) pBool );
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease( pCCC );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }else{
          pDouble = hb_itemGetND( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                for( o=1; o<=pPag; o++){
                   hb_arraySetND( pCCC, o, (double) pDouble );
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease( pCCC );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }
       break;
    }
    case 4 :
    {

       unsigned int n=1,m=1,o=1,p=1; 

       if( HB_IS_STRING( pA ) ){
          const char * pString = hb_itemGetCPtr( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                   for( p=1; p<=pBlk; p++){
                      hb_arraySetC( pCCCC, p, (const char *) pString );
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease( pCCCC );
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease( pCCC );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }else if( HB_IS_LOGICAL( pA ) ){
          pBool = hb_itemGetL( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                   for( p=1; p<=pBlk; p++){
                      hb_arraySetL( pCCCC, p, (HB_BOOL) pBool );
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease( pCCCC );
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease( pCCC );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }
       }else{
          pDouble = hb_itemGetND( pA );
          pCWM = hb_itemArrayNew( pRow ); // CWM
          for( n=1; n<=pRow; n++){
             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
             for( m=1; m<=pCol; m++){
                PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                   for( p=1; p<=pBlk; p++){
                      hb_arraySetND( pCCCC, p, (double) pDouble );
                   }
                   hb_arraySet( pCCC, o, pCCCC );
                   hb_itemRelease( pCCCC );
                }
                hb_arraySet( pCC, m, pCCC );
                hb_itemRelease( pCCC );
             }
             hb_arraySet( pCWM, n, pCC );
             hb_itemRelease( pCC );
          }   
       }
       break;
    }
    }
    hb_itemClear(pA);
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( XMMEQUAL )   // verifica si 2 mats son iguales. Al primer distinto, chao.
{
    PHB_ITEM pA = hb_param( 1, HB_IT_ARRAY ); // A
    PHB_ITEM pB = hb_param( 2, HB_IT_ARRAY ); // B
    unsigned int pDim = hb_parni( 3 );   // dimension de matrices
    unsigned int pRow = hb_parni( 4 );   // rows
    unsigned int pCol = hb_parni( 5 );   // cols
    unsigned int pPag = hb_parni( 6 );   // pags
    unsigned int pBlk = hb_parni( 7 );   // blks
    int codfun = hb_parni( 8 );
    const char * tipo = hb_parc(9);
    
    int equalOk = 1;

    if( strcmp (tipo,"N") == 0 ){
       if( codfun == 1 || codfun == 6 ){  // NEQ or EQ?
          switch( pDim ){
          case 1 : {
             unsigned int n=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                if( hb_itemGetND( pAA ) != hb_itemGetND( pBB ) ){
                   if ( codfun == 6 ){
                      equalOk = 0;
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                }else if ( codfun == 1 ){
                   equalOk = 0;
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   break;
                }
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 2 :{
             unsigned int n=1,m=1;

             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   if( hb_itemGetND( pAAA ) != hb_itemGetND( pBBB ) ){
                      if ( codfun == 6 ){
                         equalOk = 0;
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                   }else if ( codfun == 1 ){
                      equalOk = 0;
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 3 :{
             unsigned int n=1,m=1,o=1;
       
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      if( hb_itemGetND( pAAAA ) != hb_itemGetND( pBBBB ) ){
                         if ( codfun == 6 ){
                            equalOk = 0;
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            break;
                         }
                      }else if ( codfun == 1 ){
                         equalOk = 0;
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                   } 
                   if ( !equalOk ) break;  
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 4 :{
             unsigned int n=1,m=1,o=1,p=1;

             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                         PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                         if( hb_itemGetND( pAAAAA ) != hb_itemGetND( pBBBBB ) ){
                            if ( codfun == 6 ){
                               equalOk = 0;
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pAAAA );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               break;
                            }
                         }else if ( codfun == 1 ){
                            equalOk = 0;
                            hb_itemRelease( pAAAAA );
                            hb_itemRelease( pBBBBB );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            break;
                         }
                         hb_itemRelease( pAAAAA );
                         hb_itemRelease( pBBBBB );
                      }
                      if ( !equalOk ) break;
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                   }
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );   
             }
             break;
          }
          } // switch
       }else if( codfun == 2 || codfun == 5 ){   // GET >= or LT < ?
          switch( pDim ){
          case 1 :{
             unsigned int n=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                if( hb_itemGetND( pAA ) < hb_itemGetND( pBB ) ){
                   if ( codfun == 2 ){
                      equalOk = 0;
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                }else if( codfun == 5){
                   equalOk = 0;
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   break;
                }
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 2 :{
             unsigned int n=1,m=1;
       
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   if( hb_itemGetND( pAAA ) < hb_itemGetND( pBBB ) ){
                      if ( codfun == 2 ){
                         equalOk = 0;
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                   }else if( codfun == 5){
                      equalOk = 0;
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 3 :{
             unsigned int n=1,m=1,o=1;
         
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      if( hb_itemGetND( pAAAA ) < hb_itemGetND( pBBBB ) ){
                         if ( codfun == 2 ){
                            equalOk = 0;
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            break;
                         }
                      }else if( codfun == 5){
                         equalOk = 0;
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                   }
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 4 :{
             unsigned int n=1,m=1,o=1,p=1;
       
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                         PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                         if( hb_itemGetND( pAAAAA ) < hb_itemGetND( pBBBBB ) ){
                            if ( codfun == 2 ){
                               equalOk = 0;
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pAAAA );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               break;
                            }
                         }else if( codfun == 5){
                            equalOk = 0;
                            hb_itemRelease( pAAAAA );
                            hb_itemRelease( pBBBBB );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            break;
                         }
                         hb_itemRelease( pAAAAA );
                         hb_itemRelease( pBBBBB );
                      }
                      if ( !equalOk ) break;
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                   }
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }
          }  // switch
       }else if( codfun == 3 || codfun == 4 ){  // LET <= or GT > ?
          switch( pDim ){
          case 1:{
             unsigned int n=1;
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                if( hb_itemGetND( pAA ) > hb_itemGetND( pBB ) ){
                   if ( codfun == 3 ){
                      equalOk = 0;
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                }else if( codfun == 4 ){
                   equalOk = 0;
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   break;
                }
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 2 :{
             unsigned int n=1,m=1;
       
             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   if( hb_itemGetND( pAAA ) > hb_itemGetND( pBBB ) ){
                      if ( codfun == 3 ){
                         equalOk = 0;
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                   }else if( codfun == 4 ){
                      equalOk = 0;
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 3 :{
             unsigned int n=1,m=1,o=1;

             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      if( hb_itemGetND( pAAAA ) > hb_itemGetND( pBBBB ) ){
                         if ( codfun == 3 ){
                            equalOk = 0;
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            break;
                         }
                      }else if( codfun == 4 ){
                         equalOk = 0;
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                   }
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }case 4 :{
             unsigned int n=1,m=1,o=1,p=1;

             for( n=1; n<=pRow; n++){
                PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                for( m=1; m<=pCol; m++){
                   PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                   PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                   for( o=1; o<=pPag; o++){
                      PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                      PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                      for( p=1; p<=pBlk; p++){
                         PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                         PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                         if( hb_itemGetND( pAAAAA ) > hb_itemGetND( pBBBBB ) ){
                            if ( codfun == 3 ){
                               equalOk = 0;
                               hb_itemRelease( pAAAAA );
                               hb_itemRelease( pBBBBB );
                               hb_itemRelease( pAAAA );
                               hb_itemRelease( pBBBB );
                               hb_itemRelease( pAAA );
                               hb_itemRelease( pBBB );
                               hb_itemRelease( pAA );
                               hb_itemRelease( pBB );
                               break;
                            }
                         }else if( codfun == 4 ){
                            equalOk = 0;
                            hb_itemRelease( pAAAAA );
                            hb_itemRelease( pBBBBB );
                            hb_itemRelease( pAAAA );
                            hb_itemRelease( pBBBB );
                            hb_itemRelease( pAAA );
                            hb_itemRelease( pBBB );
                            hb_itemRelease( pAA );
                            hb_itemRelease( pBB );
                            break;
                         }
                         hb_itemRelease( pAAAAA );
                         hb_itemRelease( pBBBBB );
                      }
                      if ( !equalOk ) break;
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                   }   
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                }
                if ( !equalOk ) break;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
             }
             break;
          }
          }  // switch
       }
    }
    else
    {
       switch( pDim ){
       case 1 :{
          unsigned int n=1;
          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             if( strcmp( hb_itemGetCPtr( pAA ), hb_itemGetCPtr( pBB ) ) != 0 ){
                equalOk = 0;
                hb_itemRelease( pAA );
                hb_itemRelease( pBB );
                break;
             }
             hb_itemRelease( pAA );
             hb_itemRelease( pBB );
          }
          break;
       }case 2 :{
          unsigned int n=1,m=1;

          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                if( strcmp( hb_itemGetCPtr( pAAA ), hb_itemGetCPtr( pBBB ) ) != 0 ){
                   equalOk = 0;
                   hb_itemRelease( pAAA );
                   hb_itemRelease( pBBB );
                   hb_itemRelease( pAA );
                   hb_itemRelease( pBB );
                   break;
                }
                hb_itemRelease( pAAA );
                hb_itemRelease( pBBB );
             }
             if ( !equalOk ) break;
             hb_itemRelease( pAA );
             hb_itemRelease( pBB );
          }
          break;
       }case 3 :{
          unsigned int n=1,m=1,o=1;

          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                   if( strcmp( hb_itemGetCPtr( pAAAA ), hb_itemGetCPtr( pBBBB ) ) != 0 ){
                      equalOk = 0;
                      hb_itemRelease( pAAAA );
                      hb_itemRelease( pBBBB );
                      hb_itemRelease( pAAA );
                      hb_itemRelease( pBBB );
                      hb_itemRelease( pAA );
                      hb_itemRelease( pBB );
                      break;
                   }
                   hb_itemRelease( pAAAA );
                   hb_itemRelease( pBBBB );
                }   
                if ( !equalOk ) break;
                hb_itemRelease( pAAA );
                hb_itemRelease( pBBB );
             }
             if ( !equalOk ) break;
             hb_itemRelease( pAA );
             hb_itemRelease( pBB );
          }
          break;
       }case 4 :{
          unsigned int n=1,m=1,o=1,p=1;

          for( n=1; n<=pRow; n++){
             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
             PHB_ITEM pBB = hb_itemArrayGet( pB, n);
             for( m=1; m<=pCol; m++){
                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                for( o=1; o<=pPag; o++){
                   PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                   PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                   for( p=1; p<=pBlk; p++){
                      PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                      PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                      if( strcmp( hb_itemGetCPtr( pAAAAA ), hb_itemGetCPtr( pBBBBB ) ) != 0 ){
                         equalOk = 0;
                         hb_itemRelease( pAAAAA );
                         hb_itemRelease( pBBBBB );
                         hb_itemRelease( pAAAA );
                         hb_itemRelease( pBBBB );
                         hb_itemRelease( pAAA );
                         hb_itemRelease( pBBB );
                         hb_itemRelease( pAA );
                         hb_itemRelease( pBB );
                         break;
                      }
                      hb_itemRelease( pAAAAA );
                      hb_itemRelease( pBBBBB );
                   }
                   if ( !equalOk ) break;
                   hb_itemRelease( pAAAA );
                   hb_itemRelease( pBBBB );
                }   
                if ( !equalOk ) break;
                hb_itemRelease( pAAA );
                hb_itemRelease( pBBB );
             }
             if ( !equalOk ) break;
             hb_itemRelease( pAA );
             hb_itemRelease( pBB );
          }
          break;
       }
       } // switch
    }

    hb_retni( equalOk );
}

HB_FUNC( XCASTEO )
{
    PHB_ITEM pA       = hb_param( 1, HB_IT_ARRAY ); // A
    PHB_ITEM params   = hb_param( 2, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    int codfun        = hb_itemGetNI( p6 ); // 0=int, 1=long, 2=double
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    
    PHB_ITEM pCWM = NULL;
    
    switch( pDim ){
       case 1:{
          switch( codfun ){
             case 0:{
                unsigned int n;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   hb_arraySetNInt( pCWM, n, (HB_MAXINT)hb_itemGetND( pAA ) ); 
                   hb_itemRelease( pAA );
                }
                break;
             }case 1:{
                unsigned int n;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   hb_arraySetNL( pCWM, n, (long)hb_itemGetND( pAA ) );
                   hb_itemRelease( pAA );
                }
                break;
             }case 2:{
                unsigned int n;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) );
                   hb_itemRelease( pAA );
                }
                break;
             }
          }
          break;
       }
       case 2:{
          switch( codfun ){
             case 0:{
                unsigned int n=1,m=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetNInt( pCC, m, (HB_MAXINT)hb_itemGetND( pAAA ) );
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }case 1:{
                unsigned int n=1,m=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetNL( pCC, m, (long)hb_itemGetND( pAAA ) );
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }case 2:{
                unsigned int n=1,m=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) );
                      hb_itemRelease(pAAA);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       }
       case 3:{
          switch( codfun ){
             case 0:{
                unsigned int n=1,m=1,o=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         hb_arraySetNInt( pCCC, o, (HB_MAXINT)hb_itemGetND( pAAAA ) );
                         hb_itemRelease(pAAAA);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }case 1:{
                unsigned int n=1,m=1,o=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         hb_arraySetNL( pCCC, o, (long)hb_itemGetND( pAAAA ) );
                         hb_itemRelease(pAAAA);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }case 2:{
                unsigned int n=1,m=1,o=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) );
                         hb_itemRelease(pAAAA);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       }
       case 4:{
          switch( codfun ){
             case 0:{
                unsigned int n=1,m=1,o=1,p=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            hb_arraySetNInt( pCCCC, p, (HB_MAXINT)hb_itemGetND( pAAAAA ) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);   
                }
                break;
             }case 1:{
                unsigned int n=1,m=1,o=1,p=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            hb_arraySetNL( pCCCC, p, (long)hb_itemGetND( pAAAAA ) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }case 2:{
                unsigned int n=1,m=1,o=1,p=1;
                pCWM = hb_itemArrayNew( pRow ); // CWM 
                for( n=1; n<=pRow; n++){
                   PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                   PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM 
                   for( m=1; m<=pCol; m++){
                      PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                      PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM 
                      for( o=1; o<=pPag; o++){
                         PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                         PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM 
                         for( p=1; p<=pBlk; p++){
                            PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                            hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) );
                            hb_itemRelease(pAAAAA);
                         }
                         hb_arraySet( pCCC, o, pCCCC );
                         hb_itemRelease(pAAAA);
                         hb_itemRelease(pCCCC);   
                      }
                      hb_arraySet( pCC, m, pCCC );
                      hb_itemRelease(pAAA);
                      hb_itemRelease(pCCC);
                   }
                   hb_arraySet( pCWM, n, pCC );
                   hb_itemRelease(pAA);
                   hb_itemRelease(pCC);
                }
                break;
             }
          }
          break;
       }
    }
    hb_itemReturnRelease( pCWM );
}

HB_FUNC( XMMCOMPUTE )
{
    PHB_ITEM pA       = hb_param( 1, HB_IT_ARRAY ); // A
    PHB_ITEM pB       = hb_param( 2, HB_IT_ARRAY ); // B
    PHB_ITEM params   = hb_param( 3, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    int codfun        = hb_itemGetNI( p6 ); // suma, resta, multipl.
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    
    double pDenominador;
    PHB_ITEM pCWM = NULL;

   /*** EL COMPUTO PUEDE MEZCLAR TIPOS NUMERICOS DIFERENTES, LUEGO, EL RESULTADO SIEMPRE
        SERA DOUBLE POR DEFINICION. EL PROGRAMADOR PODRA CASTEAR AL TIPO NUMERICO QUE
        DESEE CON (DBL X), (LONG X) Y (INT X) 
        
        DEVUELVE UN ARRAY VACIO SI HAY ERROR
        ***/
    
    switch( pDim ){
      case 1 : {
        unsigned int n=1;
        switch( codfun ){
            case 1:
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) 
                           + hb_itemGetND( pBB ) );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                 }
                 break;
            }
            case 2: // resta
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) 
                           - hb_itemGetND( pBB ) );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                 }
                 break;
            }
            case 3:  // multiplicacion
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) 
                           * hb_itemGetND( pBB ) );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                 }
                 break;
            }
            case 4:  // division normal
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    pDenominador = hb_itemGetND( pBB );
                    if ( pDenominador != 0.0 ){
                       hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) 
                                  / pDenominador );
                    }else{
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       hb_itemRelease(pAA);
                       hb_itemRelease(pBB);
                       break;
                    }
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                  }
                  break;
            }
            case 5: // division entera
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    pDenominador = hb_itemGetND( pBB );
                    if ( pDenominador != 0.0 ){
                       hb_arraySetNL( pCWM, n, (long) (hb_itemGetND( pAA ) 
                                  / pDenominador) );
                    }else{
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       hb_itemRelease(pAA);
                       hb_itemRelease(pBB);
                       break;
                    }
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                 }
                 break;
            }
            case 6 : // pow
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    double pNum = hb_itemGetND( pAA );
                    double pPow = hb_itemGetND( pBB );
                    if( pNum == 0.0 && pPow < 0.0 ){
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       hb_itemRelease(pAA);
                       hb_itemRelease(pBB);
                       break;
                    }else if( pNum < 0.0 && pPow != (double)(long)pPow ) {
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       hb_itemRelease(pAA);
                       hb_itemRelease(pBB);
                       break;
                    }
                    else hb_arraySetND( pCWM, n, pow( pNum, pPow ) );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                 }
                 break;
            }
            case 7 : // mod
            {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    double pMod = hb_itemGetND( pBB );
                    if( pMod != 0.0 ){
                        hb_arraySetND( pCWM, n, fmod( hb_itemGetND( pAA ), pMod ) );
                    }else {
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       hb_itemRelease(pAA);
                       hb_itemRelease(pBB);
                       break;
                    }
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                 }
                 break;
            }
        }
        break;
      }
      case 2 :
      {
        unsigned int n=1,m=1;

          switch( codfun ){
             case 1 :
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       
                       hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) 
                            + hb_itemGetND( pBBB ) );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 2 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);   
                       hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) 
                            - hb_itemGetND( pBBB ) );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 3 :
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);   
                       hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) 
                            * hb_itemGetND( pBBB ) );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 4 :
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                         
                       pDenominador = hb_itemGetND( pBBB );
                       if ( pDenominador != 0.0){
                          hb_arraySetND( pCC, m, hb_itemGetND( pAAA )
                                / pDenominador );
                       }else{
                          sw=0;
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pBBB);
                          hb_itemRelease(pAA);
                          hb_itemRelease(pBB);
                          hb_itemRelease(pCC);
                          break;
                       }
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 5 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       pDenominador = hb_itemGetND( hb_itemArrayGet( pBB, m) );
                       if ( pDenominador != 0.0 ){
                          hb_arraySetNL( pCC, m, (long) (hb_itemGetND( hb_itemArrayGet( pAA, m) ) 
                             / pDenominador) );
                       }else{
                          sw=0;
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pBBB);
                          hb_itemRelease(pAA);
                          hb_itemRelease(pBB);
                          hb_itemRelease(pCC);
                          break;
                       }
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 6 : // pow
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m); 
                       
                       double pNum = hb_itemGetND( pAAA );
                       double pPow = hb_itemGetND( pBBB );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       if( pNum == 0.0 && pPow < 0.0 ){
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          hb_itemRelease(pAA);
                          hb_itemRelease(pBB);
                          hb_itemRelease(pCC);
                          sw=0;
                          break;
                       }
                       else if( pNum < 0.0 && pPow != (double)(long)pPow ){
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          hb_itemRelease(pAA);
                          hb_itemRelease(pBB);
                          hb_itemRelease(pCC);
                          sw=0;
                          break;
                       }
                       else hb_arraySetND( pCC, m, pow( pNum, pPow ) );

                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 7 : // mod
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       
                       double pMod = hb_itemGetND( pBBB );
                       if( pMod != 0.0 ){
                            hb_arraySetND( pCC, m, fmod( hb_itemGetND( pAAA ), 
                             pMod ) );
                       }else{ 
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pBBB);
                          hb_itemRelease(pAA);
                          hb_itemRelease(pBB);
                          hb_itemRelease(pCC);
                          sw=0;
                          break;
                       }
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
          }  // switch
          break;
     }
     case 3 :{

        unsigned int n=1,m=1,o=1;

          switch( codfun ){
             case 1 :
             { 
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                       
                          hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) + 
                                    hb_itemGetND( pBBBB ) );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 2 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                       
                          hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) - 
                                    hb_itemGetND( pBBBB ) );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 3 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                       
                          hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) *
                                    hb_itemGetND( pBBBB ) );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 4 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          
                          pDenominador = hb_itemGetND( pBBBB );
                          if ( pDenominador != 0.0){
                          hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) 
                              / pDenominador );
                          }else{
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pBBBB);
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pBBB);
                             hb_itemRelease(pAA);
                             hb_itemRelease(pBB);
                             sw=0;
                             break;
                          }
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 5 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          
                          pDenominador = hb_itemGetND( pBBBB );
                          if ( pDenominador != 0.0){
                             hb_arraySetNL( pCCC, o, (long)(hb_itemGetND( pAAAA ) 
                              / pDenominador ));
                          }else{
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pBBBB);
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pBBB);
                             hb_itemRelease(pAA);
                             hb_itemRelease(pBB);
                             sw=0;
                             break;
                          }
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);   
                 }
                 break;
             }
             case 6 : // pow
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                   
                          double pNum = hb_itemGetND( pAAAA );
                          double pPow = hb_itemGetND( pBBBB );
                          if( pNum == 0.0 && pPow < 0.0 ){
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pBBBB);
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pBBB);
                             hb_itemRelease(pAA);
                             hb_itemRelease(pBB);
                             sw=0;
                             break;
                          }
                          else if( pNum < 0.0 && pPow != (double)(long)pPow ) {
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pBBBB);
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pBBB);
                             hb_itemRelease(pAA);
                             hb_itemRelease(pBB);
                             sw=0;
                             break;
                          }
                          else hb_arraySetND( pCCC, o, pow( pNum, pPow ) );
                          
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC); 
                 }
                 break;
             }
             case 7 : // mod
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          
                          double pMod = hb_itemGetND( pBBBB );
                          if( pMod != 0.0 ){
                             hb_arraySetND( pCCC, o, fmod( hb_itemGetND( pAAAA ), 
                                  pMod ) );
                          }else{ 
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pBBBB);
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pBBB);
                             hb_itemRelease(pAA);
                             hb_itemRelease(pBB);
                             sw=0;
                             break;
                          }
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);   
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC); 
                 }
                 break;
             }
          }
          break;
     }
     case 4 :{

        unsigned int n=1,m=1,o=1,p=1;

          switch( codfun ){
             case 1 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                          
                             hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) + 
                                        hb_itemGetND( pBBBBB ) );
                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC); 
                 }
                 break;
             }
             case 2 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                             
                             hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) - 
                                     hb_itemGetND( pBBBBB ) );
                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 3 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                      
                             hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) *
                                     hb_itemGetND( pBBBBB ) );
                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 4 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                             
                             pDenominador = hb_itemGetND( pBBBBB );
                             if ( pDenominador != 0.0 ){
                                  hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) 
                                        / pDenominador );
                             }else{
                                 hb_itemRelease(pCWM);
                                 pCWM = hb_itemArrayNew( 0 ); // CWM
                                 hb_itemRelease(pAAAAA);
                                 hb_itemRelease(pBBBBB);
                                 hb_itemRelease(pAAAA);
                                 hb_itemRelease(pBBBB);
                                 hb_itemRelease(pAAA);
                                 hb_itemRelease(pBBB);
                                 hb_itemRelease(pAA);
                                 hb_itemRelease(pBB);
                                 sw=0;
                                 break;
                             }
                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          if (!sw) break;
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 5 : 
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                      
                             pDenominador = hb_itemGetND( hb_itemArrayGet( pBBBB, p) );
                             if ( pDenominador != 0.0 ){
                                 hb_arraySetNL( pCCCC, p, (long)( hb_itemGetND( hb_itemArrayGet( pAAAA, p) ) 
                                           / pDenominador ));
                             }else{
                                 hb_itemRelease(pCWM);
                                 pCWM = hb_itemArrayNew( 0 ); // CWM
                                 hb_itemRelease(pAAAAA);
                                 hb_itemRelease(pBBBBB);
                                 hb_itemRelease(pAAAA);
                                 hb_itemRelease(pBBBB);
                                 hb_itemRelease(pAAA);
                                 hb_itemRelease(pBBB);
                                 hb_itemRelease(pAA);
                                 hb_itemRelease(pBB);
                                 sw=0;
                                 break;
                             }
                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          if (!sw) break;
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 6 : // pow
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                             
                             double pNum = hb_itemGetND( pAAAAA );
                             double pPow = hb_itemGetND( pBBBBB );
                             if( pNum == 0.0 && pPow < 0.0 ){
                                hb_itemRelease(pCWM);
                                 pCWM = hb_itemArrayNew( 0 ); // CWM
                                 hb_itemRelease(pAAAAA);
                                 hb_itemRelease(pBBBBB);
                                 hb_itemRelease(pAAAA);
                                 hb_itemRelease(pBBBB);
                                 hb_itemRelease(pAAA);
                                 hb_itemRelease(pBBB);
                                 hb_itemRelease(pAA);
                                 hb_itemRelease(pBB);
                                 sw=0;
                                 break;
                             }
                             else if( pNum < 0.0 && pPow != (double)(long)pPow ) {
                                 hb_itemRelease(pCWM);
                                 pCWM = hb_itemArrayNew( 0 ); // CWM
                                 hb_itemRelease(pAAAAA);
                                 hb_itemRelease(pBBBBB);
                                 hb_itemRelease(pAAAA);
                                 hb_itemRelease(pBBBB);
                                 hb_itemRelease(pAAA);
                                 hb_itemRelease(pBBB);
                                 hb_itemRelease(pAA);
                                 hb_itemRelease(pBB);
                                 sw=0;
                                 break;
                             }
                             else hb_arraySetND( pCCCC, p, pow( pNum, pPow ) );

                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          if (!sw) break;
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
             case 7 : // mod
             {
                 pCWM = hb_itemArrayNew( pRow ); // CWM
                 int sw=1;
                 for( n=1; n<=pRow; n++){
                    PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                    PHB_ITEM pBB = hb_itemArrayGet( pB, n);
                    PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                    for( m=1; m<=pCol; m++){
                       PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                       PHB_ITEM pBBB = hb_itemArrayGet( pBB, m);
                       PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                       for( o=1; o<=pPag; o++){
                          PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                          PHB_ITEM pBBBB = hb_itemArrayGet( pBBB, o);
                          PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                          for( p=1; p<=pBlk; p++){
                             PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                             PHB_ITEM pBBBBB = hb_itemArrayGet( pBBBB, p);
                             double pMod = hb_itemGetND( pBBBBB );
                             if( pMod != 0.0 ){
                                hb_arraySetND( pCCCC, p, fmod( hb_itemGetND( pAAAAA ), 
                                        pMod ) );
                             }else{
                                hb_itemRelease(pCWM);
                                 pCWM = hb_itemArrayNew( 0 ); // CWM
                                 hb_itemRelease(pAAAAA);
                                 hb_itemRelease(pBBBBB);
                                 hb_itemRelease(pAAAA);
                                 hb_itemRelease(pBBBB);
                                 hb_itemRelease(pAAA);
                                 hb_itemRelease(pBBB);
                                 hb_itemRelease(pAA);
                                 hb_itemRelease(pBB);
                                 sw=0;
                                 break;
                             }
                             hb_itemRelease(pAAAAA);
                             hb_itemRelease(pBBBBB);   
                          }
                          if (!sw) break;
                          hb_arraySet( pCCC, o, pCCCC );
                          hb_itemRelease(pAAAA);
                          hb_itemRelease(pBBBB);
                          hb_itemRelease(pCCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCC, m, pCCC );
                       hb_itemRelease(pAAA);
                       hb_itemRelease(pBBB);
                       hb_itemRelease(pCCC);
                    }
                    if (!sw) break;
                    hb_arraySet( pCWM, n, pCC );
                    hb_itemRelease(pAA);
                    hb_itemRelease(pBB);
                    hb_itemRelease(pCC);
                 }
                 break;
             }
          }
          break;
    }
    } // switch

    hb_itemReturnRelease( pCWM );  
}


HB_FUNC( XEMCOMPUTE )
{
    double Escalar    = hb_parnd( 1 ); // Escalar, numero simple
    PHB_ITEM pA       = hb_param( 2, HB_IT_ARRAY ); // B
    PHB_ITEM params   = hb_param( 3, HB_IT_ARRAY ); // PARAMETROS
    
    PHB_ITEM p1 = hb_itemArrayGet( params, 1);
    PHB_ITEM p2 = hb_itemArrayGet( params, 2);
    PHB_ITEM p3 = hb_itemArrayGet( params, 3);
    PHB_ITEM p4 = hb_itemArrayGet( params, 4);
    PHB_ITEM p5 = hb_itemArrayGet( params, 5);
    PHB_ITEM p6 = hb_itemArrayGet( params, 6);
    PHB_ITEM p7 = hb_itemArrayGet( params, 7);
    
    unsigned int pDim = hb_itemGetNI( p1 );   // dimension de matrices
    unsigned int pRow = hb_itemGetNI( p2 );   // rows
    unsigned int pCol = hb_itemGetNI( p3 );   // cols
    unsigned int pPag = hb_itemGetNI( p4 );   // pags
    unsigned int pBlk = hb_itemGetNI( p5 );   // blks
    int codfun        = hb_itemGetNI( p6 ); // suma, resta, multipl.
    int pOrden        = hb_itemGetNI( p7 );  // TIPO: NA O AN
    
    hb_itemRelease(p1);
    hb_itemRelease(p2);
    hb_itemRelease(p3);
    hb_itemRelease(p4);
    hb_itemRelease(p5);
    hb_itemRelease(p6);
    hb_itemRelease(p7);
    
    double pDenominador;
    PHB_ITEM pCWM = NULL;

   /*** EL COMPUTO PUEDE MEZCLAR TIPOS NUMERICOS DIFERENTES, LUEGO, EL RESULTADO SIEMPRE
        SERA DOUBLE POR DEFINICION. EL PROGRAMADOR PODRA CASTEAR AL TIPO NUMERICO QUE
        DESEE CON (DBL X), (LONG X) Y (INT X) ***/
        
    switch( pDim ){
    case 1 :{
       unsigned int n=1;
          switch( codfun ){
            case 1: if ( pOrden == 0 ){  // suma
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) + Escalar );
                         hb_itemRelease(pAA);
                      }
                    }else{
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         hb_arraySetND( pCWM, n, Escalar + hb_itemGetND( pAA ) );
                         hb_itemRelease(pAA);
                      }
                    } 
                    break;
            case 2: if ( pOrden == 0 ){  // resta
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) - Escalar );
                         hb_itemRelease(pAA);
                      }
                    }else{
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         hb_arraySetND( pCWM, n, Escalar - hb_itemGetND( pAA ) );
                         hb_itemRelease(pAA);
                      }
                    }
                    break;
            case 3: if ( pOrden == 0 ){  // multi
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) * Escalar );
                         hb_itemRelease(pAA);
                      }
                    }else{
                      pCWM = hb_itemArrayNew( pRow ); // CWM
                      for( n=1; n<=pRow; n++){
                         PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                         hb_arraySetND( pCWM, n, Escalar * hb_itemGetND( pAA ) );
                         hb_itemRelease(pAA);
                      }
                    }
                    break;
            case 4: if ( pOrden == 0 ){  // division normal
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          hb_arraySetND( pCWM, n, hb_itemGetND( pAA ) / Escalar );
                          hb_itemRelease(pAA);
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          pDenominador = hb_itemGetND( pAA );
                          if ( pDenominador != 0.0){
                             hb_arraySetND( pCWM, n, Escalar / pDenominador );
                          }else{
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          hb_itemRelease(pAA);
                       }
                    }
                    break;
            case 5: if ( pOrden == 0 ){  // division entera
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          hb_arraySetNL( pCWM, n, (long) ( hb_itemGetND( pAA ) / Escalar ));
                          hb_itemRelease(pAA);
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          pDenominador = hb_itemGetND( pAA );
                          if ( pDenominador != 0.0){
                             hb_arraySetNL( pCWM, n, (long) (Escalar / pDenominador) );
                          }else{
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          hb_itemRelease(pAA);
                       }
                    }
                    break;
             case 6 : // pow
             {
                    if ( pOrden == 0 ){  //
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          double pNum = hb_itemGetND( pAA );
                          if( pNum == 0.0 && Escalar < 0.0 ){
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          else if( pNum < 0 && Escalar != (double)(long)Escalar ) {
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          else hb_arraySetND( pCWM, n, pow( pNum, Escalar) );
                          hb_itemRelease(pAA);
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          double pPow = hb_itemGetND( pAA );
                          if( Escalar == 0.0 && pPow < 0.0){
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          else if( Escalar < 0.0 && pPow != (double)(long)pPow ){
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          else hb_arraySetND( pCWM, n, pow(Escalar, pPow) );
                          hb_itemRelease(pAA);
                       }
                    }
                    break;
             }
             case 7 : // mod
             {
                    if ( pOrden == 0 ){  //
                       if( Escalar != 0.0 ){
                          pCWM = hb_itemArrayNew( pRow ); // CWM
                          for( n=1; n<=pRow; n++){
                             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                             hb_arraySetND( pCWM, n, fmod( hb_itemGetND( pAA ), Escalar) );
                             hb_itemRelease(pAA);
                          }
                       }else{
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          break;
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          double pMod = hb_itemGetND( pAA );
                          if( pMod != 0.0 ){
                             hb_arraySetND( pCWM, n, fmod(Escalar, pMod) );
                          }else{ 
                             hb_itemRelease(pCWM);
                             pCWM = hb_itemArrayNew( 0 ); // CWM
                             break;
                          }
                          hb_itemRelease(pAA);
                       }
                    }
                    break;
             }
          }
          break;
    }
    case 2 :{

       unsigned int n=1,m=1;

          switch( codfun ){
             case 1 : if ( pOrden == 0 ){
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) + Escalar );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }else{
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, Escalar + hb_itemGetND( pAAA ) );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }
                      break;
             case 2 : if ( pOrden == 0 ){
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) - Escalar );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }else{
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, Escalar - hb_itemGetND( pAAA ) );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }
                      break;
             case 3 : if ( pOrden == 0 ){
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) * Escalar );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }else{
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, Escalar * hb_itemGetND( pAAA ) );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }
                      break;
             case 4 : if ( pOrden == 0 ){  // division normal
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetND( pCC, m, hb_itemGetND( pAAA ) / Escalar );
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }else{
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         int sw=1;
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               pDenominador = hb_itemGetND( pAAA );
                               hb_itemRelease(pAAA);
                               if ( pDenominador != 0.0){
                                  hb_arraySetND( pCC, m, Escalar / pDenominador );
                               }else{
                                  hb_itemRelease(pCWM);
                                  pCWM = hb_itemArrayNew( 0 ); // CWM
                                  hb_itemRelease(pAA);
                                  hb_itemRelease(pCC);
                                  sw=0;
                                  break;
                               }
                            }
                            if (!sw) break;
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }
                      break;
             case 5 : if ( pOrden == 0 ){  // division entera
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               hb_arraySetNL( pCC, m, (long) ( hb_itemGetND( pAAA ) / Escalar ));
                               hb_itemRelease(pAAA);
                            }
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }else{
                         pCWM = hb_itemArrayNew( pRow ); // CWM
                         int sw=1;
                         for( n=1; n<=pRow; n++){
                            PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                            PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                            for( m=1; m<=pCol; m++){
                               PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                               pDenominador = hb_itemGetND( pAAA );
                               hb_itemRelease(pAAA);
                               if ( pDenominador != 0.0 ){
                                  hb_arraySetNL( pCC, m, (long) (Escalar / pDenominador) );
                               }else{
                                  hb_itemRelease(pCWM);
                                  pCWM = hb_itemArrayNew( 0 ); // CWM
                                  hb_itemRelease(pAA);
                                  hb_itemRelease(pCC);
                                  sw=0;
                                  break;
                               }
                            }
                            if (!sw) break;
                            hb_arraySet( pCWM, n, pCC );
                            hb_itemRelease(pAA);
                            hb_itemRelease(pCC);
                         }
                      }
                      break;
             case 6 : 
             {
                    if ( pOrden == 0 ){  //
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             double pNum = hb_itemGetND( pAAA );
                             hb_itemRelease(pAAA);
                             if( pNum == 0.0 && Escalar < 0.0 ){
                                hb_itemRelease(pCWM);
                                pCWM = hb_itemArrayNew( 0 ); // CWM
                                hb_itemRelease(pAA);
                                hb_itemRelease(pCC);
                                sw=0;
                                break;
                             }
                             else if( pNum < 0 && Escalar != (double)(long)Escalar ) {
                                hb_itemRelease(pCWM);
                                pCWM = hb_itemArrayNew( 0 ); // CWM
                                hb_itemRelease(pAA);
                                hb_itemRelease(pCC);
                                sw=0;
                                break;
                             }
                             else hb_arraySetND( pCC, m, pow( pNum, Escalar) );
                             
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             double pPow = hb_itemGetND( pAAA );
                             hb_itemRelease(pAAA);
                             if( Escalar == 0.0 && pPow < 0.0){
                                hb_itemRelease(pCWM);
                                pCWM = hb_itemArrayNew( 0 ); // CWM
                                hb_itemRelease(pAA);
                                hb_itemRelease(pCC);
                                sw=0;
                                break;
                             }
                             else if( Escalar < 0.0 && pPow != (double)(long)pPow ) {
                                hb_itemRelease(pCWM);
                                pCWM = hb_itemArrayNew( 0 ); // CWM
                                hb_itemRelease(pAA);
                                hb_itemRelease(pCC);
                                sw=0;
                                break;
                             }
                             else hb_arraySetND( pCC, m, pow(Escalar, pPow) );
                             
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }
                    break;
             }
             case 7 : // mod
             {
                    if ( pOrden == 0 ){  //
                       if( Escalar != 0.0 ){
                          pCWM = hb_itemArrayNew( pRow ); // CWM
                          for( n=1; n<=pRow; n++){
                             PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                             PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                             for( m=1; m<=pCol; m++){
                                PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                                hb_arraySetND( pCC, m, fmod( hb_itemGetND( pAAA ), Escalar) );
                                hb_itemRelease(pAAA);
                             }
                             hb_arraySet( pCWM, n, pCC );
                             hb_itemRelease(pAA);
                             hb_itemRelease(pCC);
                          }
                       }else{
                          hb_itemRelease(pCWM);
                          pCWM = hb_itemArrayNew( 0 ); // CWM
                          break;
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             double pMod = hb_itemGetND( pAAA );
                             hb_itemRelease(pAAA);
                             if( pMod != 0.0 ){
                                hb_arraySetND( pCC, m, fmod(Escalar, pMod) );
                             }else{
                                hb_itemRelease(pCWM);
                                pCWM = hb_itemArrayNew( 0 ); // CWM
                                hb_itemRelease(pAA);
                                hb_itemRelease(pCC);
                                sw=0;
                                break;
                             }
                             
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }
                    break;
             }
          }
          break;
    }
    case 3 :{

       unsigned int n=1,m=1,o=1;
       
          switch( codfun ){
             case 1 : if ( pOrden == 0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) + Escalar );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, Escalar + hb_itemGetND( pAAAA ) );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      }
                      break;
             case 2 : if ( pOrden == 0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) - Escalar );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, Escalar - hb_itemGetND( pAAAA ) );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      } 
                      break;
             case 3 : if ( pOrden == 0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) * Escalar );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, Escalar * hb_itemGetND( pAAAA ) );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      } 
                      break;
             case 4 : if ( pOrden == 0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, hb_itemGetND( pAAAA ) / Escalar );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                pDenominador = hb_itemGetND( pAAAA );
                                hb_itemRelease(pAAAA);
                                if ( pDenominador != 0.0){
                                   hb_arraySetND( pCCC, o, Escalar / pDenominador );
                                }else{
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                             }
                             if (!sw) break;
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      } 
                      break;
             case 5 : if ( pOrden == 0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetNL( pCCC, o, (long)(hb_itemGetND( pAAAA ) / Escalar ));
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                pDenominador = hb_itemGetND( pAAAA );
                                hb_itemRelease(pAAAA);
                                if ( pDenominador != 0.0){
                                   hb_arraySetNL( pCCC, o, (long)(Escalar / pDenominador ));
                                }else{
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                      } 
                      break;
             case 6 : 
             {
                    if ( pOrden == 0 ){  //
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                double pNum = hb_itemGetND( pAAAA );
                                hb_itemRelease(pAAAA);
                                if( pNum == 0.0 && Escalar < 0.0 ){
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else if( pNum < 0 && Escalar != (double)(long)Escalar ) {
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else hb_arraySetND( pCCC, o, pow( pNum, Escalar) );
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }else{
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       int sw=1;
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                double pPow = hb_itemGetND( pAAAA );
                                hb_itemRelease(pAAAA);
                                if( Escalar == 0.0 && pPow < 0.0){
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else if( Escalar < 0.0 && pPow != (double)(long)pPow ) {
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else hb_arraySetND( pCCC, o, pow(Escalar, pPow) );
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }
                    break;
             }
             case 7 : // mod
             {
                 if ( pOrden == 0 ){  //
                    if( Escalar != 0.0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                hb_arraySetND( pCCC, o, fmod( hb_itemGetND( pAAAA ), Escalar) );
                                hb_itemRelease(pAAAA);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }else{
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       break;
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    int sw=1;
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             double pMod = hb_itemGetND( pAAAA );
                             hb_itemRelease(pAAAA);
                             if( pMod != 0.0 ){
                                hb_arraySetND( pCCC, o, fmod(Escalar, pMod) );
                             }else{
                                hb_itemRelease(pCWM);
                                pCWM = hb_itemArrayNew( 0 ); // CWM
                                hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                break;
                             }
                             
                          }
                          if (!sw) break;
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }
                 break;
             }
          }
          break;
    }
    case 4 :{

       unsigned int n=1,m=1,o=1,p=1;
       
          switch( codfun ){
             case 1 : 
                 if ( pOrden == 0 ){
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) + Escalar );
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, Escalar + hb_itemGetND( pAAAAA ) );
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }
                 break;
             case 2 : 
                 if ( pOrden == 0 ){
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) - Escalar );
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, Escalar - hb_itemGetND( pAAAAA ) );
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }
                 break;
             case 3 : 
                 if ( pOrden == 0 ){
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) * Escalar );
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, Escalar * hb_itemGetND( pAAAAA ) );
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }
                 break;
             case 4 : 
                 if ( pOrden == 0 ){
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetND( pCCCC, p, hb_itemGetND( pAAAAA ) / Escalar ); 
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    int sw=1;
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                pDenominador = hb_itemGetND( pAAAAA );
                                hb_itemRelease(pAAAAA);
                                if ( pDenominador != 0.0){
                                   hb_arraySetND( pCCCC, p, Escalar / pDenominador );
                                }else{
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 } 
                 break;
             case 5 : 
                 if ( pOrden == 0 ){
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                hb_arraySetNL( pCCCC, p, (long)(hb_itemGetND( pAAAAA ) / Escalar )); 
                                hb_itemRelease(pAAAAA);
                             }
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    int sw=1;
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                pDenominador = hb_itemGetND( pAAAAA );
                                hb_itemRelease(pAAAAA);
                                if ( pDenominador != 0.0){
                                   hb_arraySetNL( pCCCC, p, (long)(Escalar / pDenominador ));
                                }else{
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 } 
                 break;
             case 6 : 
             {
                 if ( pOrden == 0 ){  //
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    int sw=1;
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                double pNum = hb_itemGetND( pAAAAA );
                                hb_itemRelease(pAAAAA);
                                if( pNum == 0.0 && Escalar < 0.0 ){
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else if( pNum < 0 && Escalar != (double)(long)Escalar ){
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else hb_arraySetND( pCCCC, p, pow( pNum, Escalar) );
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    int sw=1;
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                double pPow = hb_itemGetND( pAAAAA );
                                hb_itemRelease(pAAAAA);
                                if( Escalar == 0.0 && pPow < 0.0){
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else if( Escalar < 0.0 && pPow != (double)(long)pPow ) {
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                else hb_arraySetND( pCCCC, p, pow(Escalar, pPow) );
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }
                 break;
             }
             case 7 : // mod
             {
                 if ( pOrden == 0 ){  //
                    if( Escalar != 0.0 ){
                       pCWM = hb_itemArrayNew( pRow ); // CWM
                       for( n=1; n<=pRow; n++){
                          PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                          PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                          for( m=1; m<=pCol; m++){
                             PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                             PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                             for( o=1; o<=pPag; o++){
                                PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                                PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                                for( p=1; p<=pBlk; p++){
                                   PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                   hb_arraySetND( pCCCC, p, fmod( hb_itemGetND( pAAAAA ), Escalar) );
                                   hb_itemRelease(pAAAAA);
                                }
                                hb_arraySet( pCCC, o, pCCCC );
                                hb_itemRelease(pAAAA);
                                hb_itemRelease(pCCCC);
                             }
                             hb_arraySet( pCC, m, pCCC );
                             hb_itemRelease(pAAA);
                             hb_itemRelease(pCCC);
                          }
                          hb_arraySet( pCWM, n, pCC );
                          hb_itemRelease(pAA);
                          hb_itemRelease(pCC);
                       }
                    }else{
                       hb_itemRelease(pCWM);
                       pCWM = hb_itemArrayNew( 0 ); // CWM
                       break;
                    }
                 }else{
                    pCWM = hb_itemArrayNew( pRow ); // CWM
                    int sw=1;
                    for( n=1; n<=pRow; n++){
                       PHB_ITEM pAA = hb_itemArrayGet( pA, n);
                       PHB_ITEM pCC = hb_itemArrayNew( pCol ); // CWM
                       for( m=1; m<=pCol; m++){
                          PHB_ITEM pAAA = hb_itemArrayGet( pAA, m);
                          PHB_ITEM pCCC = hb_itemArrayNew( pPag ); // CWM
                          for( o=1; o<=pPag; o++){
                             PHB_ITEM pAAAA = hb_itemArrayGet( pAAA, o);
                             PHB_ITEM pCCCC = hb_itemArrayNew( pBlk ); // CWM
                             for( p=1; p<=pBlk; p++){
                                PHB_ITEM pAAAAA = hb_itemArrayGet( pAAAA, p);
                                double pMod = hb_itemGetND( pAAAAA );
                                hb_itemRelease(pAAAAA);
                                if( pMod != 0.0 ){
                                   hb_arraySetND( pCCCC, p, fmod(Escalar, pMod) );
                                }else{
                                   hb_itemRelease(pCWM);
                                   pCWM = hb_itemArrayNew( 0 ); // CWM
                                   hb_itemRelease(pAAAA);
                                   hb_itemRelease(pCCCC);
                                   hb_itemRelease(pAAA);
                                   hb_itemRelease(pCCC);
                                   hb_itemRelease(pAA);
                                   hb_itemRelease(pCC);
                                   sw=0;
                                   break;
                                }
                                
                             }
                             if (!sw) break;
                             hb_arraySet( pCCC, o, pCCCC );
                             hb_itemRelease(pAAAA);
                             hb_itemRelease(pCCCC);
                          }
                          if (!sw) break;
                          hb_arraySet( pCC, m, pCCC );
                          hb_itemRelease(pAAA);
                          hb_itemRelease(pCCC);
                       }
                       if (!sw) break;
                       hb_arraySet( pCWM, n, pCC );
                       hb_itemRelease(pAA);
                       hb_itemRelease(pCC);
                    }
                 }
                 break;
             }
          }
          break;
    }
    }  // switch
    hb_itemReturnRelease( pCWM );  
}
/**********    
MANTENER, PORQUE ME SIRVE PARA VER COMO CREAR UN ARRAY DESDE ADENTRO.
    long uiArrayLen = ( long ) hb_arrayLen( pA );

    PHB_ITEM pC = hb_itemArrayNew( uiArrayLen );
    hb_itemReturnRelease( pC );
    long n;
    double nA;

    if(Escalar != 0.0){
       if (param==0){
          for( n=0; n<uiArrayLen; n++){
             double nA = hb_itemGetND( hb_itemArrayGet( pA, n+1) );
             hb_arraySetND( pC, n+1, nA+Escalar );
          }
       }else{
          for( n=0; n<uiArrayLen; n++){
             double nA = hb_itemGetND( hb_itemArrayGet( pA, n+1) );
             hb_arraySetND( pC, n+1, Escalar+nA );
          }
       }
    }else{
       for( n=0; n<uiArrayLen; n++){
          double nA = hb_itemGetND( hb_itemArrayGet( pA, n+1) );
          hb_arraySetND( pC, n+1, nA );
       }
    }
    hb_itemReturnRelease( pC );
} */

/************* queda como referencia: no se usa.
HB_FUNC( XLET2D )
{
   PHB_ITEM pTarget = hb_param( 1, HB_IT_ARRAY ); // DESTINO
   HB_SHORT ndx     = hb_parni( 2 );
   PHB_ITEM pSource = hb_param( 3, HB_IT_ANY ); // FUENTE
   int pRow = hb_parni( 4 );   // rows
   int pRLim= hb_parni( 5 );
   int pCol = hb_parni( 6 );   // cols
   int pCLim= hb_parni( 7 );

   int letOk = 1;
   PHB_ITEM pT,pTT;
   
 //  printf("--> %d,%d,%d,%d,%d,%d,%d,%d\n",pRow,pRLim,pCol,pCLim,pPag,pPLim,pBlk,pBLim);
   
   if ( pRow>0&&pCol>0 ){
         if( pRow <= pRLim && pCol <= pCLim  ){
            pT = hb_itemArrayGet( pTarget, ndx);
            pTT = hb_itemArrayGet( pT, pRow);
            
            if( HB_IS_STRING( pSource ) ){
               hb_arraySetC( pTT, pCol, (const char *)  hb_itemGetCPtr( pSource )  );
            }else if ( HB_IS_NUMINT ( pSource ) ){
               hb_arraySetNInt( pTT, pCol, (HB_MAXINT)  hb_itemGetNInt( pSource )  );
            }else if( HB_IS_NUMERIC( pSource ) ) {
               hb_arraySetND( pTT, pCol, (double)hb_itemGetND( pSource ) );
            }else if( HB_IS_LONG( pSource )  ){
               hb_arraySetNL( pTT, pCol, (long)hb_itemGetNL( pSource ) );
            }else if( HB_IS_LOGICAL( pSource ) ){
               hb_arraySetL( pTT, pCol, (HB_BOOL)hb_itemGetL( pSource ) ) ;
            }
          }else{
            letOk = 0;
          }
    }else{
       letOk = -1;
    }
    hb_itemReturn( pTarget );
    hb_retni( letOk );
}
*/

/******* HASTA AQUI CALCULOS MATRICIALES **********/


HB_FUNC ( XSLEEP )    // segundos
   {
      unsigned int TIEMPO = hb_parni(1); 
      sleep( TIEMPO );
   }

   HB_FUNC ( XUSLEEP )   // microsegundos
   {
      unsigned int TIEMPO = hb_parni(1); 
   usleep( TIEMPO );
}

/*
#ifndef _MAC64_
   #include <termios.h>
   #include <fcntl.h>

   #ifdef _LINUX32_
      #include <sys/io.h>
   #endif

   #ifdef _LINUX64_
      #include </usr/include/x86_64-linux-gnu/sys/io.h>  
   #endif
*/

void do_fun_xgetbit(){
   unsigned x = hb_parni(1);
   int p = hb_parni(2);
   int n = hb_parni(3);
   hb_retni( (x>> (p+1-n)) & ~(~0 << n) );
}
HB_FUNC ( XGETBIT )
{
   do_fun_xgetbit();
}

/*
 * PosChar(), PosDel(), PosIns() and PosRepl() CT3 functions
 *
 * Copyright 2001 IntTec GmbH, Neunlindenstr 32, 79106 Freiburg, Germany
 *        Author: Martin Vogel <vogel@inttec.de>
 */
HB_FUNC( XPOSCHAR )
{

   if( hb_parclen( 1 ) > 0 )
   {
      if( ( hb_parclen( 2 ) > 0 ) || HB_ISNUM( 2 ) )
      {
         const char * pcString = hb_parc( 1 );
         HB_SIZE sStrLen = hb_parclen( 1 );
         char * pcRet;
         char cReplace;
         HB_SIZE sPosition;

         if( HB_ISCHAR( 2 ) )
            cReplace = *( hb_parc( 2 ) );
         else
            cReplace = ( char ) ( hb_parns( 2 ) % 256 );

         if( HB_ISNUM( 3 ) )
         {
            sPosition = hb_parns( 3 );
            if( sPosition == 0 )
               sPosition = sStrLen;
         }
         else
            sPosition = sStrLen;

         pcRet = ( char * ) hb_xgrab( sStrLen + 1 );
         hb_xmemcpy( pcRet, pcString, sStrLen );
         *( pcRet + sPosition - 1 ) = cReplace;

         hb_storclen( pcRet, sStrLen, 1 );
         hb_retclen_buffer( pcRet, sStrLen );
      }
      else
      {
            hb_retclen( hb_parc( 1 ), hb_parclen( 1 ) );
      }
   }
   else
   {
         hb_retc_null();
   }
}

/******* MATEMATICAAS COMUNES Y NO TAN COMUNES ********/

 
/**************************************************************************************/ 
/*
 * CT3 Number and bit manipulation functions:
 *       NumAnd(), NumOr(), NumXor(), NUMNOT()
 *       ClearBit(), SetBit()
 *
 * Copyright 2007 Przemyslaw Czerpak <druzus / at / priv.onet.pl>
 */

HB_BOOL ct_numParam( int iParam, HB_MAXINT * plNum )
{
   const char * szHex = hb_parc( iParam );

   if( szHex )
   {
      *plNum = 0;
      while( *szHex == ' ' )
         szHex++;
      while( *szHex )
      {
         char c = *szHex++;

         if( c >= '0' && c <= '9' )
            c -= '0';
         else if( c >= 'A' && c <= 'F' )
            c -= 'A' - 10;
         else if( c >= 'a' && c <= 'f' )
            c -= 'a' - 10;
         else
            break;
         *plNum = ( *plNum << 4 ) | c;
         iParam = 0;
      }
      if( ! iParam )
         return HB_TRUE;
   }
   else if( HB_ISNUM( iParam ) )
   {
      *plNum = hb_parnint( iParam );
      return HB_TRUE;
   }

   *plNum = -1;
   return HB_FALSE;
}

HB_FUNC( XNUMAND )
{
   int iPCount = hb_pcount(), i = 1;
   HB_MAXINT lValue = -1, lNext = 0;

   if( iPCount && ct_numParam( 1, &lValue ) )
   {
      while( --iPCount && ct_numParam( ++i, &lNext ) )
         lValue &= lNext;

      if( iPCount )
         lValue = -1;
   }
   hb_retnint( lValue );
}

HB_FUNC( XNUMOR )
{
   int iPCount = hb_pcount(), i = 1;
   HB_MAXINT lValue = -1, lNext = 0;

   if( iPCount && ct_numParam( 1, &lValue ) )
   {
      while( --iPCount && ct_numParam( ++i, &lNext ) )
         lValue |= lNext;

      if( iPCount )
         lValue = -1;
   }
   hb_retnint( lValue );
}

HB_FUNC( XNUMXOR )
{
   int iPCount = hb_pcount(), i = 1;
   HB_MAXINT lValue = -1, lNext = 0;

   if( iPCount && ct_numParam( 1, &lValue ) )
   {
      while( --iPCount && ct_numParam( ++i, &lNext ) )
         lValue ^= lNext;

      if( iPCount )
         lValue = -1;
   }
   hb_retnint( lValue );
}

HB_FUNC( XNUMNOT )
{
   HB_MAXINT lValue;

   if( ct_numParam( 1, &lValue ) )
      lValue = ( ~lValue ) & 0xffffffff;

   hb_retnint( lValue );
}

HB_FUNC( XCLEARBIT )
{
   int iPCount = hb_pcount(), iBit, i = 1;
   HB_MAXINT lValue;

   if( ct_numParam( 1, &lValue ) )
   {
      while( --iPCount )
      {
         iBit = hb_parni( ++i );
         if( iBit < 1 || iBit > 64 )
            break;
         lValue &= ~( ( ( HB_MAXINT ) 1 ) << ( iBit - 1 ) );
      }

      if( iPCount )
         lValue = -1;
   }

   hb_retnint( lValue );
}

HB_FUNC( XSETBIT )
{
   int iPCount = hb_pcount(), iBit, i = 1;
   HB_MAXINT lValue;

   if( ct_numParam( 1, &lValue ) )
   {
      while( --iPCount )
      {
         iBit = hb_parni( ++i );
         if( iBit < 1 || iBit > 64 )
            break;
         lValue |= ( ( HB_MAXINT ) 1 ) << ( iBit - 1 );
      }

      if( iPCount )
         lValue = -1;
   }

   hb_retnint( lValue );
}

/*****************************************************************/

/*
 * Harbour Project source code:
 * Stack structure
 *
 * Copyright 2000 Jose Lalin <dezac@corevia.com>
 * www - http://www.harbour-project.org
*/
/* StackNew() --> <aStack>
*/
HB_FUNC( STACKNEW )
{
   hb_itemReturnRelease( hb_itemArrayNew( 0 ) ); /* Create array */
}

/*  StackPush( <aStack>, <xValue> ) --> <aStack>
*/
HB_FUNC( STACKPUSH )
{
   hb_arrayAdd( hb_param( 1, HB_IT_ARRAY ), 
                hb_param( 2, HB_IT_ANY ) );
}

/* StackPop( <aStack> ) --> <xValue>
   Returns NIL if the stack is empty
*/
HB_FUNC( STACKPOP )
{
   PHB_ITEM pArray = hb_param( 1, HB_IT_ARRAY );
   long ulLen = hb_arrayLen( pArray );
   PHB_ITEM pLast = hb_itemNew( NULL );

   if( ulLen )
   {
      hb_arrayLast( pArray, pLast );
      hb_arrayDel( pArray, ulLen );
      --ulLen;
      hb_arraySize( pArray, HB_MAX( ulLen, 0 ) );
   }

   hb_itemReturnRelease( pLast );
}

/* StackIsEmpty( <aStack> ) --> <lEmpty>
*/
/*HB_FUNC( STACKISEMPTY )
{
   hb_retl( hb_arrayLen( hb_param( 1, HB_IT_ARRAY ) ) == 0 );
}*/

/* StackTop( <aStack> ) --> <xValue>
   Returns the top item
*/
/*HB_FUNC( STACKTOP )
{
   PHB_ITEM pLast = hb_itemNew( NULL );

   hb_arrayLast( hb_param( 1, HB_IT_ARRAY ), pLast );

   hb_itemReturnRelease( pLast );
}*/


HB_FUNC( N2COLOR )
{
   int iColor = hb_parnidef( 1, -1 );

   if( iColor >= 0x00 && iColor <= 0xff )
   {
      char szColorString[ 10 ];
      hb_gtColorsToString( &iColor, 1, szColorString, 10 );
      hb_retc( szColorString );
   }
   else
      hb_retc_null();
}

HB_FUNC( CMDSYSTEM )
{
  PHB_ITEM pText = hb_param(1,HB_IT_STRING);
  const char * string = hb_itemGetCPtr( pText );
  //int l = hb_itemGetCLen( pText );
  int ret;
  ret=system(string);
  hb_retni(ret);
}

HB_FUNC ( STRCUT )
{
  const char *linea = hb_parc(1);
  int DESDE=hb_parni(2);
  int HASTA=hb_parni(3); 
  int LEN=hb_parni(4); 
 /* unsigned short DESDE=hb_parni(2);
  unsigned short HASTA=hb_parni(3); 
  unsigned short LEN=hb_parni(4); */

  char * buf;
  buf = FUNSTRCUT(linea, DESDE<=0 ? 1 : DESDE, HASTA, LEN);
  const char * Ret = buf;
  hb_retc(Ret);
  free(buf);
}

/*****************************************
  quita una direccion del stack temporal
  no sabe si la direccion pertenece a
  dicho stack, por eso debe verificar con
  TOPCWM.
  Este proceso es por direccion DIR.
******************************************/
HB_FUNC ( CMPCWM )
{
 unsigned short DIR=hb_parni(1); 
 unsigned short CWM=hb_parni(2);
 unsigned short TOPCWM=hb_parni(3); 

 CWM -= DIR > TOPCWM ? 1 : 0; 
 
 hb_retni(CWM); 
}


#pragma ENDDUMP 

/*
///
#define BLACK        0
#define BLUE         1
#define GREEN        2
#define CYAN         3
#define RED          4
#define MAGENTA      5
#define BROWN        6
#define LIGHTGRAY    7
#define DARKGRAY     8
#define LIGHTBLUE    9
#define LIGHTGREEN   10
#define LIGHTCYAN    11
#define LIGHTRED     12
#define LIGHTMAGENTA 13
#define YELLOW       14
#define WHITE        15
// Special attributes 
#define UNDERLINE    64
#define BLINK        128

// Special font attributes 
#define UNDERLINE_ATTR 4
#define BLINK_ATTR     5
#define BRILLO_ATTR    1

// Bright colors start in color number 9 
#define BRILLO_MIN     9

HB_FUNC( GOTOXY )
{
   HB_INT x = hb_parns( 1 );
   HB_INT y = hb_parns( 2 );
   
   printf("\033[%d;%dH", y, x);
}

HB_FUNC( COLORTEXT )
{
  HB_INT color = hb_parns( 1 );

  static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};
  
  int atrval=0;
  if (color & UNDERLINE)
    atrval=UNDERLINE_ATTR;
  else if (color & BLINK)
    atrval=BLINK_ATTR;
  else if (color>=BRILLO_MIN)
    atrval=BRILLO_ATTR;

  color=ansicolors[color & 15];
  
  printf("\033[%d;%dm", atrval, color);
}

HB_FUNC( COLORBACK )
{
  HB_INT color = hb_parns( 1 );
  
  static const char ansicolors[16] = {30, 34, 32, 36, 31, 35, 33, 37, 0, 34, 32, 36, 31, 35, 33, 37};
  
  if (color<BRILLO_MIN)
    {				   
      color=ansicolors[color & 15]+10;
  
      printf("\033[%dm", color);
    }
}

HB_FUNC( WRITE )
{

//   HB_LONG elem = hb_parns( 1 );
 //  PHB_ITEM nDimx2 = hb_param( 5, HB_IT_ANY );

//   printf("%ld\n",elem); 
   
   PHB_ITEM pNumber = hb_param( 1, HB_IT_NUMERIC );

   if( pNumber )
   {
//      int iWidth;
//      int iDec;

//      hb_itemGetNLen( pNumber, &iWidth, &iDec );

      if( HB_IS_INTEGER( pNumber ) )
      {
         int iNumber = hb_itemGetNI( pNumber );
         printf("%d",iNumber);
      }
      else if( HB_IS_LONG( pNumber ) )
      {
         long long int lNumber = hb_itemGetNInt( pNumber );
         printf("%Ld",lNumber);
      }
      else
      {
         double dNumber = hb_itemGetND( pNumber );

         printf("%lf",dNumber);
      }
   }   
}

HB_FUNC( IMPRIMECONSOLA ) 
{
  PHB_ITEM pText = hb_param(1,HB_IT_STRING);
 
  const char * string = hb_itemGetCPtr( pText );
  //int l = hb_itemGetCLen( pText );

  printf("%s",string);

}

#pragma ENDDUMP

*/
